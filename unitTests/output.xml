<?xml version='1.0' encoding='utf8'?>
<xml><function index="0" id="d7/def/structBBP_1_1std_1_1AbstractGCEntry_1aae987edc86de3193b2bd0f9266c09876" name="~AbstractGCEntry" args="()" definition="virtual BBP::std::AbstractGCEntry::~AbstractGCEntry">			virtual ~AbstractGCEntry()

			{};
</function><function index="1" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1a8ca25cf116cdbb92f7ed4702a62e9d11" name="BinaryApplication" args="(std::conststring fileName, std::size_t extraSegments, std::size_t extraSections, std::size_t extraSymbols)" definition="BBP::esa::BinaryApplication::BinaryApplication">#include "FileSys.h"

#include "Lex.h"



namespace BBP

{

	namespace esa

	{



		struct dataEntry

		{
</function><function index="2" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1aae12c360f177a00ed49d6a3280951a67" name="addDataToSection" args="(std::index_t, dataEntry &amp;)" definition="void BBP::esa::BinaryApplication::addDataToSection">			std::conststring data;



			// The size of the data to be encoded into data

			std::size_t size;



			// The actual location of the data within rodata

			std::c_string elfData;



			// The offset within rodata of this data

			std::offset_t offset;



			// The corresponding symbol for this entry

			std::index_t symbol;



			// The type of symbol. Yeah yeah it is stored in builder.symbols[symbol].info() but I dont give a shit I want it here fuck you.

			std::byte type;



			// The data hash

			std::hash_t hash;



			dataEntry(std::conststring msg, std::size_t len)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(0),

				hash(0)

			{}



			dataEntry(std::conststring msg, std::size_t len, std::byte _type)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(_type),

				hash(0)

			{}



		};



		class BinaryApplication

		{

		public:
</function><function index="3" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1addb7c5388abf47164e9041129185748c" name="addSymbol" args="(dataEntry &amp;, std::conststring)" definition="void BBP::esa::BinaryApplication::addSymbol">			BinaryApplication(std::conststring fileName, std::size_t extraSegments, std::size_t extraSections, std::size_t extraSymbols);



			// Adds some data into a section

			void addDataToSection(std::index_t, dataEntry &amp;);



			// Adds a symbol (and does not emit symbol data! use addDataToSection for that!)

			void addSymbol(dataEntry &amp;, std::conststring);

			void addSymbol(dataEntry &amp;, std::conststring, std::index_t);



			// Emits a symbol, at the specified section, including its data. Also provides ability to override symbol.

			void emitSymbol(std::index_t, dataEntry &amp;, std::conststring, std::hash_t, std::index_t);



			// Add symbol hash

			bool emitSymbolHash(std::hash_t hash, std::index_t symbol);



			// Shorthand for emitting source file name
</function><function index="4" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1a60bc8a3f3015af99daaa18ca276d8b21" name="addSymbol" args="(dataEntry &amp;, std::conststring, std::index_t)" definition="void BBP::esa::BinaryApplication::addSymbol">

			// add N amount of symbols

			void appendSymbols(std::index_t);



			// Name mangling functions

			void mangle(std::conststring name, std::Lexer::lex_thing &amp;thing, dataEntry &amp;entry);



			// This is what builds the application

			std::ELF::ELFBuilder builder;

			std::Stack&lt;std::string_element&gt; builderStack;

			std::FILE file;



			// Static string to mangle names

			std::static_string&lt;128&gt; mangledPage;

			std::Stack&lt;std::string_element&gt; mangled;
</function><function index="5" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1a2aab74057b13ed7c631a8cf3ebf96d16" name="emitSymbol" args="(std::index_t, dataEntry &amp;, std::conststring, std::hash_t, std::index_t)" definition="void BBP::esa::BinaryApplication::emitSymbol" /><function index="6" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1af27670d4109d1543aa48c2a4f1cb98e9" name="emitSymbolHash" args="(std::hash_t hash, std::index_t symbol)" definition="bool BBP::esa::BinaryApplication::emitSymbolHash" /><function index="7" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1adf380f7751bf6f0f640ae6beaa678470" name="setSource" args="(std::conststring)" definition="void BBP::esa::BinaryApplication::setSource">			void save();

			void close();



		};



	}
</function><function index="8" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1a196824b68fa368b0fdb865f34ad980d8" name="appendSymbols" args="(std::index_t)" definition="void BBP::esa::BinaryApplication::appendSymbols">

#endif</function><function index="9" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1a1937e2e6c48c065edd37d61fc2c6f812" name="mangle" args="(std::conststring name, std::Lexer::lex_thing &amp;thing, dataEntry &amp;entry)" definition="void BBP::esa::BinaryApplication::mangle">#include "FileSys.h"

#include "Lex.h"



namespace BBP

{

	namespace esa

	{



		struct dataEntry

		{

			// The data to be encoded into data

			std::conststring data;



			// The size of the data to be encoded into data

			std::size_t size;



			// The actual location of the data within rodata

			std::c_string elfData;



			// The offset within rodata of this data

			std::offset_t offset;



			// The corresponding symbol for this entry

			std::index_t symbol;



			// The type of symbol. Yeah yeah it is stored in builder.symbols[symbol].info() but I dont give a shit I want it here fuck you.

			std::byte type;



			// The data hash

			std::hash_t hash;



			dataEntry(std::conststring msg, std::size_t len)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(0),

				hash(0)

			{}



			dataEntry(std::conststring msg, std::size_t len, std::byte _type)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(_type),

				hash(0)

			{}



		};



		class BinaryApplication

		{

		public:



			BinaryApplication(std::conststring fileName, std::size_t extraSegments, std::size_t extraSections, std::size_t extraSymbols);



			// Adds some data into a section

			void addDataToSection(std::index_t, dataEntry &amp;);



			// Adds a symbol (and does not emit symbol data! use addDataToSection for that!)

			void addSymbol(dataEntry &amp;, std::conststring);

			void addSymbol(dataEntry &amp;, std::conststring, std::index_t);



			// Emits a symbol, at the specified section, including its data. Also provides ability to override symbol.

			void emitSymbol(std::index_t, dataEntry &amp;, std::conststring, std::hash_t, std::index_t);



			// Add symbol hash

			bool emitSymbolHash(std::hash_t hash, std::index_t symbol);



			// Shorthand for emitting source file name

			void setSource(std::conststring);



			// add N amount of symbols

			void appendSymbols(std::index_t);



			// Name mangling functions

			void mangle(std::conststring name, std::Lexer::lex_thing &amp;thing, dataEntry &amp;entry);



			// This is what builds the application

			std::ELF::ELFBuilder builder;

			std::Stack&lt;std::string_element&gt; builderStack;

			std::FILE file;



			// Static string to mangle names
</function><function index="10" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1ad36d1a9ace4e2aaae92bebdce1227914" name="save" args="()" definition="void BBP::esa::BinaryApplication::save" /><function index="11" id="d0/dbe/classBBP_1_1esa_1_1BinaryApplication_1aa3e4150fb317dd2705a9b5a6e6389b26" name="close" args="()" definition="void BBP::esa::BinaryApplication::close" /><function index="12" id="d7/da4/classCunts_1a4ac9b7a4801141c49bb5a225f52247b0" name="allOfYou" args="()" definition="static void Cunts::allOfYou">	static inline void allOfYou()

	{}
</function><function index="13" id="d1/dcf/structBBP_1_1esa_1_1dataEntry_1afc78ac98ae2c2889270bba3b285352b7" name="dataEntry" args="(std::conststring msg, std::size_t len)" definition="BBP::esa::dataEntry::dataEntry">			dataEntry(std::conststring msg, std::size_t len)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(0),

				hash(0)

			{}
</function><function index="14" id="d1/dcf/structBBP_1_1esa_1_1dataEntry_1a9f846daa8f060bd289323d01455c5acc" name="dataEntry" args="(std::conststring msg, std::size_t len, std::byte _type)" definition="BBP::esa::dataEntry::dataEntry">			dataEntry(std::conststring msg, std::size_t len, std::byte _type)

				: data(msg),

				size(len),

				elfData(nullptr),

				offset(0),

				symbol(0),

				type(_type),

				hash(0)

			{}
</function><function index="15" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a43e89d15168860841898bdaa41f63928" name="ELFBuilder" args="(ResourceManager *res, std::size_t segCount, std::size_t secCount, std::size_t symCount)" definition="BBP::std::ELF::ELFBuilder::ELFBuilder">

#include "ELF32.h"



namespace BBP

{

	namespace std

	{

		namespace ELF

		{

			class ELFBuilder;

			class SegmentBuilder;

			class SectionBuilder;

			class SymbolBuilder;





			class ELFBuilder

			{

			public:



				ELFBuilder(ResourceManager *res, std::size_t segCount, std::size_t secCount, std::size_t symCount);

				ELFBuilder(PAGE&lt;string_element&gt; *_file, ResourceManager *res);



				// The resource manager in use by the ELF

				ResourceManager *allocator;



				// The file in question

				PAGE&lt;string_element&gt; file;



				// Keep track of endiann-ness

				bool Endian;



				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;


</function><function index="16" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a9be7c78361492e5f615263fac98a6fe8" name="ELFBuilder" args="(PAGE&lt; string_element &gt; *_file, ResourceManager *res)" definition="BBP::std::ELF::ELFBuilder::ELFBuilder">				Stack&lt;SectionBuilder&gt; sections;



				// Symbol stack (pointers to save memory)

				Stack&lt;SymbolBuilder&gt; symbols;



				std::byte ident(std::byte);

				void ident(std::byte, std::byte);



				std::halfword type(void);

				void type(std::halfword);



				std::halfword machine(void);

				void machine(std::halfword);



				std::word version(void);

				void version(std::word);



				std::address_t entry(void);

				void entry(std::address_t);



				std::offset_t phoff(void);

				void phoff(std::offset_t);



				std::offset_t shoff(void);

				void shoff(std::offset_t);



				std::word flags(void);

				void flags(std::word);



				std::halfword ehsize(void);

				void ehsize(std::halfword);



				std::halfword phentsize(void);

				void phentsize(std::halfword);



				std::halfword phnum(void);

				void phnum(std::halfword);



				std::halfword shentsize(void);

				void shentsize(std::halfword);



				std::halfword shnum(void);

				void shnum(std::halfword);



				std::halfword shstrndx(void);

				void shstrndx(std::halfword);



				// Functions to move around various components

				void emitHeader();

				std::size_t calculateHeaderSize();

				void emitELFHeaders();



				// Variables to keep track of various standard sections

				std::index_t shstrtab;

				std::index_t strtab;

				std::index_t symtab;

				std::index_t hashtab;



				std::index_t bss;

				std::index_t data;

				std::index_t data1;

				std::index_t fini;

				std::index_t init;

				std::index_t rodata;

				std::index_t rodata1;

				std::index_t text;

				std::index_t rel_text;



				SectionBuilder &amp;_shstrtab();

				SectionBuilder &amp;_strtab();

				SectionBuilder &amp;_symtab();

				SectionBuilder &amp;_hashtab();



				SectionBuilder &amp;_bss();

				SectionBuilder &amp;_data();

				SectionBuilder &amp;_data1();

				SectionBuilder &amp;_fini();

				SectionBuilder &amp;_init();

				SectionBuilder &amp;_rodata();

				SectionBuilder &amp;_rodata1();

				SectionBuilder &amp;_text();

				SectionBuilder &amp;_rel_text();



				// Recalculates the various offsets used

				void recalculateOffsets(std::offset_t after, std::size_t byHowMuch);



				// Creates a standard application

				void formStandard(std::size_t textSize, std::size_t dataSize, std::size_t rodataSize, std::size_t bssSize);



				// Renames a symbol

				void renameSymbol(std::index_t, conststring);



				void close();



				std::size_t symbolCount;



				// Hashing stuff

				std::word hashBucketCount;

				std::word hashChainCount;



			private:

				PAGE&lt;SegmentBuilder&gt; segPages;

				PAGE&lt;SectionBuilder&gt; secPages;

				PAGE&lt;SymbolBuilder&gt; symPages;



				bool isMemUnique;



			};





			class SymbolBuilder

			{

			public:



				std::word name(void);

				void name(std::word);



				std::address_t value(void);

				void value(std::address_t);



				std::word size(void);

				void size(std::word);



				std::byte info(void);

				void info(std::byte);



				std::byte other(void);

				void other(std::byte);



				std::halfword shndx(void);

				void shndx(std::halfword);



				PAGE&lt;string_element&gt; header; // This is the actual 'header' of the segment. Stored as binary representation as would be on file.

				Stack&lt;string_element&gt; stack; // This is a stack representation of the data

				PAGE&lt;string_element&gt; data; // The data this segment contains. 



				void close();



				// The owner of this segment

				ELFBuilder *elf;



				bool isMemUnique;



				SymbolBuilder(ELFBuilder *, std::offset_t); // Segment is already found within elf

				SymbolBuilder(ELFBuilder *, string_element *, std::size_t); // Segment is not within elf



				/*

				* If true, 'data' and 'header' are alloc'ed externally and is not contained within 'elf'.

				* If false, 'data' and 'header' point to an internal section of 'elf'.

				*

				* This is used to read and write data to and from the elf.

				*/





			};





			class SectionBuilder

			{

			public:



				std::word name(void);

				void name(std::word);



				std::word type(void);

				void type(std::word);



				std::word flags(void);

				void flags(std::word);



				std::address_t addr(void);

				void addr(std::address_t);



				std::offset_t offset(void);

				void offset(std::offset_t);



				std::word size(void);
</function><function index="17" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a83d5af2fc078db5b80fdd88e3c9820cf" name="ident" args="(std::byte)" definition="BBP::std::byte BBP::std::ELF::ELFBuilder::ident">				std::halfword ehsize(void);
</function><function index="18" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1ae4da0b2f40130bacd1c9d32fedeefb5c" name="ident" args="(std::byte, std::byte)" definition="void BBP::std::ELF::ELFBuilder::ident">				void ehsize(std::halfword);
</function><function index="19" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1afc691ed888793002bc1eeac36be461c5" name="type" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::type">				std::halfword phentsize(void);
</function><function index="20" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a52a3e49cef06ce764a539769dca4eae5" name="type" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::type">				void phentsize(std::halfword);
</function><function index="21" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a8331ad88c01e561d7a65e9a09ae356ca" name="machine" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::machine">				std::halfword phnum(void);
</function><function index="22" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a6e562b9a500b2478ae838c87c3fb3477" name="machine" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::machine">				void phnum(std::halfword);
</function><function index="23" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a4259ab8567b1a91eae57637b069f6580" name="version" args="(void)" definition="BBP::std::word BBP::std::ELF::ELFBuilder::version">				std::halfword shentsize(void);
</function><function index="24" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1aff0f9a0e5110f287d5a5ef5b36c9cc5d" name="version" args="(std::word)" definition="void BBP::std::ELF::ELFBuilder::version">				void shentsize(std::halfword);
</function><function index="25" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a875594f682445c582dfa17432639a68c" name="entry" args="(void)" definition="BBP::std::address_t BBP::std::ELF::ELFBuilder::entry">				std::halfword shnum(void);
</function><function index="26" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a212c16462e7dcd629ba82ece4cf3ef62" name="entry" args="(std::address_t)" definition="void BBP::std::ELF::ELFBuilder::entry">				void shnum(std::halfword);
</function><function index="27" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a831146e80b722eacb7767a22507da6b5" name="phoff" args="(void)" definition="BBP::std::offset_t BBP::std::ELF::ELFBuilder::phoff">				std::halfword shstrndx(void);
</function><function index="28" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1aeb1d6badd15ac5e2e536760279ab0943" name="phoff" args="(std::offset_t)" definition="void BBP::std::ELF::ELFBuilder::phoff">				void shstrndx(std::halfword);
</function><function index="29" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a5604c352d9c887660d677ff048e13153" name="shoff" args="(void)" definition="BBP::std::offset_t BBP::std::ELF::ELFBuilder::shoff">				// Functions to move around various components
</function><function index="30" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a11874eb0a4b5a9b1d2bcf3579b6becbe" name="shoff" args="(std::offset_t)" definition="void BBP::std::ELF::ELFBuilder::shoff">				void emitHeader();
</function><function index="31" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a393508aee1aab2a178951be96366a4d5" name="flags" args="(void)" definition="BBP::std::word BBP::std::ELF::ELFBuilder::flags">				void emitELFHeaders();
</function><function index="32" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a8881867962e73abd45a54474ce909cf1" name="flags" args="(std::word)" definition="void BBP::std::ELF::ELFBuilder::flags">
</function><function index="33" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a9ba08ee7f68e4afe0096dac9cc115607" name="ehsize" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::ehsize">				std::index_t shstrtab;
</function><function index="34" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1ab6187004421a14a10cd48057d6f3eb81" name="ehsize" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::ehsize">				std::index_t strtab;
</function><function index="35" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1acac63e64243d4126380dc890683bfa66" name="phentsize" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::phentsize">				std::index_t hashtab;
</function><function index="36" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a773d8f5044ec6ff3bb7d96d06e9a2235" name="phentsize" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::phentsize">
</function><function index="37" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a3f5be41608ef64c87d0c48cdaab4b6f8" name="phnum" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::phnum">				std::index_t data;
</function><function index="38" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1aaad7fe20a039b19f13d1ac9b52f7e791" name="phnum" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::phnum">				std::index_t data1;
</function><function index="39" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1abbc0f11da49eb83a92059c2ff412e49d" name="shentsize" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::shentsize">				std::index_t init;
</function><function index="40" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1abcf3e28a84675d78e7bae97cea68228b" name="shentsize" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::shentsize">				std::index_t rodata;
</function><function index="41" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a00013d07c04c5454c55732f076b6b205" name="shnum" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::shnum">				std::index_t text;
</function><function index="42" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a8d89e03e60382bb740ddf3a22f58bbf3" name="shnum" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::shnum">				std::index_t rel_text;
</function><function index="43" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a627eb7c3bd51fe7629ae609c52382a67" name="shstrndx" args="(void)" definition="BBP::std::halfword BBP::std::ELF::ELFBuilder::shstrndx">				SectionBuilder &amp;_shstrtab();
</function><function index="44" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1ab3f0fcac2e1f61141516894d6c17d911" name="shstrndx" args="(std::halfword)" definition="void BBP::std::ELF::ELFBuilder::shstrndx">				SectionBuilder &amp;_strtab();
</function><function index="45" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1ab901b617454344776884381c1c7fb4ca" name="emitHeader" args="()" definition="void BBP::std::ELF::ELFBuilder::emitHeader">				// The file in question

				PAGE&lt;string_element&gt; file;



				// Keep track of endiann-ness

				bool Endian;



				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;



				// Section stack (pointers to save memory)

				Stack&lt;SectionBuilder&gt; sections;



				// Symbol stack (pointers to save memory)

				Stack&lt;SymbolBuilder&gt; symbols;



				std::byte ident(std::byte);

				void ident(std::byte, std::byte);



				std::halfword type(void);

				void type(std::halfword);



				std::halfword machine(void);

				void machine(std::halfword);



				std::word version(void);

				void version(std::word);



				std::address_t entry(void);

				void entry(std::address_t);



				std::offset_t phoff(void);

				void phoff(std::offset_t);



				std::offset_t shoff(void);

				void shoff(std::offset_t);



				std::word flags(void);

				void flags(std::word);



				std::halfword ehsize(void);

				void ehsize(std::halfword);



				std::halfword phentsize(void);

				void phentsize(std::halfword);



				std::halfword phnum(void);

				void phnum(std::halfword);



				std::halfword shentsize(void);

				void shentsize(std::halfword);



				std::halfword shnum(void);

				void shnum(std::halfword);



				std::halfword shstrndx(void);

				void shstrndx(std::halfword);



				// Functions to move around various components

				void emitHeader();

				std::size_t calculateHeaderSize();

				void emitELFHeaders();



				// Variables to keep track of various standard sections
</function><function index="46" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a1dcc45e16a692ab4c03e83b3495dbff4" name="calculateHeaderSize" args="()" definition="BBP::std::size_t BBP::std::ELF::ELFBuilder::calculateHeaderSize">				ELFBuilder(ResourceManager *res, std::size_t segCount, std::size_t secCount, std::size_t symCount);

				ELFBuilder(PAGE&lt;string_element&gt; *_file, ResourceManager *res);



				// The resource manager in use by the ELF
</function><function index="47" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a641af35e476cf59f478e3d1cb057afb5" name="emitELFHeaders" args="()" definition="void BBP::std::ELF::ELFBuilder::emitELFHeaders">#include "Memory.h"

#include "Strings.h"

#include "Resources.h"



#include "ELF32.h"



namespace BBP

{

	namespace std

	{

		namespace ELF

		{

			class ELFBuilder;

			class SegmentBuilder;

			class SectionBuilder;

			class SymbolBuilder;





			class ELFBuilder

			{

			public:
</function><function index="48" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1aa406686c72f9f1f10cd8cba2d4bdd726" name="recalculateOffsets" args="(std::offset_t after, std::size_t byHowMuch)" definition="void BBP::std::ELF::ELFBuilder::recalculateOffsets">				std::index_t strtab;

				std::index_t symtab;

				std::index_t hashtab;



				std::index_t bss;

				std::index_t data;

				std::index_t data1;

				std::index_t fini;

				std::index_t init;

				std::index_t rodata;

				std::index_t rodata1;

				std::index_t text;

				std::index_t rel_text;



				SectionBuilder &amp;_shstrtab();

				SectionBuilder &amp;_strtab();

				SectionBuilder &amp;_symtab();

				SectionBuilder &amp;_hashtab();



				SectionBuilder &amp;_bss();

				SectionBuilder &amp;_data();

				SectionBuilder &amp;_data1();

				SectionBuilder &amp;_fini();

				SectionBuilder &amp;_init();

				SectionBuilder &amp;_rodata();

				SectionBuilder &amp;_rodata1();

				SectionBuilder &amp;_text();

				SectionBuilder &amp;_rel_text();



				// Recalculates the various offsets used

				void recalculateOffsets(std::offset_t after, std::size_t byHowMuch);



				// Creates a standard application
</function><function index="49" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1af7708be2d563034de2361e84eacdb48d" name="formStandard" args="(std::size_t textSize, std::size_t dataSize, std::size_t rodataSize, std::size_t bssSize)" definition="void BBP::std::ELF::ELFBuilder::formStandard">				PAGE&lt;string_element&gt; header; // This is the actual 'header' of the segment. Stored as binary representation as would be on file.

				Stack&lt;string_element&gt; stack; // This is a stack representation of the data

				PAGE&lt;string_element&gt; data; // The data this segment contains. 



				void close();



				// The owner of this segment

				ELFBuilder *elf;



				bool isMemUnique;



				SegmentBuilder(ELFBuilder *, std::offset_t); // Segment is already found within elf

				SegmentBuilder(ELFBuilder *, string_element *, std::size_t); // Segment is not within elf



				/*

				* If true, 'data' and 'header' are alloc'ed externally and is not contained within 'elf'.

				* If false, 'data' and 'header' point to an internal section of 'elf'.

				* 

				* This is used to read and write data to and from the elf.

				*/



			};



		}

	}

}



#endif
</function><function index="50" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a036a64649877e44e7e4958f508ce034f" name="renameSymbol" args="(std::index_t, conststring)" definition="void BBP::std::ELF::ELFBuilder::renameSymbol" /><function index="51" id="d3/d63/classBBP_1_1std_1_1ELF_1_1ELFBuilder_1a0e05c3b97f4227c9924841c5e170ae82" name="close" args="()" definition="void BBP::std::ELF::ELFBuilder::close">				void link(std::word);



				std::word info(void);

				void info(std::word);



				std::word addralign(void);

				void addralign(std::word);



				std::word entsize(void);

				void entsize(std::word);



				PAGE&lt;string_element&gt; header; // This is the actual 'header' of the segment. Stored as binary representation as would be on file.

				Stack&lt;string_element&gt; stack; // This is a stack representation of the data

				PAGE&lt;string_element&gt; data; // The data this segment contains. 



				void Append(std::size_t);

				void Extend(std::size_t);

				void close();



				// The owner of this segment

				ELFBuilder *elf;

				bool isMemUnique;



				SectionBuilder(ELFBuilder *, std::offset_t); // Segment is already found within elf

				SectionBuilder(ELFBuilder *, string_element *, std::size_t); // Segment is not within elf



				/*

				* If true, 'data' and 'header' are alloc'ed externally and is not contained within 'elf'.

				* If false, 'data' and 'header' point to an internal section of 'elf'.

				*

				* This is used to read and write data to and from the elf.

				*/



			};





			class SegmentBuilder

			{

			public:

				

				void Append(std::size_t dataSize);



				std::word type(void);

				void type(std::word);


</function><function index="52" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1af0f792b159cceacff13793211821ee22" name="esaProcessor" args="()" definition="BBP::esa::esaProcessor::esaProcessor">			std::conststring setDereference(std::word address, std::word, std::byte count);

			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;



			// Backend procedure functions

			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);



			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;
</function><function index="53" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a63f090f895980cdf3c56e9f52e5d6a63" name="translate" args="(std::PATH &amp;, std::PATH &amp;)" definition="BBP::std::errno_t BBP::esa::esaProcessor::translate">			PROCEDURE_T,

			INSTRUCTION_T

		};



		enum SYMBOL_TYPE : uint32_t

		{

			// Defines the access of a symbol. If none used, it is a quasi-symbol.

			SYMTACC_VIRTUAL = 0b1,

			SYMTACC_STATIC = SYMTACC_VIRTUAL &lt;&lt; 1,



			// Modifiers that can be used

			SYMTMOD_EXTERN = SYMTACC_STATIC &lt;&lt; 1,

			SYMTMOD_CONST = SYMTMOD_EXTERN &lt;&lt; 1,

			SYMTMOD_STATIC = SYMTMOD_CONST &lt;&lt; 1,


</function><function index="54" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1af38a06bf937bacbc5db9413c2c9db248" name="unkown" args="(std::index_t from, std::index_t to)" definition="BBP::std::conststring BBP::esa::esaProcessor::unkown">			std::Lexer::lex_thing symbol;

			std::STATIC_PAGE&lt;std::byte, 512&gt; symbolDataPage;

			std::Stack&lt;std::byte&gt; symbolDataByte;

			std::PAGE&lt;std::halfword&gt; symbolDataPageHalfword;

			std::Stack&lt;std::halfword&gt; symbolDataHalfword;

			std::PAGE&lt;std::word&gt; symbolDataPageWord;

			std::Stack&lt;std::word&gt; symbolDataWord;


</function><function index="55" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a57d3e592694b8e7468ce2bbaecfea887" name="resolve" args="(std::index_t from, std::index_t to)" definition="BBP::std::conststring BBP::esa::esaProcessor::resolve" /><function index="56" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a85ea0ce6c3fe59531cc7dac6c94a5fd8" name="numerical" args="(std::Lexer::numerical_t numerical, bool isFloat)" definition="BBP::std::conststring BBP::esa::esaProcessor::numerical">#ifndef BBP_STDLIB_ELSA

#define BBP_STDLIB_ELSA



namespace BBP

{

	namespace esa

	{


</function><function index="57" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a8884b186d1988809313a4114f644364e" name="numericalArgument" args="(std::Lexer::numerical_t numerical, bool isFloat)" definition="BBP::std::conststring BBP::esa::esaProcessor::numericalArgument">		{

		public:



			// The parser, and its initializer.

			std::Lexer::lex_context esaParser;

			esaProcessor();



			// Public API

			std::errno_t translate(std::PATH &amp;, std::PATH&amp; );



			// Secondary functions

			std::conststring unkown(std::index_t from, std::index_t to);

			std::conststring resolve(std::index_t from, std::index_t to);

			std::conststring numerical(std::Lexer::numerical_t numerical, bool isFloat);

			std::conststring numericalArgument(std::Lexer::numerical_t numerical, bool isFloat);

			void reserveRegisters();



			// Linker stuff

			void emitRelocation(std::index_t);

			std::word calculateArgumentOffset();

			std::word calculateAbsoluteArgumentOffset();


</function><function index="58" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a8416cc323f2fd3f9a6cf72b73aeeaef9" name="reserveRegisters" args="()" definition="void BBP::esa::esaProcessor::reserveRegisters">			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;



			// Backend procedure functions

			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);



			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;

			std::Lexer::lex_keywordhandle firstCloser;

			std::STATIC_PAGE&lt;std::Lexer::lex_keywordhandle, 32&gt; delimiterPage;

			std::Stack&lt;std::Lexer::lex_keywordhandle&gt; delimiterStack;

			std::word delimiterDepth = 0;



			bool lineIsDefiningSymbolDefinition;

			bool lineIsDefiningInstruction;

			bool lineIsDefiningProcedure;



		};



		// Types used by ELSA

		enum ELSA_TYPE : uint32_t

		{

			UNKOWN_T,

			SYMBOL_T,
</function><function index="59" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a8d460cabf300a0edc2357eacdae4646e" name="emitRelocation" args="(std::index_t)" definition="void BBP::esa::esaProcessor::emitRelocation">			std::conststring setHash(std::hash_t);

			std::conststring setSize(std::size_t);

			void addWord(std::word);

			void addHalfword(std::halfword);

			void addByte(std::byte);

			std::conststring addNumerical(std::Lexer::numerical_t, bool);

			void resetSymbol();

			std::index_t lookupSymbol(std::index_t, std::index_t, std::word *, std::hash_t &amp;);



			// Frontend: Instruction building functions

			void setInstruction(userspace::OPCODES, std::byte, std::nibble flags, std::nibble args);

			void expectLiteral(std::byte n);

			void expectAddress(std::byte n);

			void expectAny(std::byte n);

			void surpressArgCountWarning(std::byte n);
</function><function index="60" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a51819f1bfee1b178381104ad84cfb97d" name="calculateArgumentOffset" args="()" definition="BBP::std::word BBP::esa::esaProcessor::calculateArgumentOffset" /><function index="61" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1ad8c3bca0dfb62e333282fa375ae094a7" name="calculateAbsoluteArgumentOffset" args="()" definition="BBP::std::word BBP::esa::esaProcessor::calculateAbsoluteArgumentOffset" /><function index="62" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1aed2f4d7f4f3f2df0d78efbe0e0a6b18a" name="addReservedIdentifier" args="(std::conststring, userspace::Instruction::Arg)" definition="void BBP::esa::esaProcessor::addReservedIdentifier" /><function index="63" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1ad7231383e52c9c6ff776caacfd0e7cd6" name="markVirtual" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::markVirtual">			void reserveRegisters();



			// Linker stuff

			void emitRelocation(std::index_t);

			std::word calculateArgumentOffset();

			std::word calculateAbsoluteArgumentOffset();



			// Symbol building Variables

			std::Lexer::lex_thing symbol;

			std::STATIC_PAGE&lt;std::byte, 512&gt; symbolDataPage;

			std::Stack&lt;std::byte&gt; symbolDataByte;

			std::PAGE&lt;std::halfword&gt; symbolDataPageHalfword;

			std::Stack&lt;std::halfword&gt; symbolDataHalfword;

			std::PAGE&lt;std::word&gt; symbolDataPageWord;

			std::Stack&lt;std::word&gt; symbolDataWord;



			// Instruction building variables

			userspace::Instruction instruction;

			std::byte atArgument;

			bool surpress[8];



			// Procedure building variables

			std::index_t startedAt;

			std::index_t endedAt;

			std::hash_t procedureHash;
</function><function index="64" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1abe77cbc85874becd623c99cf2114f411" name="markExtern" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::markExtern">			std::index_t procedureNameStart;

			std::index_t procedureNameEnd;

			std::byte procedureArgumentCount;

			bool doneDeclaringProcedure;

			bool externProcedure;



			// Generic Symbol Stuff

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; reservedIdentifiers;

			std::STATIC_PAGE&lt;userspace::Instruction::Arg, 256&gt; reservedIdentifiersValues;

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; quasiSymbols;

			std::STATIC_PAGE&lt;std::word, 256&gt; quasiSymbolValues;

			void addReservedIdentifier(std::conststring, userspace::Instruction::Arg);



			// Frontend: Symbol building functions

			std::conststring markVirtual();

			std::conststring markExtern();

			std::conststring markConst();

			std::conststring markStatic();

			std::conststring setHash(std::hash_t);

			std::conststring setSize(std::size_t);

			void addWord(std::word);

			void addHalfword(std::halfword);
</function><function index="65" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1adff4e819106da5ac0f0c71b0f50c866a" name="markConst" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::markConst">#include "Opcodes.h"



#ifndef BBP_STDLIB_ELSA

#define BBP_STDLIB_ELSA



namespace BBP

{

	namespace esa

	{



		class esaProcessor

		{

		public:



			// The parser, and its initializer.

			std::Lexer::lex_context esaParser;

			esaProcessor();



			// Public API

			std::errno_t translate(std::PATH &amp;, std::PATH&amp; );



			// Secondary functions

			std::conststring unkown(std::index_t from, std::index_t to);

			std::conststring resolve(std::index_t from, std::index_t to);

			std::conststring numerical(std::Lexer::numerical_t numerical, bool isFloat);
</function><function index="66" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1aaded9a5bf8df647fb15960d767a99a3b" name="markStatic" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::markStatic">			std::conststring addNumerical(std::Lexer::numerical_t, bool);

			void resetSymbol();

			std::index_t lookupSymbol(std::index_t, std::index_t, std::word *, std::hash_t &amp;);



			// Frontend: Instruction building functions

			void setInstruction(userspace::OPCODES, std::byte, std::nibble flags, std::nibble args);

			void expectLiteral(std::byte n);

			void expectAddress(std::byte n);

			void expectAny(std::byte n);

			void surpressArgCountWarning(std::byte n);

			void surpressArgCountWarning();

			std::conststring setArg(userspace::Instruction::Arg &amp;arg);

			std::conststring setReference(std::word address, std::word page);

			std::conststring setDereference(std::word address, std::word, std::byte count);

			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;


</function><function index="67" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1acd7475e57d1e7357089a8c46d6cb53f1" name="setHash" args="(std::hash_t)" definition="BBP::std::conststring BBP::esa::esaProcessor::setHash">			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);
</function><function index="68" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a325768f56af4fd769104446162976fa3" name="setSize" args="(std::size_t)" definition="BBP::std::conststring BBP::esa::esaProcessor::setSize">			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;

			std::Lexer::lex_keywordhandle firstCloser;

			std::STATIC_PAGE&lt;std::Lexer::lex_keywordhandle, 32&gt; delimiterPage;

			std::Stack&lt;std::Lexer::lex_keywordhandle&gt; delimiterStack;

			std::word delimiterDepth = 0;



			bool lineIsDefiningSymbolDefinition;

			bool lineIsDefiningInstruction;

			bool lineIsDefiningProcedure;



		};



		// Types used by ELSA

		enum ELSA_TYPE : uint32_t

		{

			UNKOWN_T,

			SYMBOL_T,

			PROCEDURE_T,

			INSTRUCTION_T

		};



		enum SYMBOL_TYPE : uint32_t

		{

			// Defines the access of a symbol. If none used, it is a quasi-symbol.

			SYMTACC_VIRTUAL = 0b1,

			SYMTACC_STATIC = SYMTACC_VIRTUAL &lt;&lt; 1,



			// Modifiers that can be used

			SYMTMOD_EXTERN = SYMTACC_STATIC &lt;&lt; 1,

			SYMTMOD_CONST = SYMTMOD_EXTERN &lt;&lt; 1,

			SYMTMOD_STATIC = SYMTMOD_CONST &lt;&lt; 1,



			// The size of the symbol

			SYMTSZ_NIL = SYMTMOD_STATIC &lt;&lt; 1,

			SYMTSZ_DN = SYMTSZ_NIL &lt;&lt; 1,

			SYMTSZ_DB = SYMTSZ_DN &lt;&lt; 1,

			SYMTSZ_DH = SYMTSZ_DB &lt;&lt; 1,

			SYMTSZ_DI = SYMTSZ_DH &lt;&lt; 1,

			SYMTSZ_DA = SYMTSZ_DI &lt;&lt; 1,

			SYMTSZ_DW = SYMTSZ_DA &lt;&lt; 1

		};
</function><function index="69" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a5f1fc3fb60f0720e4d2271f226e67a06" name="addWord" args="(std::word)" definition="void BBP::esa::esaProcessor::addWord">



		// Extern symbols

		extern esaProcessor processor;




</function><function index="70" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a392baee83da9ce3255c7f5e61157be49" name="addHalfword" args="(std::halfword)" definition="void BBP::esa::esaProcessor::addHalfword">}



#endif
</function><function index="71" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1aeeb7b99d62bba9b4b5e446358560e6c4" name="addByte" args="(std::byte)" definition="void BBP::esa::esaProcessor::addByte" /><function index="72" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a162947cc5e869642c242a00f0f9279d3" name="addNumerical" args="(std::Lexer::numerical_t, bool)" definition="BBP::std::conststring BBP::esa::esaProcessor::addNumerical" /><function index="73" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a98ed0b2d234bcbe32e6c394c178ed970" name="resetSymbol" args="()" definition="void BBP::esa::esaProcessor::resetSymbol" /><function index="74" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a7d9e5e59bdee6120db48df50a95fc471" name="lookupSymbol" args="(std::index_t, std::index_t, std::word *, std::hash_t &amp;)" definition="BBP::std::index_t BBP::esa::esaProcessor::lookupSymbol">			userspace::Instruction instruction;

			std::byte atArgument;

			bool surpress[8];



			// Procedure building variables

			std::index_t startedAt;

			std::index_t endedAt;

			std::hash_t procedureHash;

			std::STATIC_PAGE&lt;std::string_element, 100&gt; procedureName;

			std::index_t procedureNameStart;

			std::index_t procedureNameEnd;

			std::byte procedureArgumentCount;

			bool doneDeclaringProcedure;

			bool externProcedure;



			// Generic Symbol Stuff

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; reservedIdentifiers;

			std::STATIC_PAGE&lt;userspace::Instruction::Arg, 256&gt; reservedIdentifiersValues;

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; quasiSymbols;

			std::STATIC_PAGE&lt;std::word, 256&gt; quasiSymbolValues;

			void addReservedIdentifier(std::conststring, userspace::Instruction::Arg);



			// Frontend: Symbol building functions

			std::conststring markVirtual();

			std::conststring markExtern();

			std::conststring markConst();

			std::conststring markStatic();

			std::conststring setHash(std::hash_t);

			std::conststring setSize(std::size_t);

			void addWord(std::word);

			void addHalfword(std::halfword);

			void addByte(std::byte);

			std::conststring addNumerical(std::Lexer::numerical_t, bool);

			void resetSymbol();

			std::index_t lookupSymbol(std::index_t, std::index_t, std::word *, std::hash_t &amp;);



			// Frontend: Instruction building functions

			void setInstruction(userspace::OPCODES, std::byte, std::nibble flags, std::nibble args);

			void expectLiteral(std::byte n);

			void expectAddress(std::byte n);

			void expectAny(std::byte n);

			void surpressArgCountWarning(std::byte n);

			void surpressArgCountWarning();

			std::conststring setArg(userspace::Instruction::Arg &amp;arg);

			std::conststring setReference(std::word address, std::word page);

			std::conststring setDereference(std::word address, std::word, std::byte count);

			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;



			// Backend procedure functions

			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);



			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;

			std::Lexer::lex_keywordhandle firstCloser;

			std::STATIC_PAGE&lt;std::Lexer::lex_keywordhandle, 32&gt; delimiterPage;

			std::Stack&lt;std::Lexer::lex_keywordhandle&gt; delimiterStack;

			std::word delimiterDepth = 0;



			bool lineIsDefiningSymbolDefinition;

			bool lineIsDefiningInstruction;

			bool lineIsDefiningProcedure;



		};



		// Types used by ELSA

		enum ELSA_TYPE : uint32_t

		{

			UNKOWN_T,

			SYMBOL_T,

			PROCEDURE_T,

			INSTRUCTION_T

		};



		enum SYMBOL_TYPE : uint32_t

		{

			// Defines the access of a symbol. If none used, it is a quasi-symbol.

			SYMTACC_VIRTUAL = 0b1,

			SYMTACC_STATIC = SYMTACC_VIRTUAL &lt;&lt; 1,



			// Modifiers that can be used

			SYMTMOD_EXTERN = SYMTACC_STATIC &lt;&lt; 1,

			SYMTMOD_CONST = SYMTMOD_EXTERN &lt;&lt; 1,

			SYMTMOD_STATIC = SYMTMOD_CONST &lt;&lt; 1,



			// The size of the symbol

			SYMTSZ_NIL = SYMTMOD_STATIC &lt;&lt; 1,

			SYMTSZ_DN = SYMTSZ_NIL &lt;&lt; 1,

			SYMTSZ_DB = SYMTSZ_DN &lt;&lt; 1,

			SYMTSZ_DH = SYMTSZ_DB &lt;&lt; 1,

			SYMTSZ_DI = SYMTSZ_DH &lt;&lt; 1,

			SYMTSZ_DA = SYMTSZ_DI &lt;&lt; 1,

			SYMTSZ_DW = SYMTSZ_DA &lt;&lt; 1

		};







		// Extern symbols

		extern esaProcessor processor;





	}

}



#endif
</function><function index="75" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1af5a0bf5373e689b0354a8d415458243d" name="setInstruction" args="(userspace::OPCODES, std::byte, std::nibble flags, std::nibble args)" definition="void BBP::esa::esaProcessor::setInstruction" /><function index="76" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a7417023ec3879b792e5dcd8a38d82a0f" name="expectLiteral" args="(std::byte n)" definition="void BBP::esa::esaProcessor::expectLiteral" /><function index="77" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a5b2083d61beeb51402c7edff61d5bb63" name="expectAddress" args="(std::byte n)" definition="void BBP::esa::esaProcessor::expectAddress" /><function index="78" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1abce0386e9793d3ede152a5d2d8d20ad5" name="expectAny" args="(std::byte n)" definition="void BBP::esa::esaProcessor::expectAny" /><function index="79" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a34f3903e7cc37c39cde9396418a590f0" name="surpressArgCountWarning" args="(std::byte n)" definition="void BBP::esa::esaProcessor::surpressArgCountWarning" /><function index="80" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a3961f2af2f42c747107031aeb1ec6cfd" name="surpressArgCountWarning" args="()" definition="void BBP::esa::esaProcessor::surpressArgCountWarning" /><function index="81" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a326f2387d3ba45b9ba1f74bbb7ac23b0" name="setArg" args="(userspace::Instruction::Arg &amp;arg)" definition="BBP::std::conststring BBP::esa::esaProcessor::setArg" /><function index="82" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a7d364a8a5c499473c6e41764f4f201e4" name="setReference" args="(std::word address, std::word page)" definition="BBP::std::conststring BBP::esa::esaProcessor::setReference" /><function index="83" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a46213e7fde7272e128422a9cf4e595b6" name="setDereference" args="(std::word address, std::word, std::byte count)" definition="BBP::std::conststring BBP::esa::esaProcessor::setDereference" /><function index="84" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a59f17bb0cb6b43cd9c4bc00c1ae3a3bb" name="logInstruction" args="()" definition="void BBP::esa::esaProcessor::logInstruction" /><function index="85" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a9c87a4c904394702ed260d02a3cca938" name="resetInstruction" args="()" definition="void BBP::esa::esaProcessor::resetInstruction" /><function index="86" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1aa57aff72c2c8ab0a35bd8a4bffd32d01" name="setProcedureAddress" args="()" definition="void BBP::esa::esaProcessor::setProcedureAddress" /><function index="87" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a6018e61deb0c0d40a713c7c343a7a7f0" name="setProcedureIdentifier" args="(std::index_t, std::index_t, std::hash_t)" definition="void BBP::esa::esaProcessor::setProcedureIdentifier" /><function index="88" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a2c2e1d319b45856c99b3c95d1b822f9b" name="setProcedureArgCount" args="(std::byte)" definition="void BBP::esa::esaProcessor::setProcedureArgCount" /><function index="89" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a66b8c3e4d0b81bd4e8a399bfb8c3c5c3" name="setupBackend" args="(std::conststring, std::size_t, std::size_t, std::size_t)" definition="void BBP::esa::esaProcessor::setupBackend">			// Procedure building variables

			std::index_t startedAt;

			std::index_t endedAt;

			std::hash_t procedureHash;

			std::STATIC_PAGE&lt;std::string_element, 100&gt; procedureName;
</function><function index="90" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a6c03c71d935df80b40838ddac6733450" name="saveAndClose" args="()" definition="void BBP::esa::esaProcessor::saveAndClose">			std::index_t procedureNameEnd;

			std::byte procedureArgumentCount;

			bool doneDeclaringProcedure;

			bool externProcedure;



			// Generic Symbol Stuff

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; reservedIdentifiers;

			std::STATIC_PAGE&lt;userspace::Instruction::Arg, 256&gt; reservedIdentifiersValues;
</function><function index="91" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1ae7cd5f1fefe82579ae0dba1776d9b19e" name="discardAndClose" args="()" definition="void BBP::esa::esaProcessor::discardAndClose">			std::STATIC_PAGE&lt;std::word, 256&gt; quasiSymbolValues;

			void addReservedIdentifier(std::conststring, userspace::Instruction::Arg);



			// Frontend: Symbol building functions

			std::conststring markVirtual();

			std::conststring markExtern();

			std::conststring markConst();
</function><function index="92" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a6356368fbf1217095c3ed89086288606" name="buildSymbol" args="()" definition="BBP::std::errno_t BBP::esa::esaProcessor::buildSymbol">			std::conststring setArg(userspace::Instruction::Arg &amp;arg);

			std::conststring setReference(std::word address, std::word page);

			std::conststring setDereference(std::word address, std::word, std::byte count);

			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;



			// Backend procedure functions

			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);



			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;

			std::Lexer::lex_keywordhandle firstCloser;

			std::STATIC_PAGE&lt;std::Lexer::lex_keywordhandle, 32&gt; delimiterPage;

			std::Stack&lt;std::Lexer::lex_keywordhandle&gt; delimiterStack;

			std::word delimiterDepth = 0;



			bool lineIsDefiningSymbolDefinition;

			bool lineIsDefiningInstruction;

			bool lineIsDefiningProcedure;



		};



		// Types used by ELSA

		enum ELSA_TYPE : uint32_t

		{

			UNKOWN_T,

			SYMBOL_T,

			PROCEDURE_T,

			INSTRUCTION_T

		};



		enum SYMBOL_TYPE : uint32_t

		{

			// Defines the access of a symbol. If none used, it is a quasi-symbol.

			SYMTACC_VIRTUAL = 0b1,

			SYMTACC_STATIC = SYMTACC_VIRTUAL &lt;&lt; 1,



			// Modifiers that can be used

			SYMTMOD_EXTERN = SYMTACC_STATIC &lt;&lt; 1,

			SYMTMOD_CONST = SYMTMOD_EXTERN &lt;&lt; 1,

			SYMTMOD_STATIC = SYMTMOD_CONST &lt;&lt; 1,



			// The size of the symbol

			SYMTSZ_NIL = SYMTMOD_STATIC &lt;&lt; 1,

			SYMTSZ_DN = SYMTSZ_NIL &lt;&lt; 1,

			SYMTSZ_DB = SYMTSZ_DN &lt;&lt; 1,

			SYMTSZ_DH = SYMTSZ_DB &lt;&lt; 1,

			SYMTSZ_DI = SYMTSZ_DH &lt;&lt; 1,

			SYMTSZ_DA = SYMTSZ_DI &lt;&lt; 1,

			SYMTSZ_DW = SYMTSZ_DA &lt;&lt; 1

		};







		// Extern symbols

		extern esaProcessor processor;





	}

}



#endif
</function><function index="93" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a553f28a74233c3b7f4268343e1037f55" name="emitProcedure" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::emitProcedure" /><function index="94" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1adab5f68614326a968bc96042947e7baa" name="emitInstruction" args="()" definition="BBP::std::conststring BBP::esa::esaProcessor::emitInstruction" /><function index="95" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1ada73c0b220f39b769e10d29bdd45ce39" name="saveIdentifier" args="(std::index_t start, std::index_t end)" definition="void BBP::esa::esaProcessor::saveIdentifier">#define BBP_STDLIB_ELSA



namespace BBP

{

	namespace esa

	{
</function><function index="96" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1aa78bbecef432f11d558f7b108084528f" name="hashIdentifier" args="(BBP::esa::dataEntry &amp;)" definition="BBP::std::hash_t BBP::esa::esaProcessor::hashIdentifier">			std::conststring unkown(std::index_t from, std::index_t to);

			std::conststring resolve(std::index_t from, std::index_t to);

			std::conststring numerical(std::Lexer::numerical_t numerical, bool isFloat);

			std::conststring numericalArgument(std::Lexer::numerical_t numerical, bool isFloat);

			void reserveRegisters();



			// Linker stuff

			void emitRelocation(std::index_t);

			std::word calculateArgumentOffset();

			std::word calculateAbsoluteArgumentOffset();



			// Symbol building Variables

			std::Lexer::lex_thing symbol;

			std::STATIC_PAGE&lt;std::byte, 512&gt; symbolDataPage;

			std::Stack&lt;std::byte&gt; symbolDataByte;

			std::PAGE&lt;std::halfword&gt; symbolDataPageHalfword;

			std::Stack&lt;std::halfword&gt; symbolDataHalfword;

			std::PAGE&lt;std::word&gt; symbolDataPageWord;

			std::Stack&lt;std::word&gt; symbolDataWord;



			// Instruction building variables

			userspace::Instruction instruction;

			std::byte atArgument;

			bool surpress[8];
</function><function index="97" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1ad01106b1ee15d1306e16a5c5ce2fd8cd" name="mangleSymbolIdentifier" args="(BBP::esa::dataEntry &amp;entry)" definition="BBP::std::conststring BBP::esa::esaProcessor::mangleSymbolIdentifier">		class esaProcessor

		{

		public:



			// The parser, and its initializer.

			std::Lexer::lex_context esaParser;

			esaProcessor();



			// Public API

			std::errno_t translate(std::PATH &amp;, std::PATH&amp; );


</function><function index="98" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1af4b6ff6fcde258840f428e3ea3493758" name="ExpectDelimiters" args="(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop)" definition="BBP::std::errno_t BBP::esa::esaProcessor::ExpectDelimiters">

#ifndef BBP_STDLIB_ELSA

#define BBP_STDLIB_ELSA



namespace BBP

{

	namespace esa

	{



		class esaProcessor

		{

		public:



			// The parser, and its initializer.

			std::Lexer::lex_context esaParser;

			esaProcessor();



			// Public API

			std::errno_t translate(std::PATH &amp;, std::PATH&amp; );



			// Secondary functions

			std::conststring unkown(std::index_t from, std::index_t to);

			std::conststring resolve(std::index_t from, std::index_t to);

			std::conststring numerical(std::Lexer::numerical_t numerical, bool isFloat);

			std::conststring numericalArgument(std::Lexer::numerical_t numerical, bool isFloat);

			void reserveRegisters();



			// Linker stuff

			void emitRelocation(std::index_t);

			std::word calculateArgumentOffset();

			std::word calculateAbsoluteArgumentOffset();



			// Symbol building Variables

			std::Lexer::lex_thing symbol;

			std::STATIC_PAGE&lt;std::byte, 512&gt; symbolDataPage;

			std::Stack&lt;std::byte&gt; symbolDataByte;

			std::PAGE&lt;std::halfword&gt; symbolDataPageHalfword;

			std::Stack&lt;std::halfword&gt; symbolDataHalfword;

			std::PAGE&lt;std::word&gt; symbolDataPageWord;

			std::Stack&lt;std::word&gt; symbolDataWord;



			// Instruction building variables

			userspace::Instruction instruction;

			std::byte atArgument;

			bool surpress[8];



			// Procedure building variables

			std::index_t startedAt;

			std::index_t endedAt;

			std::hash_t procedureHash;

			std::STATIC_PAGE&lt;std::string_element, 100&gt; procedureName;

			std::index_t procedureNameStart;

			std::index_t procedureNameEnd;

			std::byte procedureArgumentCount;

			bool doneDeclaringProcedure;

			bool externProcedure;



			// Generic Symbol Stuff

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; reservedIdentifiers;

			std::STATIC_PAGE&lt;userspace::Instruction::Arg, 256&gt; reservedIdentifiersValues;

			std::STATIC_PAGE&lt;std::hash_t, 256&gt; quasiSymbols;

			std::STATIC_PAGE&lt;std::word, 256&gt; quasiSymbolValues;

			void addReservedIdentifier(std::conststring, userspace::Instruction::Arg);



			// Frontend: Symbol building functions

			std::conststring markVirtual();

			std::conststring markExtern();

			std::conststring markConst();

			std::conststring markStatic();

			std::conststring setHash(std::hash_t);

			std::conststring setSize(std::size_t);

			void addWord(std::word);

			void addHalfword(std::halfword);

			void addByte(std::byte);

			std::conststring addNumerical(std::Lexer::numerical_t, bool);

			void resetSymbol();

			std::index_t lookupSymbol(std::index_t, std::index_t, std::word *, std::hash_t &amp;);



			// Frontend: Instruction building functions

			void setInstruction(userspace::OPCODES, std::byte, std::nibble flags, std::nibble args);

			void expectLiteral(std::byte n);

			void expectAddress(std::byte n);

			void expectAny(std::byte n);

			void surpressArgCountWarning(std::byte n);

			void surpressArgCountWarning();

			std::conststring setArg(userspace::Instruction::Arg &amp;arg);

			std::conststring setReference(std::word address, std::word page);

			std::conststring setDereference(std::word address, std::word, std::byte count);

			void logInstruction();

			void resetInstruction();



			// Frontend: Procedure building functions

			void setProcedureAddress();

			void setProcedureIdentifier(std::index_t, std::index_t, std::hash_t);

			void setProcedureArgCount(std::byte);



			// Backend functions

			esa::BinaryApplication *application;

			void setupBackend(std::conststring, std::size_t, std::size_t, std::size_t);

			void saveAndClose();

			void discardAndClose();

			std::errno_t buildSymbol();



			// Frontend: Routines

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineStartsPage;

			std::STATIC_PAGE&lt;std::index_t, 32&gt; routineSubscriberCount;

			std::Stack&lt;std::index_t&gt; routineStarts;

			std::STATIC_PAGE&lt;std::index_t, 128&gt; subscribersPage;

			std::Stack&lt;std::index_t&gt; subscribers;



			// Backend procedure functions

			std::conststring emitProcedure();



			// Backend instruction function

			std::conststring emitInstruction();



			void saveIdentifier(std::index_t start, std::index_t end);

			std::hash_t hashIdentifier(BBP::esa::dataEntry &amp;);

			BBP::std::conststring mangleSymbolIdentifier(BBP::esa::dataEntry &amp;entry);



			// Auxiliary functions

			std::errno_t ExpectDelimiters(std::Lexer::lex_context *, std::index_t argc, std::Lexer::lex_keywordhandle const argv[], bool singleLine, std::index_t min, std::index_t maxDepth, std::Lexer::lex_keywordhandle escape, std::Lexer::lex_keywordhandle stop);

			std::conststring includeFile(std::Lexer::lex_context *, std::index_t);

			bool includeFromPath(std::FILE &amp;, std::PATH &amp;, std::Stack&lt;std::string_element&gt; &amp;, std::PATH &amp;out);



			// flags

			bool beVerbose;



			// These variables are passed between the actions and auxiliary actions

			std::Lexer::lex_keywordhandle handle;

			std::Lexer::lex_keywordhandle lastOpener;

			std::Lexer::lex_keywordhandle firstCloser;

			std::STATIC_PAGE&lt;std::Lexer::lex_keywordhandle, 32&gt; delimiterPage;

			std::Stack&lt;std::Lexer::lex_keywordhandle&gt; delimiterStack;

			std::word delimiterDepth = 0;



			bool lineIsDefiningSymbolDefinition;

			bool lineIsDefiningInstruction;

			bool lineIsDefiningProcedure;



		};



		// Types used by ELSA

		enum ELSA_TYPE : uint32_t

		{

			UNKOWN_T,

			SYMBOL_T,

			PROCEDURE_T,

			INSTRUCTION_T

		};



		enum SYMBOL_TYPE : uint32_t

		{

			// Defines the access of a symbol. If none used, it is a quasi-symbol.

			SYMTACC_VIRTUAL = 0b1,

			SYMTACC_STATIC = SYMTACC_VIRTUAL &lt;&lt; 1,



			// Modifiers that can be used

			SYMTMOD_EXTERN = SYMTACC_STATIC &lt;&lt; 1,

			SYMTMOD_CONST = SYMTMOD_EXTERN &lt;&lt; 1,

			SYMTMOD_STATIC = SYMTMOD_CONST &lt;&lt; 1,



			// The size of the symbol

			SYMTSZ_NIL = SYMTMOD_STATIC &lt;&lt; 1,
</function><function index="99" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1af184289074f27f191666564995b2c6d8" name="includeFile" args="(std::Lexer::lex_context *, std::index_t)" definition="BBP::std::conststring BBP::esa::esaProcessor::includeFile" /><function index="100" id="db/d1d/classBBP_1_1esa_1_1esaProcessor_1a32d036e0f72c2f867f4b83b8d5f9a351" name="includeFromPath" args="(std::FILE &amp;, std::PATH &amp;, std::Stack&lt; std::string_element &gt; &amp;, std::PATH &amp;out)" definition="bool BBP::esa::esaProcessor::includeFromPath">			SYMTSZ_DB = SYMTSZ_DN &lt;&lt; 1,

			SYMTSZ_DH = SYMTSZ_DB &lt;&lt; 1,

			SYMTSZ_DI = SYMTSZ_DH &lt;&lt; 1,

			SYMTSZ_DA = SYMTSZ_DI &lt;&lt; 1,

			SYMTSZ_DW = SYMTSZ_DA &lt;&lt; 1

		};







		// Extern symbols

		extern esaProcessor processor;





	}

}



#endif
</function><function index="101" id="d4/dbd/classBBP_1_1std_1_1FILE_1a286d9d0aca6078e4eb09362f8acaee22" name="FILE" args="()" definition="BBP::std::FILE::FILE">#include "Strings.h"

#include "Resources.h"

#include "stdio.h"



#ifndef BBP_STDLIB_FILESYS_NOOVERWRITE
</function><function index="102" id="d4/dbd/classBBP_1_1std_1_1FILE_1aa5c9afde2a4904368e27716b4a8e1eed" name="FILE" args="(std::PATH)" definition="BBP::std::FILE::FILE">			void makeRelative(PATH &amp;reference, PATH &amp;dir);



			PATH(VOLUME *, std::string &amp;path);

			PATH(VOLUME *, std::conststring path);

			PATH(std::string &amp;path);

			PATH(std::conststring path);

			PATH(std::PATH &amp;);

			PATH();



			~PATH();



		private:



			// The string where the path + filename lives

			std::static_string&lt;max_path_length&gt; _path;



			// Pretty much a copy of the input path string

			std::static_string&lt;max_path_length&gt; rawPath;



			// This index stores where the file name begins

			std::index_t fileNameStartIndex;



			// This is where _path is allocated

			std::ResourceManager *allocator;



			// The volume which this path is relative to

			VOLUME *Volume;



			PATH &amp;getFileAndPaths();


</function><function index="103" id="d4/dbd/classBBP_1_1std_1_1FILE_1abb0bdd4716fd2e57f0d46e7fe26c7adc" name="FILE" args="(std::conststring)" definition="BBP::std::FILE::FILE">		class VOLUME

		{

		public:

			VOLUME(char l, std::conststring);
</function><function index="104" id="d4/dbd/classBBP_1_1std_1_1FILE_1a559d5f29d593814cb3379046cd1f6318" name="FILE" args="(std::Stack&lt; std::string_element &gt; &amp;data, std::conststring path)" definition="BBP::std::FILE::FILE">#endif



namespace BBP

{

	namespace std

	{



		// Nodes that stores the actual data. (See INode)

		struct FileNode;

		struct DirectoryNode;



		// What the "user" uses

		class VOLUME;

		class DIRECTORY;

		class FILE;

		class PATH;



		// Constants
</function><function index="105" id="d4/dbd/classBBP_1_1std_1_1FILE_1a75f50f01820a6cb9d377336aacfd975b" name="data" args="()" definition="BBP::std::FileNode * BBP::std::FILE::data">			bool _dealloc_page = false;

			bool _loaded_intomem = false;

			bool _unload_inode = false;


</function><function index="106" id="d4/dbd/classBBP_1_1std_1_1FILE_1ae42065d3c2135f0bd24a3402c7a85921" name="b" args="()" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::FILE::b">

			FileNode()

				: allocator(nullptr),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),
</function><function index="107" id="d4/dbd/classBBP_1_1std_1_1FILE_1a327ef0f05d0b57b4a2b5a67cfeb2165d" name="is_open" args="()" definition="bool BBP::std::FILE::is_open">			// The internal data of the file

			std::ResourceManager *allocator;

			std::Stack&lt;std::string_element&gt; fileData;



			// Path of the file

			std::PATH filePath;
</function><function index="108" id="d4/dbd/classBBP_1_1std_1_1FILE_1a416594fb841611d072c639a32a273f36" name="on_disk" args="()" definition="bool BBP::std::FILE::on_disk">			inline bool on_disk() { return _is_on_disk; }
</function><function index="109" id="d4/dbd/classBBP_1_1std_1_1FILE_1a0a06d09de567928faea10565289627c6" name="close" args="()" definition="void BBP::std::FILE::close">		};



		class DIRECTORY

		{

		public:







		private:

			noderef_t node;

			DirectoryNode *getNode();

		};



		struct FileNode
</function><function index="110" id="d4/dbd/classBBP_1_1std_1_1FILE_1afa777a975006e09f52e8ba06ad8e3f46" name="write" args="(std::conststring str)" definition="BBP::std::FILE &amp; BBP::std::FILE::write">				filePathHash(0)

			{}



			FileNode(std::ResourceManager *res, std::conststring path)

				: allocator(res),
</function><function index="111" id="d4/dbd/classBBP_1_1std_1_1FILE_1a3eadf10876d18fbc31e052cf21750870" name="write" args="(std::c_string &amp;str)" definition="BBP::std::FILE &amp; BBP::std::FILE::write">				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());
</function><function index="112" id="d4/dbd/classBBP_1_1std_1_1FILE_1a6d7c68c28a73ab38e81b051b0ff94f26" name="write" args="(std::string &amp;str)" definition="BBP::std::FILE &amp; BBP::std::FILE::write">

			FileNode(std::Stack&lt;std::string_element&gt; &amp;data, std::conststring path)

				: allocator(nullptr),

				fileData(data),

				filePath(path),
</function><function index="113" id="d4/dbd/classBBP_1_1std_1_1FILE_1a18e35117a9605e8d05f1ef583050f510" name="finish" args="(std::conststring str)" definition="BBP::std::FILE &amp; BBP::std::FILE::finish">			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}


</function><function index="114" id="d4/dbd/classBBP_1_1std_1_1FILE_1a7fa49b46754e7511ca979f26bf30b4cc" name="finish" args="(std::c_string &amp;str)" definition="BBP::std::FILE &amp; BBP::std::FILE::finish">				: allocator(res),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),

				filePath(v, path),

				filePathHash(0)

			{
</function><function index="115" id="d4/dbd/classBBP_1_1std_1_1FILE_1ae6dd640f427b528ee984cd2f423efd48" name="finish" args="(std::string &amp;str)" definition="BBP::std::FILE &amp; BBP::std::FILE::finish">				filePathHash = std::strhsh(filePath.relName());

			}



			FileNode(std::ResourceManager *res, std::size_t size, std::VOLUME *v, std::conststring path)

				: allocator(res),
</function><function index="116" id="d4/dbd/classBBP_1_1std_1_1FILE_1a0090603ed90b033e086799fab27bbb03" name="finish" args="()" definition="BBP::std::FILE &amp; BBP::std::FILE::finish">					(std::PAGE&lt;std::string_element&gt; *)res-&gt;add_object(new std::PAGE&lt;std::string_element&gt;(size, (std::string_element *)res-&gt;calloc(size, sizeof(std::string_element)))),

					size),

				filePath(v, path),

				filePathHash(0)

			{
</function><function index="117" id="d4/dbd/classBBP_1_1std_1_1FILE_1a246ab9b5564d7b5fb82509eacf9c5d8e" name="checkIfIsOpen" args="(std::conststring path)" definition="BBP::std::index_t BBP::std::FILE::checkIfIsOpen">

			~VOLUME();



			PATH volumePath;

			char label;



		};



		class FILE

		{

		public:



			FILE();

			FILE(std::PATH);

			FILE(std::conststring);



			FILE(std::Stack&lt;std::string_element&gt; &amp;data, std::conststring path);



			FileNode *data();



			std::Stack&lt;std::string_element&gt; &amp;b();



			bool is_open();

			inline bool on_disk() { return _is_on_disk; }


</function><function index="118" id="d4/dbd/classBBP_1_1std_1_1FILE_1a40ac25a8ae2b6fb12dd18d29a2cb2ebf" name="findClosedFile" args="()" definition="BBP::std::index_t BBP::std::FILE::findClosedFile">

			FILE &amp;write(std::conststring str);

			FILE &amp;write(std::c_string &amp;str);

			FILE &amp;write(std::string &amp;str);

			FILE &amp;finish(std::conststring str);

			FILE &amp;finish(std::c_string &amp;str);

			FILE &amp;finish(std::string &amp;str);

			FILE &amp;finish();



			bool doesFileExistOnDisk(std::PATH &amp;);

			std::size_t getFileSizeFromDisk(std::PATH &amp;);

			std::size_t readFileFromDisk(std::FileNode *, std::PATH &amp;);

			void writeFileToDisk(std::PATH &amp;);

			void writeFileToDisk();





		private:

			

			std::index_t checkIfIsOpen(std::conststring path);

			std::index_t findClosedFile();



			void getINodeIndex(std::PATH &amp;);
</function><function index="119" id="d4/dbd/classBBP_1_1std_1_1FILE_1a785a13b9aac16963608a19e872ee3dc9" name="getINodeIndex" args="(std::PATH &amp;)" definition="void BBP::std::FILE::getINodeIndex">		static constexpr std::size_t max_path_length = 128;



		// This is ...

		typedef std::index_t noderef_t;

		extern std::STATIC_PAGE&lt;FileNode, max_open_files&gt; fileTable;



		// Variables

		extern PATH *workingDirectory;

		extern VOLUME *primaryVolume;



		// Paths

		class PATH

		{

		public:



			std::c_string pathName();

			std::c_string fileName();



			std::c_string relName();



			bool isRelativeToRoot();

			bool isDefinedFromRoot();



			PATH &amp;makeAbsolutePath(PATH *currentPath);

			PATH &amp;resolveAbsolutes();
</function><function index="120" id="dc/d3b/structBBP_1_1std_1_1FileNode_1a2a7cba0f8a554f9b725b671ba451e5af" name="FileNode" args="()" definition="BBP::std::FileNode::FileNode">			FileNode()

				: allocator(nullptr),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),

				filePath(),

				filePathHash(0)

			{}
</function><function index="121" id="dc/d3b/structBBP_1_1std_1_1FileNode_1adb6991c5ed4b950d5adcc7f721a70c54" name="FileNode" args="(std::ResourceManager *res, std::conststring path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::ResourceManager *res, std::conststring path)

				: allocator(res),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr),

				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="122" id="dc/d3b/structBBP_1_1std_1_1FileNode_1a8e316401392114ba7f05275fb9452f94" name="FileNode" args="(std::Stack&lt; std::string_element &gt; &amp;data, std::conststring path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::Stack&lt;std::string_element&gt; &amp;data, std::conststring path)

				: allocator(nullptr),

				fileData(data),

				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="123" id="dc/d3b/structBBP_1_1std_1_1FileNode_1aff0129e2d512c62e761626fb16f1cafa" name="FileNode" args="(std::ResourceManager *res, std::VOLUME *v, std::conststring path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::ResourceManager *res, std::VOLUME *v, std::conststring path)

				: allocator(res),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="124" id="dc/d3b/structBBP_1_1std_1_1FileNode_1a442abec2ec137e7cd1dd46421bf9d713" name="FileNode" args="(std::ResourceManager *res, std::size_t size, std::VOLUME *v, std::conststring path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::ResourceManager *res, std::size_t size, std::VOLUME *v, std::conststring path)

				: allocator(res),

				fileData(

					(std::PAGE&lt;std::string_element&gt; *)res-&gt;add_object(new std::PAGE&lt;std::string_element&gt;(size, (std::string_element *)res-&gt;calloc(size, sizeof(std::string_element)))),

					size),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="125" id="dc/d3b/structBBP_1_1std_1_1FileNode_1a28c6c299d16f9274ce27a6bced27d11a" name="FileNode" args="(std::ResourceManager *res, std::size_t size, std::PATH &amp;path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::ResourceManager *res, std::size_t size, std::PATH &amp;path)

				: allocator(res),

				fileData(

					(std::PAGE&lt;std::string_element&gt; *)res-&gt;add_object(new std::PAGE&lt;std::string_element&gt;(size, (std::string_element *)res-&gt;calloc(size, sizeof(std::string_element)))),

					size),

				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="126" id="dc/d3b/structBBP_1_1std_1_1FileNode_1a98ba8bb73970e6e2593e5f8efb1f0fdd" name="FileNode" args="(std::Stack&lt; std::string_element &gt; &amp;data, std::VOLUME *v, std::conststring path)" definition="BBP::std::FileNode::FileNode">			FileNode(std::Stack&lt;std::string_element&gt; &amp;data, std::VOLUME *v, std::conststring path)

				: allocator(nullptr),

				fileData(data),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}
</function><function index="127" id="d2/d7c/classBBP_1_1std_1_1GCEntry_1a097311bf0c5aba62e8b59697b2f511ba" name="~GCEntry" args="()" definition="virtual BBP::std::GCEntry&lt; T &gt;::~GCEntry">			virtual ~GCEntry()

			{

			}
</function><function index="128" id="d2/d7c/classBBP_1_1std_1_1GCEntry_1af80c9897951e6229f91ae2554c264fb8" name="markDeleted" args="()" definition="void BBP::std::GCEntry&lt; T &gt;::markDeleted">			void markDeleted()

			{

				ptr = nullptr;

			}
</function><function index="129" id="d2/d7c/classBBP_1_1std_1_1GCEntry_1afa6c2ef133c16df72eb3e05fa7908151" name="_delete" args="()" definition="void BBP::std::GCEntry&lt; T &gt;::_delete">			void _delete()

			{

				delete(ptr);

			}
</function><function index="130" id="d2/d7c/classBBP_1_1std_1_1GCEntry_1a4db27cb70a72b3d7e3e776f087ba55c4" name="getRawPtr" args="()" definition="void* BBP::std::GCEntry&lt; T &gt;::getRawPtr">			void *getRawPtr()

			{

				return (void *)ptr;

			}
</function><function index="131" id="df/d24/classGoto_1a59e11de02662de61c81e16084186d98c" name="Hell" args="()" definition="static void Goto::Hell">	static inline void Hell()

	{}
</function><function index="132" id="d7/dad/classIHate_1a8c25a30c98540c5b83043bcb5d5bb579" name="AllOfYou" args="()" definition="static void IHate::AllOfYou">	static inline void AllOfYou()

	{}
</function><function index="133" id="d7/dad/classIHate_1a4a3d865b46626c46d647bba63ae196fa" name="Everything" args="()" definition="static void IHate::Everything">	static inline void Everything()

	{}
</function><function index="134" id="d7/dad/classIHate_1ae155f0a76ad61eb3b8d175661a9d6f49" name="Myself" args="()" definition="static void IHate::Myself">	static inline void Myself()

	{}
</function><function index="135" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1aaa63103687431a43e23c35cfed011411" name="lex_context" args="()" definition="BBP::std::Lexer::lex_context::lex_context" /><function index="136" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a4395935c27b686c8c04bd1234f595685" name="translateUnit" args="(std::PATH &amp;)" definition="void BBP::std::Lexer::lex_context::translateUnit">#define BBP_STDLIB_LEX_H



namespace BBP

{

	namespace std

	{

		namespace Lexer

		{



			class lex_context;



			typedef uint32_t lex_type;



			// Used to define enums

			typedef uint32_t lex_specialty;



			// This type is used pass around references to keywords

			typedef uint32_t lex_keywordhandle;


</function><function index="137" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a5cd38f62146186672890a2a20e8e4fee" name="parseFile" args="()" definition="void BBP::std::Lexer::lex_context::parseFile" /><function index="138" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1aec4c5d7614d9bdcd3575f4d0c9b52312" name="parseFile" args="(std::PATH &amp;)" definition="void BBP::std::Lexer::lex_context::parseFile">			typedef std::conststring(*lex_action)(lex_context *, std::index_t, lex_keywordhandle);



			union numerical_t { std::word i; float f; };



			// Keyword

			struct lex_keyword

			{

				std::conststring word;

				std::size_t length;



				uint32_t mask;

				lex_action action;



				//Flags used by the lexer to determine ...

				bool forceEvaluation; // If true, this keyword is always checked.

				bool forceParseInComments; // If true, this keyword is never skipped when inside a comment

				bool forceParseInLiterals; // If true, this keyword is never skipped when inside a literal

				bool forceParseOutsideComments; // If true, this keyword is also considered when commentDepth is 0.

				bool forceParseOutsideLiterals; // If true, this keyword is also considered when literalDepth is 0.

				bool actAsDelimiter; // If true, this keyword will be treated like a whitespace.



				char considerCommentDepth; // If 'forceParseInComments' is false, his keyword is considered only if 'commentDepth' matches this value

				char considerLiteralDepth; // if 'forceParseInLiterals' is false, his keyword is considered only if 'literalDepth' matches this value

			};



			

			// This stores a list of 'things'

			struct lex_thing

			{

				// The context in which this "thing" is in.

				lex_context *context;


</function><function index="139" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a9ea6297d4895c1023d5c85e2ad6b80b0" name="executeKeywordAction" args="(lex_keywordhandle, lex_keyword *&amp;)" definition="void BBP::std::Lexer::lex_context::executeKeywordAction">				index_t start;

				index_t end;



				// If this "Thing" is inside of another thing.

				lex_thing *insideOf;



				// What type of thing is this?

				lex_type type;



				// What type of 'type' is this?

				lex_specialty subtype;



				// Hash to speed up searching

				hash_t hash;

			};



			// This structure stores various variables needed to debug an issue

			struct lex_debugInfo

			{

				// The coloumns and lines

				std::index_t coloumn = 0;
</function><function index="140" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a8a9bd06e1b0bbcf991fb6fce2470c4f7" name="executeSpecialFunction" args="(std::index_t a, std::index_t b)" definition="void BBP::std::Lexer::lex_context::executeSpecialFunction" /><function index="141" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1ab10154f72fb28be7553637f79d6adc40" name="isWhitespace" args="(char)" definition="bool BBP::std::Lexer::lex_context::isWhitespace" /><function index="142" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a4bf2b10c8db466d9a88fc2b42e28ab7e" name="isNewLine" args="(char)" definition="bool BBP::std::Lexer::lex_context::isNewLine" /><function index="143" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1ad7bad9296f4dffdd28dfe8d54be57886" name="isBinaryNumeral" args="(char)" definition="char BBP::std::Lexer::lex_context::isBinaryNumeral" /><function index="144" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a06aa3edce2c709be4a30342a74a53b66" name="isOctalNumeral" args="(char)" definition="char BBP::std::Lexer::lex_context::isOctalNumeral" /><function index="145" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a538f7eb0cab3e11a435775eb587ba471" name="isDecimalNumeral" args="(char)" definition="char BBP::std::Lexer::lex_context::isDecimalNumeral" /><function index="146" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a16e4e121c7507615c798a72ba0dcbd4a" name="isHexadecimalNumeral" args="(char)" definition="char BBP::std::Lexer::lex_context::isHexadecimalNumeral" /><function index="147" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a9d2106c7a808fe48c767b50d58b10169" name="isNumericalBase" args="(std::string_element, std::byte &amp;)" definition="char BBP::std::Lexer::lex_context::isNumericalBase" /><function index="148" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1aab7ac89d9a0fbcf5298392da3c28be1e" name="tryParseNumerical" args="(std::index_t from, std::index_t to, bool &amp;isFloat, float &amp;fresult, int &amp;iresult)" definition="bool BBP::std::Lexer::lex_context::tryParseNumerical" /><function index="149" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a40706684fe9f6dc38f62865da75793ca" name="moveToEndOfLastWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToEndOfLastWord" /><function index="150" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a341d64a1a8633b5c24b5eb698c183f19" name="moveToStartOfLastWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToStartOfLastWord" /><function index="151" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1af2c3a9213cc6e7b66573f7ca083ddae7" name="moveToEndOfThisWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToEndOfThisWord" /><function index="152" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a8f4659d1fbb31d488f7c5b0300741485" name="moveToStartOfThisWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToStartOfThisWord" /><function index="153" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a1489abe65153ed9795d26f3cce61f48e" name="moveToEndOfNextWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToEndOfNextWord" /><function index="154" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a57b4ede056112f658312ac6de5b1a183" name="moveToStartOfNextWord" args="(bool stopAtNewLine)" definition="void BBP::std::Lexer::lex_context::moveToStartOfNextWord" /><function index="155" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a280648bcad760d6d31da9c37b99e3a02" name="moveToAndHashThisWord" args="(std::hash_t &amp;, char)" definition="bool BBP::std::Lexer::lex_context::moveToAndHashThisWord" /><function index="156" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1aaad37e5fb34b89c653ea90a4f8132cae" name="moveToAndHashNextWord" args="(std::hash_t &amp;, char)" definition="bool BBP::std::Lexer::lex_context::moveToAndHashNextWord" /><function index="157" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1ad8f2919d448f1c9b319938ec88fb0502" name="calculateDebugPosition" args="()" definition="void BBP::std::Lexer::lex_context::calculateDebugPosition" /><function index="158" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a8249caecef89f688455c2a73135b0fc7" name="moveToNextKeyword" args="()" definition="BBP::std::Lexer::lex_keywordhandle BBP::std::Lexer::lex_context::moveToNextKeyword">

				std::conststring msg = nullptr;

				std::conststring errName = nullptr;



				std::PAGE&lt;std::string_element&gt; procedure;



				bool showLinesAndColoumns = true;

				bool showWhere = true;



				const char *highlightmsg = nullptr;



				// 0 = zero terminated by 'highlight'.

				std::index_t highlight;

				std::size_t highlightLength = 0;



			};



			class lex_context

			{

			public:



				lex_context();



				// A more complete way to compile a file

				void translateUnit(std::PATH &amp;);



				// This function ...

				void parseFile(); // Old func is L_findAllkeywords



				void parseFile(std::PATH &amp;);



				// This function just executes any given keyword

				void executeKeywordAction(lex_keywordhandle, lex_keyword *&amp;);

				void executeSpecialFunction(std::index_t a, std::index_t b);



				// The name of the translation unit being parsed.

				std::static_string&lt;128&gt; activeFile;



				// The vector to the data that must be parsed.

				std::PAGE&lt;string_element&gt; data;

				std::size_t dataSize;



				// Where in the vector the lexer is.

				std::index_t atPosition;



				// The keywords

				std::STATIC_PAGE&lt;lex_keyword, 256&gt; keywords;



				// A stack with all keywords

				std::Stack&lt;lex_keyword&gt; keywordStack;



				// A list of special functions.

				bool inhibitSpecialFunctions;

				std::conststring (*onUnkown)(index_t, index_t);

				std::conststring (*onNumericalLiteral)(numerical_t numerical, bool isFloat);



				// Used to keep track of lexing state

				index_t lastWhiteSpace;



				char commentDepth; // 0 if not in comment, 1 for single line comment, 2 for multiline comment

				char literalDepth; // 0 if not in literal, otherwise used to mask keywords.



				// Debug information

				lex_debugInfo debugInformation;



				// Continue compilation?

				bool abort;

				bool illformed;



				// User and system path info

				std::static_string&lt;1024&gt; usrpathPage;

				std::static_string&lt;1024&gt; syspathPage;

				std::Stack&lt;std::string_element&gt; usrpaths;

				std::Stack&lt;std::string_element&gt; syspaths;



				// Application builder

				



				// Helper functions

				bool isWhitespace(char);

				bool isNewLine(char);



				char isBinaryNumeral(char);

				char isOctalNumeral(char);

				char isDecimalNumeral(char);

				char isHexadecimalNumeral(char);

				char isNumericalBase(std::string_element, std::byte&amp;);



				bool tryParseNumerical(std::index_t from, std::index_t to, bool &amp;isFloat, float &amp;fresult, int &amp;iresult);



				// Used to move the lexer up and down

				void moveToEndOfLastWord(bool stopAtNewLine);

				void moveToStartOfLastWord(bool stopAtNewLine);



				void moveToEndOfThisWord(bool stopAtNewLine);

				void moveToStartOfThisWord(bool stopAtNewLine);



				void moveToEndOfNextWord(bool stopAtNewLine);

				void moveToStartOfNextWord(bool stopAtNewLine);



				bool moveToAndHashThisWord(std::hash_t &amp;, char);

				bool moveToAndHashNextWord(std::hash_t &amp;, char);



				void calculateDebugPosition();



				lex_keywordhandle moveToNextKeyword();



				// Logging functions

				void resetInfo(lex_debugInfo &amp;info);



				void Log(lex_debugInfo &amp;info);

				void Log(std::conststring msg);

				void Log(std::conststring from, std::conststring msg, std::conststring name);



				void LogError(std::conststring from, std::conststring msg, std::conststring name);

				void LogNote(std::conststring from, std::conststring msg, std::conststring name);

				void LogWarning(std::conststring from, std::conststring msg, std::conststring name);

				void LogAbort(std::conststring from, std::conststring msg, std::conststring name);



				void Highlight(lex_debugInfo info);





			};





		}

	}

}



#endif</function><function index="159" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a11c0c6d9eebae9ff33957ed4be00ff1b" name="resetInfo" args="(lex_debugInfo &amp;info)" definition="void BBP::std::Lexer::lex_context::resetInfo" /><function index="160" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a4680b8ff161430dbdab858d709b24a25" name="Log" args="(lex_debugInfo &amp;info)" definition="void BBP::std::Lexer::lex_context::Log" /><function index="161" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1ac7c94506bed90fd42cf22a9bda6225f5" name="LogError" args="(std::conststring from, std::conststring msg, std::conststring name)" definition="void BBP::std::Lexer::lex_context::LogError" /><function index="162" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a1fe735040a4c2154929d06b91bb27f91" name="LogNote" args="(std::conststring from, std::conststring msg, std::conststring name)" definition="void BBP::std::Lexer::lex_context::LogNote" /><function index="163" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a19b5de0ff0ebcf35c680702557c42f28" name="LogWarning" args="(std::conststring from, std::conststring msg, std::conststring name)" definition="void BBP::std::Lexer::lex_context::LogWarning" /><function index="164" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a13c9765604b0ce2bc27f0aa9971f12d5" name="LogAbort" args="(std::conststring from, std::conststring msg, std::conststring name)" definition="void BBP::std::Lexer::lex_context::LogAbort" /><function index="165" id="d1/dc2/classBBP_1_1std_1_1Lexer_1_1lex__context_1a1916906e1493d4fc2ca87610d02dcf7e" name="Highlight" args="(lex_debugInfo info)" definition="void BBP::std::Lexer::lex_context::Highlight" /><function index="166" id="df/ddc/structBBP_1_1std_1_1PAGE_1af9a5521fb19a11cc4a8508affedee6aa" name="PAGE" args="(size_t Size, T *dat)" definition="BBP::std::PAGE&lt; T &gt;::PAGE">			PAGE(size_t Size, T* dat) : dataSize(Size), bytes(Size * (sizeof(T) / sizeof(mem_t))), prevPage(nullptr), nextPage(nullptr), data(dat) {}
</function><function index="167" id="df/ddc/structBBP_1_1std_1_1PAGE_1a441f2061f6374798411cbc677508cdd0" name="PAGE" args="()" definition="BBP::std::PAGE&lt; T &gt;::PAGE">			PAGE() : dataSize(0), bytes(0), prevPage(0), nextPage(0), data(nullptr) {}
</function><function index="168" id="d8/dea/classBBP_1_1std_1_1PATH_1a64794a4662ea993081c426afc9313da4" name="pathName" args="()" definition="BBP::std::c_string BBP::std::PATH::pathName">			PATH &amp;resolveAbsolutes();



			void makeRelative(PATH &amp;reference, PATH &amp;dir);


</function><function index="169" id="d8/dea/classBBP_1_1std_1_1PATH_1a5d44eef11d4945f22dddf9096bd1a261" name="fileName" args="()" definition="BBP::std::c_string BBP::std::PATH::fileName">			std::c_string fileName();



			std::c_string relName();



			bool isRelativeToRoot();

			bool isDefinedFromRoot();


</function><function index="170" id="d8/dea/classBBP_1_1std_1_1PATH_1a57ccb35da441b837888a28f111999d37" name="relName" args="()" definition="BBP::std::c_string BBP::std::PATH::relName">			PATH(VOLUME *, std::conststring path);

			PATH(std::string &amp;path);

			PATH(std::conststring path);

			PATH(std::PATH &amp;);

			PATH();



			~PATH();
</function><function index="171" id="d8/dea/classBBP_1_1std_1_1PATH_1ad2fa2cf7f674261f8f9f1734934d2988" name="isRelativeToRoot" args="()" definition="bool BBP::std::PATH::isRelativeToRoot">		private:



			// The string where the path + filename lives

			std::static_string&lt;max_path_length&gt; _path;



			// Pretty much a copy of the input path string

			std::static_string&lt;max_path_length&gt; rawPath;
</function><function index="172" id="d8/dea/classBBP_1_1std_1_1PATH_1a521e2ca53abe192a2d2cca989f9d1923" name="isDefinedFromRoot" args="()" definition="bool BBP::std::PATH::isDefinedFromRoot">			// This index stores where the file name begins

			std::index_t fileNameStartIndex;



			// This is where _path is allocated

			std::ResourceManager *allocator;



			// The volume which this path is relative to

			VOLUME *Volume;



			PATH &amp;getFileAndPaths();



		};



		class VOLUME

		{

		public:

			VOLUME(char l, std::conststring);

			VOLUME(char l) : VOLUME(l, "/") {}
</function><function index="173" id="d8/dea/classBBP_1_1std_1_1PATH_1a80a557105fdce73fd255af94f5c33e1d" name="makeAbsolutePath" args="(PATH *currentPath)" definition="BBP::std::PATH &amp; BBP::std::PATH::makeAbsolutePath">

			bool doesFileExistOnDisk(std::PATH &amp;);

			std::size_t getFileSizeFromDisk(std::PATH &amp;);

			std::size_t readFileFromDisk(std::FileNode *, std::PATH &amp;);

			void writeFileToDisk(std::PATH &amp;);

			void writeFileToDisk();





		private:

			

			std::index_t checkIfIsOpen(std::conststring path);

			std::index_t findClosedFile();



			void getINodeIndex(std::PATH &amp;);

			bool _is_on_disk = false;

			bool _dealloc_page = false;

			bool _loaded_intomem = false;

			bool _unload_inode = false;



			noderef_t node;

		};



		class DIRECTORY

		{

		public:







		private:

			noderef_t node;

			DirectoryNode *getNode();

		};



		struct FileNode

		{

			// The internal data of the file

			std::ResourceManager *allocator;

			std::Stack&lt;std::string_element&gt; fileData;



			// Path of the file

			std::PATH filePath;

			std::hash_t filePathHash;



			FileNode()

				: allocator(nullptr),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),

				filePath(),

				filePathHash(0)

			{}



			FileNode(std::ResourceManager *res, std::conststring path)

				: allocator(res),
</function><function index="174" id="d8/dea/classBBP_1_1std_1_1PATH_1a634c986ae803f84b7796a7802cc995b3" name="resolveAbsolutes" args="()" definition="BBP::std::PATH &amp; BBP::std::PATH::resolveAbsolutes">				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



			FileNode(std::Stack&lt;std::string_element&gt; &amp;data, std::conststring path)

				: allocator(nullptr),

				fileData(data),

				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



			FileNode(std::ResourceManager *res, std::VOLUME *v, std::conststring path)

				: allocator(res),

				fileData((std::PAGE&lt;std::string_element&gt; *)nullptr, 0),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



			FileNode(std::ResourceManager *res, std::size_t size, std::VOLUME *v, std::conststring path)

				: allocator(res),

				fileData(

					(std::PAGE&lt;std::string_element&gt; *)res-&gt;add_object(new std::PAGE&lt;std::string_element&gt;(size, (std::string_element *)res-&gt;calloc(size, sizeof(std::string_element)))),

					size),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



			FileNode(std::ResourceManager *res, std::size_t size, std::PATH &amp;path)

				: allocator(res),

				fileData(

					(std::PAGE&lt;std::string_element&gt; *)res-&gt;add_object(new std::PAGE&lt;std::string_element&gt;(size, (std::string_element *)res-&gt;calloc(size, sizeof(std::string_element)))),

					size),

				filePath(path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



			



			FileNode(std::Stack&lt;std::string_element&gt; &amp;data, std::VOLUME *v, std::conststring path)

				: allocator(nullptr),

				fileData(data),

				filePath(v, path),

				filePathHash(0)

			{

				filePath.makeAbsolutePath(std::workingDirectory);

				filePathHash = std::strhsh(filePath.relName());

			}



		};



		struct DirectoryNode

		{

			// The volume this directory is in

			VOLUME *volume;



			// The path of this directory

			PATH path;
</function><function index="175" id="d8/dea/classBBP_1_1std_1_1PATH_1a1fc770b82ae642ebd21b73db32241745" name="makeRelative" args="(PATH &amp;reference, PATH &amp;dir)" definition="void BBP::std::PATH::makeRelative">			// Relationships between this and other directories

			DIRECTORY *parent;

			std::Stack&lt;DIRECTORY&gt; subDirectories;



			// Files stored in this directory

			std::Stack&lt;FILE&gt; files;

		};



		

		template&lt;typename... Args&gt;

		inline void fprintf(BBP::std::FILE &amp;file, std::conststring format, Args... args)

		{
</function><function index="176" id="d8/dea/classBBP_1_1std_1_1PATH_1a7b86cf222fccb3d7ce34b9a332864107" name="PATH" args="(VOLUME *, std::string &amp;path)" definition="BBP::std::PATH::PATH">

		// Nodes that stores the actual data. (See INode)
</function><function index="177" id="d8/dea/classBBP_1_1std_1_1PATH_1a3676d207fab538041564beb4e3207bef" name="PATH" args="(VOLUME *, std::conststring path)" definition="BBP::std::PATH::PATH">		struct DirectoryNode;



		// What the "user" uses

		class VOLUME;

		class DIRECTORY;

		class FILE;

		class PATH;



		// Constants

		static constexpr std::size_t max_open_files = 32;

		static constexpr std::size_t max_path_length = 128;



		// This is ...

		typedef std::index_t noderef_t;
</function><function index="178" id="d8/dea/classBBP_1_1std_1_1PATH_1a6d5148da60dd768608c959a8c96716f8" name="PATH" args="(std::string &amp;path)" definition="BBP::std::PATH::PATH">#ifndef BBP_STDLIB_FILESYS_NOOVERWRITE

#define BBP_STDLIB_FILESYS_OVERWRITEEXISTINGFILES

#endif
</function><function index="179" id="d8/dea/classBBP_1_1std_1_1PATH_1ae853efeb6cc5a12a355146d55c4a04dd" name="PATH" args="(std::conststring path)" definition="BBP::std::PATH::PATH">namespace BBP

{

	namespace std
</function><function index="180" id="d8/dea/classBBP_1_1std_1_1PATH_1a2bb4c06acd7fd61e78dfb6e1d99d9ca1" name="PATH" args="(std::PATH &amp;)" definition="BBP::std::PATH::PATH">

		// Variables

		extern PATH *workingDirectory;

		extern VOLUME *primaryVolume;


</function><function index="181" id="d8/dea/classBBP_1_1std_1_1PATH_1af170b4167adb7df6a60d0fe4d35f42d8" name="PATH" args="()" definition="BBP::std::PATH::PATH">#include "Strings.h"

#include "Resources.h"

#include "stdio.h"


</function><function index="182" id="d8/dea/classBBP_1_1std_1_1PATH_1a3ca2b7912314e3d2d235c4a6b744c46f" name="~PATH" args="()" definition="BBP::std::PATH::~PATH">		class PATH

		{

		public:


</function><function index="183" id="d8/dea/classBBP_1_1std_1_1PATH_1a331dec6c0bac5fef3047b741cb21abbf" name="getFileAndPaths" args="()" definition="BBP::std::PATH &amp; BBP::std::PATH::getFileAndPaths">			~VOLUME();



			PATH volumePath;

			char label;



		};



		class FILE

		{

		public:



			FILE();

			FILE(std::PATH);

			FILE(std::conststring);



			FILE(std::Stack&lt;std::string_element&gt; &amp;data, std::conststring path);



			FileNode *data();



			std::Stack&lt;std::string_element&gt; &amp;b();



			bool is_open();

			inline bool on_disk() { return _is_on_disk; }



			void close();



			FILE &amp;write(std::conststring str);

			FILE &amp;write(std::c_string &amp;str);

			FILE &amp;write(std::string &amp;str);

			FILE &amp;finish(std::conststring str);

			FILE &amp;finish(std::c_string &amp;str);

			FILE &amp;finish(std::string &amp;str);
</function><function index="184" id="d8/da2/structBBP_1_1userspace_1_1register__t_1a829a6ca1c1ed5c99d3e3d42e14f29764" name="register_t" args="(Thread &amp;thread, std::index_t index_, std::offset_t offset_, registerSize size_)" definition="BBP::userspace::register_t::register_t" /><function index="185" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1ad11f669509528a8f69a9175349dc1a2a" name="ResourceManager" args="()" definition="BBP::std::ResourceManager::ResourceManager" /><function index="186" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1ace0746163707cba96792b1ddce1f66e4" name="malloc" args="(std::size_t)" definition="void * BBP::std::ResourceManager::malloc">{

	namespace std

	{



		extern void ext_free(void *);

		extern void *ext_malloc(std::size_t);

		extern void *ext_calloc(std::size_t, std::size_t);



		static constexpr size_t max_objects = 1000;

		static constexpr size_t max_allocations = 1000;



		struct AbstractGCEntry

		{

			virtual ~AbstractGCEntry()

			{};

			virtual void _delete() = 0;

			virtual void markDeleted() = 0;
</function><function index="187" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a2feb265bae9a30994a2a4a4f69306329" name="calloc" args="(std::size_t, std::size_t)" definition="void * BBP::std::ResourceManager::calloc">		};



		template&lt;typename T&gt;

		class GCEntry : public AbstractGCEntry

		{

		public:

			T *ptr;

			virtual ~GCEntry()

			{

			}

			void markDeleted()

			{

				ptr = nullptr;

			}

			void _delete()

			{

				delete(ptr);
</function><function index="188" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1aea4091636b0010fa96b46859b119c515" name="add_object" args="(T *ptr)" definition="T* BBP::std::ResourceManager::add_object">			inline T *add_object(T *ptr)

			{



				// See if allocation is possible

				if (this-&gt;nextObjectAvailable == this-&gt;invalidObjectIndex)

					throw std::exception("Could not register new'd data to Resource manager: Out of allocation space.", ENOMEM);



				// Store that write into next possible object



				GCEntry&lt;T&gt; *entry = new GCEntry&lt;T&gt;();

				entry-&gt;ptr = ptr;

				this-&gt;objects.data[this-&gt;nextObjectAvailable] = entry;

				totalAllocations += sizeof(T);



				// Find next possible location

				this-&gt;nextObjectAvailable = find_next_empty_object();



				// Return ptr, in case it is needed for something

				return ptr;

			}
</function><function index="189" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a95a95eb4df0b375dfabfeb5acb58122e" name="add_alloc" args="(void *)" definition="void BBP::std::ResourceManager::add_alloc">			void *getRawPtr()

			{

				return (void *)ptr;

			}

		};



		class ResourceManager

		{

		public:



			ResourceManager();


</function><function index="190" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a88b2740fa8c5b5e30e6ef08cb8c7d883" name="free" args="(void *)" definition="void BBP::std::ResourceManager::free">			void *calloc(std::size_t, std::size_t);



			std::size_t totalAllocations = 0;



			template &lt;typename T&gt;

			inline T *add_object(T *ptr)

			{



				// See if allocation is possible

				if (this-&gt;nextObjectAvailable == this-&gt;invalidObjectIndex)

					throw std::exception("Could not register new'd data to Resource manager: Out of allocation space.", ENOMEM);



				// Store that write into next possible object



				GCEntry&lt;T&gt; *entry = new GCEntry&lt;T&gt;();

				entry-&gt;ptr = ptr;
</function><function index="191" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1ae748d6a1bf87b426245d9c1880a309fa" name="mark_deleted" args="(void *)" definition="void BBP::std::ResourceManager::mark_deleted">			std::index_t deleteAll();

			std::index_t dealloc();



		private:



			// Internal functions to quickly free / delete data at known indicies

			void free(void *, std::index_t);

			void _delete(std::index_t);



			// Searches in the allocations and object page respectively.

			std::index_t find_next_empty_alloc();

			std::index_t find_next_empty_object();



			// Searches in the 'allocations' and 'new' 

			std::index_t find_Alloc_pointer(void *);

			std::index_t find_Object_pointer(void *);


</function><function index="192" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1aabf2f3fcf4ce22bfeefe3a1496f79c89" name="_delete" args="(void *)" definition="void BBP::std::ResourceManager::_delete">			std::index_t invalidAllocationIndex;

			std::index_t nextAllocationAvailable;

			std::STATIC_PAGE&lt;void *, max_allocations&gt; allocations;



			// Used to store the indicies of 'new'-'delete' things

			std::index_t invalidObjectIndex;

			std::index_t nextObjectAvailable;

			std::STATIC_PAGE&lt;AbstractGCEntry *, max_objects&gt; objects;

		};



		extern ResourceManager progmem;

		extern ResourceManager *activemem;

	}

}



#endif</function><function index="193" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a9e71b44bf2fa37404996f41b7755bec3" name="freeAll" args="()" definition="BBP::std::index_t BBP::std::ResourceManager::freeAll" /><function index="194" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a8e0f86cd9da420b4a60eebda495b8309" name="deleteAll" args="()" definition="BBP::std::index_t BBP::std::ResourceManager::deleteAll" /><function index="195" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a1fe4dd3e15724a9b5e2a41ef90075de6" name="dealloc" args="()" definition="BBP::std::index_t BBP::std::ResourceManager::dealloc" /><function index="196" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a07be9ae976de3e085f19c938169868d5" name="free" args="(void *, std::index_t)" definition="void BBP::std::ResourceManager::free">				totalAllocations += sizeof(T);



				// Find next possible location

				this-&gt;nextObjectAvailable = find_next_empty_object();



				// Return ptr, in case it is needed for something

				return ptr;

			}

			void add_alloc(void *);



			void free(void *);



			void mark_deleted(void *);

			void _delete(void *);


</function><function index="197" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a468bd26ad9f697a6859f005106152d47" name="_delete" args="(std::index_t)" definition="void BBP::std::ResourceManager::_delete" /><function index="198" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a71c2205dc92556a9f91266343541168f" name="find_next_empty_alloc" args="()" definition="BBP::std::index_t BBP::std::ResourceManager::find_next_empty_alloc" /><function index="199" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1ad45816fb0c5611cec2669e670d12106f" name="find_next_empty_object" args="()" definition="BBP::std::index_t BBP::std::ResourceManager::find_next_empty_object" /><function index="200" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a23f4cc602d945b35b1f83e40f354360c" name="find_Alloc_pointer" args="(void *)" definition="BBP::std::index_t BBP::std::ResourceManager::find_Alloc_pointer" /><function index="201" id="d6/d73/classBBP_1_1std_1_1ResourceManager_1a4e7d173638f7fb726d4fcdc6294deb81" name="find_Object_pointer" args="(void *)" definition="BBP::std::index_t BBP::std::ResourceManager::find_Object_pointer" /><function index="202" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1afd861ea6f3072596321fc0b09bbef3b0" name="name" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::name">				// Symbol stack (pointers to save memory)
</function><function index="203" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ac0b12cb6b3c24ed5bfc55e2edb3fd6c3" name="name" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::name">				Stack&lt;SymbolBuilder&gt; symbols;
</function><function index="204" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ad6af22d6c389baf470062336cef24b0f" name="type" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::type">				std::byte ident(std::byte);
</function><function index="205" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ae744ea48e567886384c1f147d9d56d0c" name="type" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::type">				void ident(std::byte, std::byte);
</function><function index="206" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ae9a18e03fb57f60625330fc369062d3a" name="flags" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::flags">				std::halfword type(void);
</function><function index="207" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1aec5c6d26fb9cc967a5aede63de3644eb" name="flags" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::flags">				void type(std::halfword);
</function><function index="208" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ad0b7806f625427f8bbb9912966d9999f" name="addr" args="(void)" definition="BBP::std::address_t BBP::std::ELF::SectionBuilder::addr">				std::halfword machine(void);
</function><function index="209" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1aad44b295751752a779673de479e0e53f" name="addr" args="(std::address_t)" definition="void BBP::std::ELF::SectionBuilder::addr">				void machine(std::halfword);
</function><function index="210" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a7785e10735bd7b9b109baf768f7e09c0" name="offset" args="(void)" definition="BBP::std::offset_t BBP::std::ELF::SectionBuilder::offset">				std::word version(void);
</function><function index="211" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a6258733021d82342d3fae0fb36be91d8" name="offset" args="(std::offset_t)" definition="void BBP::std::ELF::SectionBuilder::offset">				void version(std::word);
</function><function index="212" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a7d844f38bc48a69c8dcc758b882eef1a" name="size" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::size">				std::address_t entry(void);
</function><function index="213" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a578f4e352f6bc66d70f4a237ea6fecb8" name="size" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::size">				void entry(std::address_t);
</function><function index="214" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a713d1ebbab93c72f9ebec24435fa9e79" name="link" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::link">				std::offset_t phoff(void);
</function><function index="215" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ab0583136069a6dc98f4e93d320ed8241" name="link" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::link">				void phoff(std::offset_t);
</function><function index="216" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ad3cab01fa80fde43b34df44e3f5eaf11" name="info" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::info">				std::offset_t shoff(void);
</function><function index="217" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a773ac4778b140aef9847c6d6d6ffc9f2" name="info" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::info">				void shoff(std::offset_t);
</function><function index="218" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1acfcb20ab0fbe2c9501ca7469ac87e75b" name="addralign" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::addralign">				std::word flags(void);
</function><function index="219" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1abeac8b241b7c5dcc7d356f6aff2464fa" name="addralign" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::addralign">				void flags(std::word);
</function><function index="220" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a41ae947e4efee075dd62539798623cbb" name="entsize" args="(void)" definition="BBP::std::word BBP::std::ELF::SectionBuilder::entsize">				std::halfword ehsize(void);
</function><function index="221" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a9b6c85b2800234c429d93323cab99d5c" name="entsize" args="(std::word)" definition="void BBP::std::ELF::SectionBuilder::entsize">				void ehsize(std::halfword);
</function><function index="222" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a5db7526e463f6505a4e2ce93f005ced0" name="Append" args="(std::size_t)" definition="void BBP::std::ELF::SectionBuilder::Append">

#include "Memory.h"

#include "Strings.h"

#include "Resources.h"



#include "ELF32.h"



namespace BBP

{

	namespace std

	{

		namespace ELF

		{

			class ELFBuilder;

			class SegmentBuilder;

			class SectionBuilder;

			class SymbolBuilder;





			class ELFBuilder

			{

			public:



				ELFBuilder(ResourceManager *res, std::size_t segCount, std::size_t secCount, std::size_t symCount);

				ELFBuilder(PAGE&lt;string_element&gt; *_file, ResourceManager *res);



				// The resource manager in use by the ELF

				ResourceManager *allocator;



				// The file in question

				PAGE&lt;string_element&gt; file;



				// Keep track of endiann-ness
</function><function index="223" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1ae3969c8df1ff25a9f0385f9e1e123f06" name="Extend" args="(std::size_t)" definition="void BBP::std::ELF::SectionBuilder::Extend">

				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;



				// Section stack (pointers to save memory)

				Stack&lt;SectionBuilder&gt; sections;



				// Symbol stack (pointers to save memory)

				Stack&lt;SymbolBuilder&gt; symbols;



				std::byte ident(std::byte);

				void ident(std::byte, std::byte);



				std::halfword type(void);

				void type(std::halfword);



				std::halfword machine(void);

				void machine(std::halfword);



				std::word version(void);

				void version(std::word);
</function><function index="224" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a3a50373a9ed12789a1b9411e290e3921" name="close" args="()" definition="void BBP::std::ELF::SectionBuilder::close">				std::address_t entry(void);

				void entry(std::address_t);



				std::offset_t phoff(void);

				void phoff(std::offset_t);



				std::offset_t shoff(void);

				void shoff(std::offset_t);



				std::word flags(void);

				void flags(std::word);


</function><function index="225" id="d5/daf/classBBP_1_1std_1_1ELF_1_1SectionBuilder_1a9708cb7df4cb8ec958275920d88cdece" name="SectionBuilder" args="(ELFBuilder *, std::offset_t)" definition="BBP::std::ELF::SectionBuilder::SectionBuilder">

				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;



				// Section stack (pointers to save memory)

				Stack&lt;SectionBuilder&gt; sections;
</function><function index="226" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1aaa84a5b985f90c569a9ddc1107aa6ddd" name="Append" args="(std::size_t dataSize)" definition="void BBP::std::ELF::SegmentBuilder::Append">#include "Memory.h"

#include "Strings.h"

#include "Resources.h"



#include "ELF32.h"



namespace BBP

{

	namespace std

	{

		namespace ELF

		{

			class ELFBuilder;

			class SegmentBuilder;

			class SectionBuilder;

			class SymbolBuilder;





			class ELFBuilder

			{

			public:



				ELFBuilder(ResourceManager *res, std::size_t segCount, std::size_t secCount, std::size_t symCount);

				ELFBuilder(PAGE&lt;string_element&gt; *_file, ResourceManager *res);



				// The resource manager in use by the ELF
</function><function index="227" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1af00237ccc39f78b66a8b2b0aecbd9f8b" name="type" args="(void)" definition="BBP::std::word BBP::std::ELF::SegmentBuilder::type">				// Symbol stack (pointers to save memory)
</function><function index="228" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a8c448066069660876f34eb9cc09db3df" name="type" args="(std::word)" definition="void BBP::std::ELF::SegmentBuilder::type">				Stack&lt;SymbolBuilder&gt; symbols;
</function><function index="229" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1ab15b446096d2d6d300b8d6abe0f411d0" name="offset" args="(void)" definition="BBP::std::offset_t BBP::std::ELF::SegmentBuilder::offset">				std::halfword type(void);
</function><function index="230" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1abe9ff5115be8a5bc2c0c82464139cbb3" name="offset" args="(std::offset_t)" definition="void BBP::std::ELF::SegmentBuilder::offset">				void type(std::halfword);
</function><function index="231" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1abc4e32090b9d84982aaf01a6c16e03e2" name="vaddr" args="(void)" definition="BBP::std::address_t BBP::std::ELF::SegmentBuilder::vaddr">				std::halfword machine(void);
</function><function index="232" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1ae003002cb9188c9c342028547b31efa6" name="vaddr" args="(std::address_t)" definition="void BBP::std::ELF::SegmentBuilder::vaddr">				void machine(std::halfword);
</function><function index="233" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a084c35bbf7bdbb515a2e05f2913fb2f6" name="paddr" args="(void)" definition="BBP::std::address_t BBP::std::ELF::SegmentBuilder::paddr">				std::word version(void);
</function><function index="234" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1abe55663d462cb6c9d2528afee120164d" name="paddr" args="(std::address_t)" definition="void BBP::std::ELF::SegmentBuilder::paddr">				void version(std::word);
</function><function index="235" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a9e0b6a8199ebabfdf4df50b1290d7724" name="filesz" args="(void)" definition="BBP::std::word BBP::std::ELF::SegmentBuilder::filesz">				std::address_t entry(void);
</function><function index="236" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1ac61bd89e416f1efecee3f079939955aa" name="filesz" args="(std::word)" definition="void BBP::std::ELF::SegmentBuilder::filesz">				void entry(std::address_t);
</function><function index="237" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1afe038c1d119433cf3aec5bfb8849c4c7" name="memsz" args="(void)" definition="BBP::std::word BBP::std::ELF::SegmentBuilder::memsz">				std::offset_t phoff(void);
</function><function index="238" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1af54085ad6c0401a77ba55a85710d3c38" name="memsz" args="(std::word)" definition="void BBP::std::ELF::SegmentBuilder::memsz">				void phoff(std::offset_t);
</function><function index="239" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1ac247750fab4f496cd28aa2dc13a419eb" name="flags" args="(void)" definition="BBP::std::word BBP::std::ELF::SegmentBuilder::flags">				std::byte ident(std::byte);
</function><function index="240" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a8f0e75f91947477de02ae8bd4c99edc3" name="flags" args="(std::word)" definition="void BBP::std::ELF::SegmentBuilder::flags">				void ident(std::byte, std::byte);
</function><function index="241" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a4a8369127b527e0050c782489ceba1c8" name="align" args="(void)" definition="BBP::std::word BBP::std::ELF::SegmentBuilder::align">				std::offset_t shoff(void);
</function><function index="242" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a3ecd22e85d3024ab597cfe417040c55a" name="align" args="(std::word)" definition="void BBP::std::ELF::SegmentBuilder::align">				void shoff(std::offset_t);
</function><function index="243" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a1fb2cb860513ff4521f8bb295ebc78c1" name="close" args="()" definition="void BBP::std::ELF::SegmentBuilder::close">

				// The file in question

				PAGE&lt;string_element&gt; file;



				// Keep track of endiann-ness

				bool Endian;



				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;



				// Section stack (pointers to save memory)

				Stack&lt;SectionBuilder&gt; sections;
</function><function index="244" id="d8/d33/classBBP_1_1std_1_1ELF_1_1SegmentBuilder_1a94ffdcf29551358346c0e867898fb500" name="SegmentBuilder" args="(ELFBuilder *, std::offset_t)" definition="BBP::std::ELF::SegmentBuilder::SegmentBuilder">

				// Segment stack (pointers to save memory)

				Stack&lt;SegmentBuilder&gt; segments;



				// Section stack (pointers to save memory)

				Stack&lt;SectionBuilder&gt; sections;
</function><function index="245" id="d8/d77/structBBP_1_1std_1_1SIGNAL_1aa55b2096d5e25b72cf9f46245c64168e" name="SIGNAL" args="(signal_t sig)" definition="BBP::std::SIGNAL::SIGNAL">			SIGNAL(signal_t sig)

				: _sig(sig)

			{

			}
</function><function index="246" id="de/d21/classBBP_1_1std_1_1Stack_1a8e1d01f86a2a53884afa6409e907c2f1" name="Stack" args="(PAGE&lt; K &gt; *_page)" definition="BBP::std::Stack&lt; K &gt;::Stack">			Stack(PAGE&lt;K&gt; *_page) : page(_page), max_elements(std::seqlen(*_page)), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
</function><function index="247" id="de/d21/classBBP_1_1std_1_1Stack_1ae489b0256b2add75816b35b7ebaf1613" name="Stack" args="(PAGE&lt; K &gt; *_page, size_t max)" definition="BBP::std::Stack&lt; K &gt;::Stack">			Stack(PAGE&lt;K&gt; *_page, size_t max) : page(_page), max_elements(max), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
</function><function index="248" id="de/d21/classBBP_1_1std_1_1Stack_1a49ad838d49b7f52fdbc308b7b9106cd0" name="Stack" args="(STATIC_PAGE&lt; K, N &gt; *_page)" definition="BBP::std::Stack&lt; K &gt;::Stack">			Stack(STATIC_PAGE&lt;K, N&gt; *_page) : page(_page), max_elements(std::seqlen(*_page)), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
</function><function index="249" id="de/d21/classBBP_1_1std_1_1Stack_1a17b43148ac641825cd5cf9efcd0df9ae" name="Stack" args="(STATIC_PAGE&lt; K, N &gt; *_page, size_t max)" definition="BBP::std::Stack&lt; K &gt;::Stack">			Stack(STATIC_PAGE&lt;K, N&gt; *_page, size_t max) : page(_page), max_elements(max), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
</function><function index="250" id="de/d21/classBBP_1_1std_1_1Stack_1a8d19bc2f830f72bd25727b41979de021" name="operator&lt;&lt;" args="(K value)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&lt;&lt;">



			// Read and write 'k' types safely.

			Stack&lt;K&gt; &amp;operator&lt;&lt;(K value); // Write one K

			Stack&lt;K&gt; &amp;operator&gt;&gt;(K &amp;value); // Read one K



			// Read and write 'k' types without safety.

			Stack&lt;K&gt; &amp;operator&lt;=(K value); // Write one K

			Stack&lt;K&gt; &amp;operator&gt;=(K &amp;value); // Read one K



			// Read and write one byte from one stream to another

			Stack&lt;K&gt; &amp;operator&gt;&gt;(Stack&lt;K&gt; &amp;);

			Stack&lt;K&gt; &amp;operator&lt;&lt;(Stack&lt;K&gt; &amp;);


</function><function index="251" id="de/d21/classBBP_1_1std_1_1Stack_1adf3ff221c692972347ea334d007da4fb" name="operator&gt;&gt;" args="(K &amp;value)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&gt;&gt;">			K &amp;operator%=(std::s_offset_t offset); // No safety



			// Return pointer to obj

			K &amp;operator[](std::index_t);



			Stack&lt;K&gt; &amp;operator++();

			Stack&lt;K&gt; &amp;operator--();



			inline Stack&lt;K&gt; &amp;operator++(int a)

			{

				a = a;

				this-&gt;operator++();

				return *this;

			}
</function><function index="252" id="de/d21/classBBP_1_1std_1_1Stack_1ae6e1627a74280e8f8c9ab1c4bf053462" name="operator&lt;=" args="(K value)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&lt;=">			void foreach(Iterator);

			bool all(Predicate);

			bool any(Predicate);







		};



	}

}
</function><function index="253" id="de/d21/classBBP_1_1std_1_1Stack_1a2438b5918618976f30c3512037d987ce" name="operator&gt;=" args="(K &amp;value)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&gt;=">

#endif</function><function index="254" id="de/d21/classBBP_1_1std_1_1Stack_1a0130c9118ae0c4802d35c0a094311c12" name="operator&gt;&gt;" args="(Stack&lt; K &gt; &amp;)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&gt;&gt;">

			void Extend(std::ResourceManager *, size_t);



			void (*readFrom)(Stack&lt;K&gt; *);

			void (*writeTo)(Stack&lt;K&gt; *);



			using Iterator = void (*)(K &amp;);
</function><function index="255" id="de/d21/classBBP_1_1std_1_1Stack_1a9cca09e173921658db58e2a4ca8c8a42" name="operator&lt;&lt;" args="(Stack&lt; K &gt; &amp;)" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator&lt;&lt;">				a = a;

				this-&gt;operator--();

				return *this;

			}



			PAGE&lt;K&gt; *page;


</function><function index="256" id="de/d21/classBBP_1_1std_1_1Stack_1a42f8fad3c66f0d7026bcd081fcd401e7" name="operator+=" args="(std::s_offset_t offset)" definition="K &amp; BBP::std::Stack&lt; K &gt;::operator+=" /><function index="257" id="de/d21/classBBP_1_1std_1_1Stack_1ae9fbcbaf4b3d75bf8d664eb1cb73ffce" name="operator%=" args="(std::s_offset_t offset)" definition="K &amp; BBP::std::Stack&lt; K &gt;::operator%=" /><function index="258" id="de/d21/classBBP_1_1std_1_1Stack_1a4a0a0bbb8783b49135716a1a28f42125" name="operator[]" args="(std::index_t)" definition="K &amp; BBP::std::Stack&lt; K &gt;::operator[]" /><function index="259" id="de/d21/classBBP_1_1std_1_1Stack_1a370763394876da6f2cd48878755ceb1f" name="operator++" args="()" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator++">		template &lt;typename K&gt;

		class Stack

		{

		public:

			
</function><function index="260" id="de/d21/classBBP_1_1std_1_1Stack_1a5c38aeadecf0e79334ae07b7aa205091" name="operator--" args="()" definition="Stack&lt; K &gt; &amp; BBP::std::Stack&lt; K &gt;::operator--">			Stack(PAGE&lt;K&gt; *_page, size_t max) : page(_page), max_elements(max), atElement(0), readFrom(nullptr), writeTo(nullptr) {}



			// Static constructors

			template&lt;int N&gt;

			Stack(STATIC_PAGE&lt;K, N&gt; *_page) : page(_page), max_elements(std::seqlen(*_page)), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
</function><function index="261" id="de/d21/classBBP_1_1std_1_1Stack_1a2a8fd467416463b2606b3ca0dfa1d306" name="operator++" args="(int a)" definition="Stack&lt;K&gt;&amp; BBP::std::Stack&lt; K &gt;::operator++">			inline Stack&lt;K&gt; &amp;operator++(int a)

			{

				a = a;

				this-&gt;operator++();

				return *this;

			}
</function><function index="262" id="de/d21/classBBP_1_1std_1_1Stack_1a675a80c3a04b2c93cddca6395fd5625c" name="operator--" args="(int a)" definition="Stack&lt;K&gt;&amp; BBP::std::Stack&lt; K &gt;::operator--">			inline Stack&lt;K&gt; &amp;operator--(int a)

			{

				a = a;

				this-&gt;operator--();

				return *this;

			}
</function><function index="263" id="de/d21/classBBP_1_1std_1_1Stack_1a4b4f719f8f4c0c213a11fc81bf2d929a" name="Extend" args="(std::ResourceManager *, size_t)" definition="void BBP::std::Stack&lt; K &gt;::Extend" /><function index="264" id="de/d21/classBBP_1_1std_1_1Stack_1af634fcf9694db9550d929e1d65998984" name="foreach" args="(Iterator)" definition="void BBP::std::Stack&lt; K &gt;::foreach" /><function index="265" id="de/d21/classBBP_1_1std_1_1Stack_1a2adcd35954408a0e5a503e87f263a50b" name="all" args="(Predicate)" definition="bool BBP::std::Stack&lt; K &gt;::all" /><function index="266" id="de/d21/classBBP_1_1std_1_1Stack_1a2101f38fbf210dd57d4fba1721357e6a" name="any" args="(Predicate)" definition="bool BBP::std::Stack&lt; K &gt;::any" /><function index="267" id="d4/dea/structBBP_1_1std_1_1STATIC__PAGE_1aadb46e0f1bdaa3e79d9847d66cd85cc7" name="STATIC_PAGE" args="()" definition="BBP::std::STATIC_PAGE&lt; T, K &gt;::STATIC_PAGE">			STATIC_PAGE() : PAGE&lt;T&gt;::PAGE(K, static_data) 

			{

				static_assert(K &lt;= max_page_static_size, "Static page cannot hold more than max_page_static_size items!");

			}
</function><function index="268" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a8e9d1d5d80ea571abf002bf196533f48" name="name" args="(void)" definition="BBP::std::word BBP::std::ELF::SymbolBuilder::name">				std::halfword phnum(void);
</function><function index="269" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a975bf92a9c40e132b9d1a27f2008f1b7" name="name" args="(std::word)" definition="void BBP::std::ELF::SymbolBuilder::name">				void phnum(std::halfword);
</function><function index="270" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a142bdf15739fd4fd6f8a0fba630eb4b0" name="value" args="(void)" definition="BBP::std::word BBP::std::ELF::SymbolBuilder::value">				std::halfword shentsize(void);
</function><function index="271" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a8dc1e772ce50eaabe4801dffccf08c82" name="value" args="(std::address_t)" definition="void BBP::std::ELF::SymbolBuilder::value">				void shentsize(std::halfword);
</function><function index="272" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1ab4b22fc12dc04bfacb03580139134ada" name="size" args="(void)" definition="BBP::std::word BBP::std::ELF::SymbolBuilder::size">				std::halfword shnum(void);
</function><function index="273" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a49d592bab3ceed808bfdafb87a06ef4b" name="size" args="(std::word)" definition="void BBP::std::ELF::SymbolBuilder::size">				void shnum(std::halfword);
</function><function index="274" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1ae1648cc733b1bb94efed548a1ee58d65" name="info" args="(void)" definition="BBP::std::byte BBP::std::ELF::SymbolBuilder::info">				std::halfword shstrndx(void);
</function><function index="275" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a059e578916c2ad92c805c7a4ca6f41db" name="info" args="(std::byte)" definition="void BBP::std::ELF::SymbolBuilder::info">				void shstrndx(std::halfword);
</function><function index="276" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a333060ff8f8b3dc3ff7650982de0fef9" name="other" args="(void)" definition="BBP::std::byte BBP::std::ELF::SymbolBuilder::other">				// Functions to move around various components
</function><function index="277" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1afe11f99597233eb9be95954c74981f69" name="other" args="(std::byte)" definition="void BBP::std::ELF::SymbolBuilder::other">				void emitHeader();
</function><function index="278" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a4ce76b1fe989267a8f20dbb08e64b4b0" name="shndx" args="(void)" definition="BBP::std::halfword BBP::std::ELF::SymbolBuilder::shndx">				void emitELFHeaders();
</function><function index="279" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a3f66776e001df07d06bd538ed347fcfb" name="shndx" args="(std::halfword)" definition="void BBP::std::ELF::SymbolBuilder::shndx">
</function><function index="280" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1af712bf5deb743173585e23792d1cbd56" name="close" args="()" definition="void BBP::std::ELF::SymbolBuilder::close">#include "Memory.h"

#include "Strings.h"

#include "Resources.h"


</function><function index="281" id="d3/db3/classBBP_1_1std_1_1ELF_1_1SymbolBuilder_1a3b6e289d6b397da8c89f9c3d7880bd4a" name="SymbolBuilder" args="(ELFBuilder *, std::offset_t)" definition="BBP::std::ELF::SymbolBuilder::SymbolBuilder">

				std::halfword ehsize(void);

				void ehsize(std::halfword);



				std::halfword phentsize(void);

				void phentsize(std::halfword);
</function><function index="282" id="d5/d8b/structBBP_1_1userspace_1_1Thread_1a9dc94f1901ced80975a29a5ce5be05b5" name="Thread" args="()" definition="BBP::userspace::Thread::Thread">			std::PAGE&lt;std::string_element&gt; initializedData;

			std::PAGE&lt;std::string_element&gt; zeroInitialized;



			// Signal handling stuff goes here



			// Flag handling goes here



			// Fault handling goes here



			Thread()

				: eax(*this, 0, 0, thirtyTwoBit),

				   ax(*this, 0, 0, sixteenBit),

				   ah(*this, 0, 1, eightBit),

				   al(*this, 0, 0, eightBit),



				ecx(*this, 0, 0, thirtyTwoBit),

				cx(*this, 0, 0, sixteenBit),

				ch(*this, 0, 1, eightBit),

				cl(*this, 0, 0, eightBit),



				edx(*this, 0, 0, thirtyTwoBit),

				dx(*this, 0, 0, sixteenBit),

				dh(*this, 0, 1, eightBit),

				dl(*this, 0, 0, eightBit),



				ebx(*this, 0, 0, thirtyTwoBit),

				bx(*this, 0, 0, sixteenBit),

				bh(*this, 0, 1, eightBit),

				bl(*this, 0, 0, eightBit),



				esi(*this, 0, 0, thirtyTwoBit),

				six(*this, 0, 0, sixteenBit),

				sih(*this, 0, 1, eightBit),

				sil(*this, 0, 0, eightBit),



				edi(*this, 0, 0, thirtyTwoBit),

				dix(*this, 0, 0, sixteenBit),

				dih(*this, 0, 1, eightBit),

				dil(*this, 0, 0, eightBit),



				tix(*this, 0, 0, thirtyTwoBit),

				st(*this, 0, 0, sixteenBit),

				ob(*this, 0, 1, eightBit),

				tb(*this, 0, 0, eightBit),

				ct(*this, 0, 0, thirtyTwoBit),

				pp(*this, 0, 0, sixteenBit),

				tp(*this, 0, 1, eightBit),



				ssx(*this, 0, 0, thirtyTwoBit),

				hv(*this, 0, 0, sixteenBit),

				ho(*this, 0, 1, eightBit),

				ht(*this, 0, 0, eightBit),

				ss(*this, 0, 0, thirtyTwoBit),

				cs(*this, 0, 0, sixteenBit),

				sf(*this, 0, 1, eightBit),



				sui(*this, 0, 0, thirtyTwoBit),

				asi(*this, 0, 0, sixteenBit),

				gsi(*this, 0, 1, eightBit),


</function><function index="283" id="dd/d40/classBBP_1_1std_1_1VOLUME_1a7493b1c50936611c82a09dd545c1fcd5" name="VOLUME" args="(char l, std::conststring)" definition="BBP::std::VOLUME::VOLUME">#include "Strings.h"

#include "Resources.h"

#include "stdio.h"



#ifndef BBP_STDLIB_FILESYS_NOOVERWRITE

#define BBP_STDLIB_FILESYS_OVERWRITEEXISTINGFILES
</function><function index="284" id="dd/d40/classBBP_1_1std_1_1VOLUME_1a833d40b349bd7ca7f8e88cde6a52693d" name="VOLUME" args="(char l)" definition="BBP::std::VOLUME::VOLUME">			VOLUME(char l) : VOLUME(l, "/") {}
</function><function index="285" id="dd/d40/classBBP_1_1std_1_1VOLUME_1ac7a62d8fcc8c915abfa122c76107676f" name="~VOLUME" args="()" definition="BBP::std::VOLUME::~VOLUME">

namespace BBP

{

	namespace std
</function><function index="286" id="d4/db8/classWhy_1a05010f437f1536dec5e18178449c9647" name="becauseFuckYouThatsWhy" args="()" definition="static void Why::becauseFuckYouThatsWhy">	static inline void becauseFuckYouThatsWhy()

	{}
</function><function index="287" id="db/d2b/structBBP_1_1std_1_1window_1a859802536a4494ac9d71e44d3ea47565" name="window" args="()" definition="BBP::std::window::window">			window()

			{

				width = 0;

				height = 0;



				xPos = 0;

				yPos = 0;

				zPos = 0;

			}
</function><function index="288" id="d9/d6f/namespaceBBP_1ac0a46562b554fd736c409bf2c645c9ba" name="shell" args="(BBP::std::string &amp;str)" definition="int BBP::shell">    int shell(BBP::std::string &amp;str)

    {

        // Get the first command line arg

        std::c_string command = std::read_a(&amp;str, 0);

        

        // Then go until space

        for (std::index_t index = 0; index &lt; str.dataSize; index++)

        {

            // Read char at index index

            std::string_element c = std::read(&amp;str, index);



            // Check if 'c' is a space

            if (c != ' ')

                continue;

            

            str.data[index] = 0;

            break;



        }



        // If string is just empty, do nothing

        if (command[0] == 0)

            return 0;



        // Create paths

        std::PATH procPath("/proc/exec/");

        procPath.makeAbsolutePath(std::workingDirectory);

        std::PATH executable(command);

        executable.makeAbsolutePath(&amp;procPath);



        



        try 

        {

            // Create file, if it exists, no error will be thrown. Otherwise, an error will be thrown.

            std::FILE executableFile(executable);



            // The file exists. Check if the page has the correct magic numbers.

            std::mem_t magic0 = std::read_r(executableFile.data()-&gt;fileData.page, BBP_EXEC_MAGIC0IDX);

            std::mem_t magic1 = std::read_r(executableFile.data()-&gt;fileData.page, BBP_EXEC_MAGIC1IDX);

            std::mem_t magic2 = std::read_r(executableFile.data()-&gt;fileData.page, BBP_EXEC_MAGIC2IDX);

            std::mem_t magic3 = std::read_r(executableFile.data()-&gt;fileData.page, BBP_EXEC_MAGIC3IDX);



            // If the magic matches up, this file is an executable.

            bool isMachineCodeExecutable = (magic0 == BBP_EXEC_MAGIC0) &amp;&amp; (magic1 == BBP_EXEC_MAGIC1) &amp;&amp; (magic2 == BBP_EXEC_MAGIC2) &amp;&amp; (magic3 == BBP_EXEC_MAGIC3);

            

            if (isMachineCodeExecutable)

            {

                // This file is an executable in machine code format. Extract the function from the page, and execute.

                std::executable_main _entry = ((std::executable_main *)executableFile.data()-&gt;fileData.page-&gt;raw)[0];

                std::execute(_entry, 0, nullptr);

            }

            else

            {

                std::printf("%s: Exec format error.\n", command);

            }



            return std::__errno;



        }

        catch (std::except const &amp;e)

        {

            switch (std::__errno)

            {

            case ENOENT:

                std::printf("%s: command not found.\n", command);

                std::__errno = 0;

                return -1;

                break;

            default:

                // Unkown error, rethrow

                throw;

            }

        }



    }
</function><function index="289" id="d9/d6f/namespaceBBP_1a3c454fd023d39b1a05fa1d24941347e9" name="shell" args="(const char *ss)" definition="int BBP::shell">    int shell(const char *ss)

    {

        // Get string length

        std::size_t strL = std::strlen(ss);



        // Create new string of that size

        std::string str(strL + 1, (std::string_element *)BBP::std::activemem-&gt;calloc(strL + 1, sizeof(std::string_element)));



        // Copy string

        std::strcpy(&amp;str, ss);



        // save shell return value

        int s = shell(str);



        // Free string mem

        BBP::std::activemem-&gt;free(str.data);



        // Return shell result

        return s;



    }
</function><function index="290" id="d9/d6f/namespaceBBP_1ad05ebc9ee4f15f3b8aa702c90586393f" name="shell_main" args="(int argc, char **argv)" definition="int BBP::shell_main">    int shell_main(int argc, char **argv)

    {

        // This surpresses the g++ unused parameters warnings

        argc = argc;

        argv = argv;



        int count = 0;

        bool doLoop = true;



        shell("elsa");

        return 0;



        while (true)

        {

            std::printf("\e[0;92m" HOSTNAME "\e[0;37m:\e[1;34m%s\e[0;37m$ ", std::workingDirectory-&gt;relName());



            while (doLoop)

            {

                std::getC();

                if (std::STDIN.atElement)

                {

                    char c = 0;

                    char del = 0x08;

                    std::STDIN &gt;&gt; c;



                    //std::printf("0x%02x ", c);



                    switch (c)

                    {

                    case 0x0a:

                    case 0x0d:

                        doLoop = false;

                        

                        break;



                    case 12:

                        // Screen clear

                        std::printf("\033[2J\033[1;1H");

                        std::printf("\e[0;92m" HOSTNAME "\e[0;37m:\e[1;34m%s\e[0;37m$ ", std::workingDirectory-&gt;relName());

                        break;



                    case 0x7f:

                        

                        if (line.atElement)

                        {

                            std::STDOUT &lt;&lt;= del;

                            std::STDOUT &lt;&lt;= ' ';

                            std::STDOUT &lt;&lt;= del;

                            line--;

                        }



                        break;

                    default:

                        std::STDOUT &lt;&lt;= c;

                        line &lt;&lt; c;

                        break;

                    }

                }

            }

            line &lt;&lt; '\0';

            std::printf("\n");

            shell(linePage);

            line.atElement = 0;

            count++;

            doLoop = true;

        }





        return 0;

    }
</function><function index="291" id="d9/d6f/namespaceBBP_1a2f249970c78eb045d841a355fb07ca46" name="boot_main" args="(int, char **)" definition="int BBP::boot_main" /><function index="292" id="d9/d6f/namespaceBBP_1aa14c9c6b5ef8116b2d552362ff8860f9" name="logout_main" args="(int, char **)" definition="int BBP::logout_main">	int badapple_main(int, char **);

	int smile_main(int, char **);

}


</function><function index="293" id="d9/d6f/namespaceBBP_1af3fe0646c6739928ebbbf2e7591002e0" name="neofetch_main" args="(int, char **)" definition="int BBP::neofetch_main" /><function index="294" id="d9/d6f/namespaceBBP_1acdc8259ae9919d6dad925d6ead142a50" name="badapple_main" args="(int, char **)" definition="int BBP::badapple_main" /><function index="295" id="d9/d6f/namespaceBBP_1a0ba2e2ff83f9f917f9811058a5d02a0b" name="smile_main" args="(int, char **)" definition="int BBP::smile_main" /><function index="296" id="df/d72/namespaceBBP_1_1esa_1a3aff5449e05ebaf7c68478bbffdbae84" name="PRAGMA" args="(include)" definition="BBP::esa::PRAGMA">#define UNDEF_HANDLE 3

#define IFNDEF_HANDLE 4

#define IFDEF_HANDLE 5

#define ENDIF_HANDLE 6

#define ELSE_HANDLE 7

#define ATOMIC_HANDLE 8

#define HANDOVER_HANDLE 9

#define CONTINUE_HANDLE 10



#define STATIC_HANDLE 11

#define CONST_HANDLE 12

#define VIRTUAL_HANDLE 13

#define EXTERN_HANDLE 14

#define PROCEDURE_HANDLE 15

#define END_HANDLE 16

#define LABEL_HANDLE 17



#define CARRIAGERETURN_HANDLE 18

#define NEWLINE_HANDLE 19

#define SEMICOLON_HANDLE 20

#define OPENBRACKET_HANDLE 21

#define CLOSEBRACKET_HANDLE 22

#define COMMA_HANDLE 23

#define OPENSQBRACKET_HANDLE 24

#define CLOSESQBRACKET_HANDLE 25

#define OPENCURLBRACKET_HANDLE 26

#define CLOSECURLBRACKET_HANDLE 27

#define PERCENT_HANDLE 28

#define OPENANGLEBRACKET_HANDLE 29

#define CLOSEANGLEBRACKET_HANDLE 30

#define DOUBLEQUOTES_HANDLE 31

#define SINGLEQUOTES_HANDLE 32

#define COLON_HANDLE 33

#define BACKSLASH_HANDLE 34



#define DN_HANDLE 35

#define DB_HANDLE 36

#define DH_HANDLE 37

#define DI_HANDLE 38

#define DA_HANDLE 39

#define DW_HANDLE 40



// NIL instructions

#define NIL_HANDLE 41



// STACK instructions

#define PUSH_HANDLE 42

#define POP_HANDLE 43

#define POPA_HANDLE 44



// CTRL instructions

#define RET_HANDLE 45

#define CALL_HANDLE 46

#define CALLP_HANDLE 47

#define SYSCALL_HANDLE 48



// MEM instructions

#define MOVB_HANDLE 49

#define MOVH_HANDLE 50

#define MOVW_HANDLE 51

#define MOVA_HANDLE 52



#define MOVBH_HANDLE 53
</function><function index="297" id="df/d72/namespaceBBP_1_1esa_1aabde672bee184b8ee5064a9bd7b2cc49" name="PRAGMA" args="(handler)" definition="BBP::esa::PRAGMA">#define MOVBA_HANDLE 55



#define MOVHB_HANDLE 56

#define MOVHW_HANDLE 57
</function><function index="298" id="df/d72/namespaceBBP_1_1esa_1a4ae9322cf167da94e4e350d561d48ac5" name="PRAGMA" args="(define)" definition="BBP::esa::PRAGMA">

#define MOVWB_HANDLE 59

#define MOVWH_HANDLE 60

#define MOVWA_HANDLE 61



#define MOVAB_HANDLE 62

#define MOVAH_HANDLE 63

#define MOVAW_HANDLE 64





// MATH instructions

#define INC_HANDLE 65

#define DEC_HANDLE 66

#define NEG_HANDLE 67

#define ADD_HANDLE 68

#define SUB_HANDLE 69

#define MUL_HANDLE 70

#define DIV_HANDLE 71

#define MOD_HANDLE 72

#define INCF_HANDLE 73

#define DECF_HANDLE 74

#define NEGF_HANDLE 75

#define ADDF_HANDLE 76

#define SUBF_HANDLE 77

#define MULF_HANDLE 78

#define DIVF_HANDLE 79

#define MODF_HANDLE 80

#define ADDFF_HANDLE 81

#define SUBFF_HANDLE 82

#define MULFF_HANDLE 83

#define DIVFF_HANDLE 84

#define MODFF_HANDLE 85

#define ADDIF_HANDLE 86

#define SUBIF_HANDLE 87

#define MULIF_HANDLE 88

#define DIVIF_HANDLE 89

#define MODIF_HANDLE 90



#define LBS_HANDLE 91

#define RBS_HANDLE 92

#define OR_HANDLE 93

#define XOR_HANDLE 94

#define AND_HANDLE 95

#define NOT_HANDLE 96

#define ORB_HANDLE 97

#define XORB_HANDLE 98

#define ANDB_HANDLE 99

#define NOTB_HANDLE 100

#define LBSIP_HANDLE 101

#define RBSIP_HANDLE 102

#define ORIP_HANDLE 103

#define XORIP_HANDLE 104

#define ANDIP_HANDLE 105

#define NOTIP_HANDLE 106

#define ORBIP_HANDLE 107

#define XORBIP_HANDLE 108

#define ANDBIP_HANDLE 109

#define NOTBIP_HANDLE 110



// FLAG instructions

#define COMP_HANDLE 111

#define FLAG_HANDLE 112



// Extended CTRL instructions

#define ROUTINE_HANDLE 113



// JUMP instructions

#define JMP_HANDLE 114
</function><function index="299" id="df/d72/namespaceBBP_1_1esa_1a6967a3e908d9025792f0ccc4f3d3da2b" name="PRAGMA" args="(undef)" definition="BBP::esa::PRAGMA">#define JGZ_HANDLE 116

#define JEZ_HANDLE 117

#define JLT_HANDLE 118

#define JGT_HANDLE 119

#define JLZN_HANDLE 120

#define JGZN_HANDLE 121

#define JEZN_HANDLE 122

#define JLTN_HANDLE 123

#define JGTN_HANDLE 124

#define JMPR_HANDLE 125

#define JLZR_HANDLE 126

#define JGZR_HANDLE 127

#define JEZR_HANDLE 128

#define JLTR_HANDLE 129

#define JGTR_HANDLE 130

#define JLZNR_HANDLE 131

#define JGZNR_HANDLE 132

#define JEZNR_HANDLE 133

#define JLTNR_HANDLE 134

#define JGTNR_HANDLE 135



// PAGE instructions

#define PAGE_HANDLE 136

#define PAGEAW_HANDLE 137

#define PAGEAR_HANDLE 138

#define PAGEW_HANDLE 139

#define PAGER_HANDLE 140

#define PALLOC_HANDLE 141

#define PFREE_HANDLE 142

#define PAGES_HANDLE 143

#define PAGEBC_HANDLE 144

#define PASSIGN_HANDLE 145



// SIGNAL instructions

#define SIGNAL_HANDLE 146

#define SIGNALF_HANDLE 147



// HALT instructions

#define HLT_HANDLE 148

#define HCF_HANDLE 149

#define HBU_HANDLE 150



namespace BBP

{
</function><function index="300" id="df/d72/namespaceBBP_1_1esa_1a6e6dcccd889373eca729083c1cb12230" name="PRAGMA" args="(ifndef)" definition="BBP::esa::PRAGMA">	namespace esa

	{



		// ESA directives

		PRAGMA(include);		// Analogous to #include

		PRAGMA(handler);	// See documentation

		PRAGMA(define);		// Defines a macro, but also keeps track of which ones are defined

		PRAGMA(undef);		// Undefines a macro

		PRAGMA(ifndef);		// If a macro is not defined, go ahead

		PRAGMA(ifdef);		// If a macro is defined, go ahead

		PRAGMA(endif);		// Stop skipping stuff

		PRAGMA(else);		// Do the other thing from before.

		PRAGMA(atomic);		// Force the processor to stay on this thread

		PRAGMA(handover);	// Force the processor to move to another thread here

		PRAGMA(continue);	// Stop forcing the processor to do stuff



		// The keywords used

		ACTION(static);

		ACTION(const);

		ACTION(virtual);

		ACTION(extern);

		ACTION(procedure);

		ACTION(end);

		ACTION(endroutine);



		// Tokens used

		TOKEN(newline);

		TOKEN(semicolon);

		TOKEN(openDelimiter);

		TOKEN(closeDelimiter);

		TOKEN(comma);

		TOKEN(caret);

		TOKEN(doubleQuote);

		TOKEN(singleQuote);

		TOKEN(colon);

		TOKEN(backslash);

		TOKEN(size);





		// Instructions

		INSTRUCTION(nil);

		INSTRUCTION(stack);

		INSTRUCTION(ctrl);

		INSTRUCTION(mem);

		INSTRUCTION(inc);
</function><function index="301" id="df/d72/namespaceBBP_1_1esa_1a376a651ef0025ec30379627f00a0991a" name="PRAGMA" args="(ifdef)" definition="BBP::esa::PRAGMA">		INSTRUCTION(neg);

		INSTRUCTION(add);

		INSTRUCTION(sub);

		INSTRUCTION(mul);

		INSTRUCTION(div);

		INSTRUCTION(mod);

		INSTRUCTION(lbs);

		INSTRUCTION(rbs);

		INSTRUCTION(or );

		INSTRUCTION(xor);

		INSTRUCTION(and);

		INSTRUCTION(not);

		INSTRUCTION(flag);

		INSTRUCTION(jmp);

		INSTRUCTION(jmpc);

		INSTRUCTION(jmpz);

		INSTRUCTION(page);

		INSTRUCTION(signal);

		INSTRUCTION(halt);







	}



}



#undef ACTION

#undef TOKEN

#undef PRAGMA

#undef INSTRUCTION

#define ACTION(name) BBP::std::conststring BBP::esa::kw_##name (BBP::std::Lexer::lex_context *context, BBP::std::index_t index, BBP::std::Lexer::lex_keywordhandle handle)

#define TOKEN(name) BBP::std::conststring BBP::esa::tk_##name (BBP::std::Lexer::lex_context *context, BBP::std::index_t index, BBP::std::Lexer::lex_keywordhandle handle)

#define PRAGMA(name) BBP::std::conststring BBP::esa::pragma_##name (BBP::std::Lexer::lex_context *context, BBP::std::index_t index, BBP::std::Lexer::lex_keywordhandle handle)

#define INSTRUCTION(name) BBP::std::conststring BBP::esa::mn_##name (BBP::std::Lexer::lex_context *context, BBP::std::index_t index, BBP::std::Lexer::lex_keywordhandle handle)

#define AUX(name) BBP::std::conststring BBP::esa::##name (BBP::std::Lexer::lex_context *, BBP::std::index_t, BBP::std::Lexer::lex_keywordhandle)


</function><function index="302" id="df/d72/namespaceBBP_1_1esa_1ae125979ea909824a16d7d3e091c5a5d1" name="PRAGMA" args="(endif)" definition="BBP::esa::PRAGMA" /><function index="303" id="df/d72/namespaceBBP_1_1esa_1a4c1978acd11f1c60bc0e3f5cdc0bba3d" name="PRAGMA" args="(else)" definition="BBP::esa::PRAGMA" /><function index="304" id="df/d72/namespaceBBP_1_1esa_1af2491b974ed6e5dfd91f988ffbeec55f" name="PRAGMA" args="(atomic)" definition="BBP::esa::PRAGMA" /><function index="305" id="df/d72/namespaceBBP_1_1esa_1aa878bfc30ecfba31d53f1bcd4f3396b6" name="PRAGMA" args="(handover)" definition="BBP::esa::PRAGMA" /><function index="306" id="df/d72/namespaceBBP_1_1esa_1a63ab48c1544c11b30cf7b8973dc3c4a7" name="PRAGMA" args="(continue)" definition="BBP::esa::PRAGMA" /><function index="307" id="df/d72/namespaceBBP_1_1esa_1a1e219df3520157b5f50076e6e7e7e250" name="ACTION" args="(static)" definition="BBP::esa::ACTION" /><function index="308" id="df/d72/namespaceBBP_1_1esa_1a3777ff300b8f0a94ac58e777d8877534" name="ACTION" args="(const)" definition="BBP::esa::ACTION" /><function index="309" id="df/d72/namespaceBBP_1_1esa_1adb2d356e3988d26ce0730f993d09836c" name="ACTION" args="(virtual)" definition="BBP::esa::ACTION" /><function index="310" id="df/d72/namespaceBBP_1_1esa_1afe48c2bb73ee462fb41415d80586657c" name="ACTION" args="(extern)" definition="BBP::esa::ACTION" /><function index="311" id="df/d72/namespaceBBP_1_1esa_1a8be66acb92b552dcec6dd4f470e75bf0" name="ACTION" args="(procedure)" definition="BBP::esa::ACTION" /><function index="312" id="df/d72/namespaceBBP_1_1esa_1a12036e29fe89ed5f33db3ef83bed0099" name="ACTION" args="(end)" definition="BBP::esa::ACTION" /><function index="313" id="df/d72/namespaceBBP_1_1esa_1a378c228d11eb0f5036c884aece1e5076" name="ACTION" args="(endroutine)" definition="BBP::esa::ACTION" /><function index="314" id="df/d72/namespaceBBP_1_1esa_1ac55c91862e5f70653b813af5c314dea7" name="TOKEN" args="(newline)" definition="BBP::esa::TOKEN" /><function index="315" id="df/d72/namespaceBBP_1_1esa_1af5eb96e9ac657293a30379703b75efba" name="TOKEN" args="(semicolon)" definition="BBP::esa::TOKEN" /><function index="316" id="df/d72/namespaceBBP_1_1esa_1a54588e10bc829ad5d640e64e1356d3ce" name="TOKEN" args="(openDelimiter)" definition="BBP::esa::TOKEN" /><function index="317" id="df/d72/namespaceBBP_1_1esa_1a403ba551f1ee42fe1580e8a8512bfa35" name="TOKEN" args="(closeDelimiter)" definition="BBP::esa::TOKEN" /><function index="318" id="df/d72/namespaceBBP_1_1esa_1afd3a06bcc97d8fcdfb32a53478282ef2" name="TOKEN" args="(comma)" definition="BBP::esa::TOKEN" /><function index="319" id="df/d72/namespaceBBP_1_1esa_1a82381333342e731dfb93f09c84b51132" name="TOKEN" args="(caret)" definition="BBP::esa::TOKEN" /><function index="320" id="df/d72/namespaceBBP_1_1esa_1ad4ccb077def20101accff187545f4b6c" name="TOKEN" args="(doubleQuote)" definition="BBP::esa::TOKEN" /><function index="321" id="df/d72/namespaceBBP_1_1esa_1aceac1883d416f22963a0707658d7e110" name="TOKEN" args="(singleQuote)" definition="BBP::esa::TOKEN" /><function index="322" id="df/d72/namespaceBBP_1_1esa_1a1823ca27ef7c399993c2afd0120757bc" name="TOKEN" args="(colon)" definition="BBP::esa::TOKEN" /><function index="323" id="df/d72/namespaceBBP_1_1esa_1a65caea5c1472041f390cca7a0e800acf" name="TOKEN" args="(backslash)" definition="BBP::esa::TOKEN" /><function index="324" id="df/d72/namespaceBBP_1_1esa_1a525eca9a0c00d832c8c5fe6722ace044" name="TOKEN" args="(size)" definition="BBP::esa::TOKEN" /><function index="325" id="df/d72/namespaceBBP_1_1esa_1a0eabac2fa0653290ed5f7c42a0d0bbb6" name="INSTRUCTION" args="(nil)" definition="BBP::esa::INSTRUCTION" /><function index="326" id="df/d72/namespaceBBP_1_1esa_1a55556f03ed541d5ddbfcc107383ff4f0" name="INSTRUCTION" args="(stack)" definition="BBP::esa::INSTRUCTION" /><function index="327" id="df/d72/namespaceBBP_1_1esa_1afbb86002c0e686550b6db9cd18643a01" name="INSTRUCTION" args="(ctrl)" definition="BBP::esa::INSTRUCTION" /><function index="328" id="df/d72/namespaceBBP_1_1esa_1a7270868ee9626ba58f73b71bb6f96068" name="INSTRUCTION" args="(mem)" definition="BBP::esa::INSTRUCTION" /><function index="329" id="df/d72/namespaceBBP_1_1esa_1acca2dee8b95ee929b51f69e29210ee35" name="INSTRUCTION" args="(inc)" definition="BBP::esa::INSTRUCTION" /><function index="330" id="df/d72/namespaceBBP_1_1esa_1a0f5ace888e2e97c1af4185f776e41157" name="INSTRUCTION" args="(dec)" definition="BBP::esa::INSTRUCTION" /><function index="331" id="df/d72/namespaceBBP_1_1esa_1a044680bbd9543a92f0a1570bca541adf" name="INSTRUCTION" args="(neg)" definition="BBP::esa::INSTRUCTION" /><function index="332" id="df/d72/namespaceBBP_1_1esa_1a5cdbb37fec09abcfa1b655e50ac300f8" name="INSTRUCTION" args="(add)" definition="BBP::esa::INSTRUCTION" /><function index="333" id="df/d72/namespaceBBP_1_1esa_1a2ac383d2a44e8a3bd156c65d6b1123c5" name="INSTRUCTION" args="(sub)" definition="BBP::esa::INSTRUCTION" /><function index="334" id="df/d72/namespaceBBP_1_1esa_1ab89285ad6ec44b992e18c9319d2e12f7" name="INSTRUCTION" args="(mul)" definition="BBP::esa::INSTRUCTION" /><function index="335" id="df/d72/namespaceBBP_1_1esa_1aeadf729eb17c492d0e9b1d743c5ee0c0" name="INSTRUCTION" args="(div)" definition="BBP::esa::INSTRUCTION" /><function index="336" id="df/d72/namespaceBBP_1_1esa_1aeca3f5a97e516916ac87423eca0d6580" name="INSTRUCTION" args="(mod)" definition="BBP::esa::INSTRUCTION" /><function index="337" id="df/d72/namespaceBBP_1_1esa_1ac11ca03ca0b25d1700c89824d78a5e7c" name="INSTRUCTION" args="(lbs)" definition="BBP::esa::INSTRUCTION" /><function index="338" id="df/d72/namespaceBBP_1_1esa_1a9e1c81f6d4c9b5a295e440e08b9ef7d9" name="INSTRUCTION" args="(rbs)" definition="BBP::esa::INSTRUCTION" /><function index="339" id="df/d72/namespaceBBP_1_1esa_1ad7a8860a16d4f84a398acbcbf842c76a" name="INSTRUCTION" args="(or)" definition="BBP::esa::INSTRUCTION" /><function index="340" id="df/d72/namespaceBBP_1_1esa_1ac5fc728568cda6a0f471c198aa1e5860" name="INSTRUCTION" args="(xor)" definition="BBP::esa::INSTRUCTION" /><function index="341" id="df/d72/namespaceBBP_1_1esa_1a6a4d6d7f9a4160ebace06e3406d80fcf" name="INSTRUCTION" args="(and)" definition="BBP::esa::INSTRUCTION" /><function index="342" id="df/d72/namespaceBBP_1_1esa_1a0c5b48d28d842b92e9c1d98bc345ff8e" name="INSTRUCTION" args="(not)" definition="BBP::esa::INSTRUCTION" /><function index="343" id="df/d72/namespaceBBP_1_1esa_1aae7777096b8691efdf3dc0217d4e740d" name="INSTRUCTION" args="(flag)" definition="BBP::esa::INSTRUCTION" /><function index="344" id="df/d72/namespaceBBP_1_1esa_1adb650f68a6de04f65e2e794d5b871307" name="INSTRUCTION" args="(jmp)" definition="BBP::esa::INSTRUCTION" /><function index="345" id="df/d72/namespaceBBP_1_1esa_1a47d72095af2aa836db18d4bba248935c" name="INSTRUCTION" args="(jmpc)" definition="BBP::esa::INSTRUCTION" /><function index="346" id="df/d72/namespaceBBP_1_1esa_1ad6560a0da2c10fe1f6569a19d6f4dc66" name="INSTRUCTION" args="(jmpz)" definition="BBP::esa::INSTRUCTION" /><function index="347" id="df/d72/namespaceBBP_1_1esa_1a2fe6657ee096963c67e0dd789e4fb2e8" name="INSTRUCTION" args="(page)" definition="BBP::esa::INSTRUCTION" /><function index="348" id="df/d72/namespaceBBP_1_1esa_1a6f1c531accfe30525f4742019b07c045" name="INSTRUCTION" args="(signal)" definition="BBP::esa::INSTRUCTION" /><function index="349" id="df/d72/namespaceBBP_1_1esa_1a8168478518d83ec93be5b55b7f806980" name="INSTRUCTION" args="(halt)" definition="BBP::esa::INSTRUCTION" /><function index="350" id="dd/d98/namespaceBBP_1_1std_1a11456392cec6b2a0ba2c507dc01c6305" name="swap" args="(int *a, int *b)" definition="void BBP::std::swap">        void swap(int *a, int *b)

        {

            int temp = *a;

            *a = *b;

            *b = temp;

        }
</function><function index="351" id="dd/d98/namespaceBBP_1_1std_1a47a9ae70757f2bb15bcae0d6fb9eaf7f" name="absolute" args="(float x)" definition="float BBP::std::absolute">        float absolute(float x)

        {

            if (x &lt; 0) return -x;

            else return x;

        }
</function><function index="352" id="dd/d98/namespaceBBP_1_1std_1aebc8a39aad9128808dcf6ac855719481" name="iPartOfNumber" args="(float x)" definition="int BBP::std::iPartOfNumber">        int iPartOfNumber(float x)

        {

            return (int)x;

        }
</function><function index="353" id="dd/d98/namespaceBBP_1_1std_1a20e33a07e6004b7dbfa9a29f09073df0" name="roundNumber" args="(float x)" definition="int BBP::std::roundNumber">        int roundNumber(float x)

        {

            return iPartOfNumber(x + 0.5);

        }
</function><function index="354" id="dd/d98/namespaceBBP_1_1std_1a6aa6ba289ce8a1387edd39e657934d4b" name="fPartOfNumber" args="(float x)" definition="float BBP::std::fPartOfNumber">        float fPartOfNumber(float x)

        {

            if (x &gt; 0) return x - iPartOfNumber(x);

            else return x - (iPartOfNumber(x) + 1);



        }
</function><function index="355" id="dd/d98/namespaceBBP_1_1std_1a190bfefd35c61c45ad74455cfbbc8907" name="rfPartOfNumber" args="(float x)" definition="float BBP::std::rfPartOfNumber">        float rfPartOfNumber(float x)

        {

            return 1 - fPartOfNumber(x);

        }
</function><function index="356" id="dd/d98/namespaceBBP_1_1std_1a750ba4c285e0788e84722a30a776b913" name="exception" args="(const char *msg, errno_t _errno)" definition="BBP::std::except BBP::std::exception">namespace BBP

{

	namespace std

	{



		struct except;

		except exception(const char *msg, errno_t _errno);





#ifndef BBP_STDLIB_EXCEPT_H

#define BBP_STDLIB_EXCEPT_H

		volatile extern errno_t __errno;
</function><function index="357" id="dd/d98/namespaceBBP_1_1std_1a944d73360eb8ebade3c1e252ecf1eedc" name="getNextAvailablePID" args="()" definition="BBP::std::PID_t BBP::std::getNextAvailablePID" /><function index="358" id="dd/d98/namespaceBBP_1_1std_1ace14a8680f46b3c05954e4d1f03ab1fe" name="execute" args="(executable_main, int argc, char **argv)" definition="void BBP::std::execute">#define BBP_EXEC_MAGIC3IDX 11



namespace BBP

{

	namespace std

	{

		

		// Define the signature of a main function

		typedef int(*executable_main)(int argc, char **argv);



		// Define the type that PID_t is

		typedef uint8_t PID_t;



		// This structure defines the structure of an executable

		struct Executable

		{

			executable_main entry;

			std::conststring name;

		};



		struct executableFrame

		{

			// The PID of the executable.

			PID_t PID;



			// Program memory

			std::ResourceManager *pmem;



			// Check if current execution frame is the active frame

			bool isActiveFrame;



			// Check if current frame is running anything

			bool isExecuting;



			// Arguments

			int argc;



		};



		// This page stores each executableFrame

		extern STATIC_PAGE&lt;executableFrame, 12&gt; procFrames;

		extern Stack&lt;executableFrame&gt; Processes;



		// Stores which PID is the active PID

		extern PID_t activeExecutable;



		// Helper functions

		PID_t getNextAvailablePID();



		

		// ...

		PID_t spawnExecutable(executable_main, std::string &amp;);









		// This is a constant array that stores the executables. In the future, this could be done dynamically, but i am too lazy for that :)

		extern const Executable executables[];



		// Executes an executable. Pretty simple.

		void execute(executable_main, int argc, char **argv);

		void exit();





	}

}







#endif
</function><function index="359" id="dd/d98/namespaceBBP_1_1std_1aa4dc45e65f9885f143b9d0f63882214d" name="exit" args="()" definition="void BBP::std::exit" /><function index="360" id="dd/d98/namespaceBBP_1_1std_1aafa51bc36e198e57ac71a6d97d1f07dd" name="fprintf" args="(BBP::std::FILE &amp;file, std::conststring format, Args... args)" definition="void BBP::std::fprintf">		inline void fprintf(BBP::std::FILE &amp;file, std::conststring format, Args... args)

		{

			// Check if can write to file

			if (!file.is_open())

				throw std::exception("ERR_FILE_NOT_OPEN", EBADF);



			// Allocate a buffer

			std::string buffer(BBP::std::max_page_elements, (BBP::std::string_element *)BBP::std::activemem-&gt;calloc(BBP::std::max_page_elements, sizeof(BBP::std::string_element)));



			// Format the string

			std::sprintf(buffer.data, format, args...);



			// Then print

			file.data()-&gt;fileData &lt;&lt;= buffer;



			// Then free the buffer

			BBP::std::activemem-&gt;free(buffer.data);



		}
</function><function index="361" id="dd/d98/namespaceBBP_1_1std_1a803d7789d9729ba4d3125bde7f8d4bf4" name="memcpy" args="(PAGE&lt; T &gt; &amp;src, PAGE&lt; T &gt; &amp;dst)" definition="void BBP::std::memcpy">		inline void memcpy(PAGE&lt;T&gt; &amp;src, PAGE&lt;T&gt; &amp;dst)

		{

			// Get sequence length of src

			std::size_t srcLen = std::seqlen(src);

			std::size_t dstLen = std::seqlen(dst);



			memcpy(src, dst, (srcLen &lt; dstLen) ? srcLen : dstLen);

		}
</function><function index="362" id="dd/d98/namespaceBBP_1_1std_1a0ae9ccd4d792c51369ee76001e4db8a1" name="decimals" args="(uint32_t value)" definition="BBP::uint32_t BBP::std::decimals">

namespace BBP

{



	typedef signed char        int8_t;

	typedef short              int16_t;

	typedef int                int32_t;
</function><function index="363" id="dd/d98/namespaceBBP_1_1std_1a113ed1a5f747f8fa4d0d8b8aaadaea53" name="getDecimal" args="(uint32_t value, uint32_t position)" definition="BBP::uint8_t BBP::std::getDecimal">	typedef long long          int64_t;

#endif

	typedef unsigned char      uint8_t;

	typedef unsigned short     uint16_t;

	typedef unsigned int       uint32_t;

#ifndef USE_32_BITS

	typedef unsigned long long uint64_t;

#endif


</function><function index="364" id="dd/d98/namespaceBBP_1_1std_1ad340be18a81465c75a58f55b151fbd85" name="strcpy" args="(string *dst, conststring src)" definition="void BBP::std::strcpy">

		/* Calculate size of string */

		size_t __UNSAFE__(strlen)(string str);



		/* Calculate size of string at specified offset */
</function><function index="365" id="dd/d98/namespaceBBP_1_1std_1adce07ae43f3eec1d803d60483e879c46" name="operator&lt;=" args="(string &amp;dst, conststring src)" definition="void BBP::std::operator&lt;=" /><function index="366" id="dd/d98/namespaceBBP_1_1std_1ab265d2091a638c87704f5c324cda8560" name="strcpy" args="(string *dst, c_string src)" definition="void BBP::std::strcpy">		/* Write one whole string into a char buffer */

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;=(std::Stack&lt;std::string_element&gt; &amp;stack, std::conststring str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;=(std::Stack&lt;std::string_element&gt; &amp;stack, std::c_string str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;=(std::Stack&lt;std::string_element&gt; &amp;stack, std::string &amp;str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;=(std::Stack&lt;std::string_element&gt; &amp;stack, char c);
</function><function index="367" id="dd/d98/namespaceBBP_1_1std_1a8803dd235bf430e587c5fd54ee05e830" name="operator&lt;=" args="(string &amp;dst, c_string src)" definition="void BBP::std::operator&lt;=" /><function index="368" id="dd/d98/namespaceBBP_1_1std_1a64546fad320a0d37b91d60a9be9b57bc" name="strcpy" args="(c_string dst, conststring src)" definition="void BBP::std::strcpy">		/* Write one whole string into a char buffer (no null terminator) */

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;(std::Stack&lt;std::string_element&gt; &amp;stack, std::conststring str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;(std::Stack&lt;std::string_element&gt; &amp;stack, std::c_string str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;(std::Stack&lt;std::string_element&gt; &amp;stack, std::string &amp;str);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;(std::Stack&lt;std::string_element&gt; &amp;stack, int value);


</function><function index="369" id="dd/d98/namespaceBBP_1_1std_1a0732a2d69fc0a894ca5e9b017c6fe01e" name="strcmp" args="(string *sta, conststring stb)" definition="bool BBP::std::strcmp">		std::Stack&lt;std::string_element&gt; &amp;operator&gt;&gt;=(std::Stack&lt;std::string_element&gt; &amp;stack, std::c_string *str);

		std::Stack&lt;std::string_element&gt; &amp;operator&gt;&gt;=(std::Stack&lt;std::string_element&gt; &amp;stack, std::string *str);



		/* Read one whole string from a buffer */

		std::Stack&lt;std::string_element&gt; &amp;operator&gt;&gt;(std::Stack&lt;std::string_element&gt; &amp;lh, std::Stack&lt;std::string_element&gt; &amp;rh);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;(std::Stack&lt;std::string_element&gt; &amp;lh, std::Stack&lt;std::string_element&gt; &amp;rh);

		std::Stack&lt;std::string_element&gt; &amp;operator&gt;&gt;=(std::Stack&lt;std::string_element&gt; &amp;lh, std::Stack&lt;std::string_element&gt; &amp;rh);

		std::Stack&lt;std::string_element&gt; &amp;operator&lt;&lt;=(std::Stack&lt;std::string_element&gt; &amp;lh, std::Stack&lt;std::string_element&gt; &amp;rh);



		/* Read one whole string from a buffer (unsafe) */

		std::Stack&lt;std::string_element&gt; &amp;operator&gt;(std::Stack&lt;std::string_element&gt; &amp;stack, std::c_string *str);

		std::Stack&lt;std::string_element&gt; &amp;operator&gt;(std::Stack&lt;std::string_element&gt; &amp;stack, std::string *str);



		const std::conststring space = " ";

		const std::conststring endl = "\n";



	}

}





#endif
</function><function index="370" id="dd/d98/namespaceBBP_1_1std_1ab8543973d238f4dd31cb788c8d0aab92" name="strlen" args="(c_string str)" definition="BBP::std::size_t BBP::std::strlen">		template &lt;int N&gt;

		using static_string = STATIC_PAGE&lt;string_element, N&gt;;



		/* Usual c-string definition */

		typedef string_element *c_string;

		typedef ustring_element *uc_string;



		/* Constant string definition */

		typedef const string_element *conststring;

		typedef const ustring_element *uconststring;



		/* The absolute longest size of a string */

		const size_t max_string_length = 0xFFFF;



		/* The hashing type of a string */
</function><function index="371" id="dd/d98/namespaceBBP_1_1std_1a488ad6c683fa5f2c35e3a4cca65a2e3d" name="strlen" args="(string &amp;str)" definition="BBP::std::size_t BBP::std::strlen">

		/* Copy string literal into 'dst' */

		void strcpy(string *dst, conststring src);

		void operator&lt;=(string &amp;dst, conststring src);

		

		/* Copy conventional string into 'dst' */

		void strcpy(string *dst, c_string src);

		void operator&lt;=(string &amp;dst, c_string src);



		/* Copy conventional string into 'dst' */

		void strcpy(c_string dst, conststring src);
</function><function index="372" id="dd/d98/namespaceBBP_1_1std_1a40d1a207b7eef358325a478fdfeb3a0d" name="strlen" args="(string str, offset_t offset)" definition="BBP::std::size_t BBP::std::strlen">		/* Compare string to string literal */

		bool strcmp(string *sta, conststring stb);



		/* Compare string to conventional string */

		bool strcmp(string *sta, c_string stb);



		/* Calculate size of string literal */

		size_t strlen(conststring str);



		/* Calculate size of conventional string */

		size_t strlen(c_string str);
</function><function index="373" id="dd/d98/namespaceBBP_1_1std_1a53a0c211ad7056be924a561f9ebc8739" name="strhsh" args="(string &amp;str)" definition="BBP::std::hash_t BBP::std::strhsh" /><function index="374" id="dd/d98/namespaceBBP_1_1std_1a588ea5eca9ac62a43ce76db1c07f64d4" name="strhsh" args="(c_string str)" definition="BBP::std::hash_t BBP::std::strhsh" /><function index="375" id="dd/d98/namespaceBBP_1_1std_1a139c4376c77070774335b26226c5da10" name="operator&quot;&quot;_hash" args="(const char *str, long unsigned int hehe)" definition="constexpr std::hash_t BBP::std::operator&quot;&quot;_hash">		constexpr inline std::hash_t operator ""_hash(const char *str, long unsigned int hehe) 

		{

			// Hashing constants

			const int p = 31;

			const int m = 1e9 + 9;



			// Working variables

			std::hash_t hash = 0;

			uint32_t Power = 1;



			// Get the size of the string

			std::size_t length = hehe;



			// Actual hashing algorithm. Taken from: 

			for (std::index_t index = 0; index &lt; length; index++)

			{

				char c = str[index];

				hash = (hash + (c - 'a' + 1) * Power) % m;

				Power = (p * Power) % m;

			}



			return hash;

		}
</function><function index="376" id="dd/d98/namespaceBBP_1_1std_1a34a7eefbc87aa01762b83a86ff90fa2a" name="strhsh" args="(hash_t &amp;, word &amp;, string_element &amp;)" definition="void BBP::std::strhsh" /><function index="377" id="dd/d98/namespaceBBP_1_1std_1a70dd1e33acbfe3b2a80db1362ee0b7df" name="operator&lt;&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::conststring str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;=" /><function index="378" id="dd/d98/namespaceBBP_1_1std_1a3c5fbed5e42156a9aed1cca658ec074e" name="operator&lt;&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::c_string str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;=" /><function index="379" id="dd/d98/namespaceBBP_1_1std_1a6e84346269af92c46831291e07b00f82" name="operator&lt;&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::string &amp;str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;=" /><function index="380" id="dd/d98/namespaceBBP_1_1std_1a3da9ba4aa61f6cf9a7a1563cc309401f" name="operator&lt;&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, char c)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;=" /><function index="381" id="dd/d98/namespaceBBP_1_1std_1a807b5c4899443fad77ac3ad5a9f82ac9" name="operator&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, int value)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;=" /><function index="382" id="dd/d98/namespaceBBP_1_1std_1a27729307826cf7d30436c8280997ed0f" name="operator&lt;&lt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::conststring str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;" /><function index="383" id="dd/d98/namespaceBBP_1_1std_1a115e846384a5f60bc5f257877aa331b6" name="operator&lt;&lt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::c_string str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;" /><function index="384" id="dd/d98/namespaceBBP_1_1std_1a58d4164508e93f2175e3829a05dc018b" name="operator&lt;&lt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::string &amp;str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;" /><function index="385" id="dd/d98/namespaceBBP_1_1std_1ae660682d94d7d97bd418f86be996e4b1" name="operator&lt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, int value)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;" /><function index="386" id="dd/d98/namespaceBBP_1_1std_1af3ec20a9dd652424defa2f6fbaacfe41" name="operator&gt;&gt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::c_string *str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;&gt;=" /><function index="387" id="dd/d98/namespaceBBP_1_1std_1aa80fe0f1a63a1fe95e02ebeb154b97c7" name="operator&gt;&gt;=" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::string *str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;&gt;=" /><function index="388" id="dd/d98/namespaceBBP_1_1std_1acf94469ccd3758128fbc9b57ade0c04b" name="operator&gt;&gt;" args="(std::Stack&lt; std::string_element &gt; &amp;lh, std::Stack&lt; std::string_element &gt; &amp;rh)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;&gt;" /><function index="389" id="dd/d98/namespaceBBP_1_1std_1a747b39bfe83825422dc3c65e5e5ff618" name="operator&lt;&lt;" args="(std::Stack&lt; std::string_element &gt; &amp;lh, std::Stack&lt; std::string_element &gt; &amp;rh)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;" /><function index="390" id="dd/d98/namespaceBBP_1_1std_1aad25ce116c7c8f0b7f042e2c5b9f733b" name="operator&gt;&gt;=" args="(std::Stack&lt; std::string_element &gt; &amp;lh, std::Stack&lt; std::string_element &gt; &amp;rh)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;&gt;=" /><function index="391" id="dd/d98/namespaceBBP_1_1std_1a23b09468820f72265cb93369926d19e7" name="operator&lt;&lt;=" args="(std::Stack&lt; std::string_element &gt; &amp;lh, std::Stack&lt; std::string_element &gt; &amp;rh)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&lt;&lt;=" /><function index="392" id="dd/d98/namespaceBBP_1_1std_1a350236449e81981979f94acf450a2113" name="operator&gt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::c_string *str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;" /><function index="393" id="dd/d98/namespaceBBP_1_1std_1adb8fd9396711ddd3946b69b97489b2d6" name="operator&gt;" args="(std::Stack&lt; std::string_element &gt; &amp;stack, std::string *str)" definition="BBP::std::Stack&lt; BBP::std::string_element &gt; &amp; BBP::std::operator&gt;" /><function index="394" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a4231d3561bf9510a91b882bfefad4434" name="convertUCHARtoINT" args="(chan_t r, chan_t g, chan_t b, chan_t a)" definition="RGBA_t BBP::std::R2D::convertUCHARtoINT">		};



		struct window

		{

			PAGE&lt;RGBA_t&gt; backBuffer;
</function><function index="395" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aac72e826c4be633a25255aa72d7d4d92" name="convertINTtoUCHAR" args="(chan_t *r, chan_t *g, chan_t *b, RGBA_t rgb)" definition="void BBP::std::R2D::convertINTtoUCHAR">

			size_t width = 0;

			size_t height = 0;



			pos_t xPos = 0;

			pos_t yPos = 0;
</function><function index="396" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a824b0886efd3dfa13b6448b8b86c6a07" name="convertINTtoUCHAR" args="(chan_t *r, chan_t *g, chan_t *b, chan_t *a, RGBA_t rgba)" definition="void BBP::std::R2D::convertINTtoUCHAR">			pos_t zPos = 0;



			colour Stroke = colour();

			colour Fill = colour();

			colour Chroma = colour();



			bool doStroke = true;
</function><function index="397" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1abd452b23f01af75984864049dd13670b" name="newWindow" args="(window *, pos_t width, pos_t height, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::newWindow">			void Hrule(window *, pos_t x1, pos_t x2, pos_t y, RGBA_t rgb);

			void Vrule(window *, pos_t y1, pos_t y2, pos_t x, RGBA_t rgb);



			void Rect(window *, pos_t x, pos_t y, pos_t w, pos_t h);

			void Box(window *, pos_t x, pos_t y, pos_t w, pos_t h);

			void Frame(window *, pos_t x, pos_t y, pos_t w, pos_t h);



			void RectPixelMask(window *, pos_t x, pos_t y, mask_t mask);

			void RectPixelMask(window *, pos_t x, pos_t y, word size, mask_t mask);

			void RectPixelMaskAligned(window *, pos_t x, pos_t y, word size, mask_t mask);



			void RectPixelMask(window *, pos_t x, pos_t y, mask_t *maskv, word maskc);

			void RectPixelMask(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc);

			void RectPixelMaskAligned(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc);



			RGBA_t readPixel(window *, pos_t x, pos_t y);



			inline void setPixel(window *, pos_t x, pos_t y);

			inline void setPixel(window *, pos_t x, pos_t y, word size);

			inline void setPixelAligned(window *, pos_t x, pos_t y, word size);



			void PixelMask(window *, pos_t x, pos_t y, mask_t mask);

			void PixelMask(window *, pos_t x, pos_t y, word size, mask_t mask);

			void PixelMaskAligned(window *, pos_t x, pos_t y, word size, mask_t mask);



			void PixelMask(window *, pos_t x, pos_t y, mask_t *maskv, word maskc);

			void PixelMask(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc);

			void PixelMaskAligned(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc);
</function><function index="398" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1acbbf7a74f366ba7e08f6bf9bb11707be" name="newWindow" args="(window *, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::newWindow">			void PrintCharacterAt(window *, pos_t x, pos_t y, ustring_element ch);

			void PrintCharacterAt(window *, pos_t x, pos_t y, ustring_element ch, word size);



			void print(window *, ustring_element ch);

			void print(window *, ustring_element *str);

			void print(window *, conststring str);

			void print(window *, mem_t *str, word str_c);
</function><function index="399" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a19a4a225e19ac4264c3ba92046f9904c" name="background" args="(window *, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::background" /><function index="400" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a2643b9e013a1bc6c016bb960a1cca9c4" name="background" args="(window *, chan_t r, chan_t g, chan_t b, chan_t a)" definition="void BBP::std::R2D::background" /><function index="401" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a5bf3befdcd6e139d3f01319eafaa5182" name="background" args="(window *, RGBA_t rgb)" definition="void BBP::std::R2D::background" /><function index="402" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1af99098285fa0f0c5ff74c4bc7f027c03" name="background" args="(window *, RGBA_t rgb, chan_t a)" definition="void BBP::std::R2D::background" /><function index="403" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a950bda48471d587efcad3dff57541550" name="stroke" args="(window *, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::stroke">			chan_t strokeWeight = 5;



			PAGE&lt;mask_t&gt; typeFace;

			int fontCount;



			PAGE&lt;string_element&gt; charMapping;

			string_element fontMapping[256];
</function><function index="404" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aa6f49be4bd366a94554e88978bcbde17" name="stroke" args="(window *, chan_t r, chan_t g, chan_t b, chan_t a)" definition="void BBP::std::R2D::stroke">

			chan_t fontSize = 3;

			chan_t fontSpacing = 8;



			pos_t cursorPosX = 0;

			pos_t cursorPosY = 0;



			chan_t coloumn = 0;
</function><function index="405" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a0ec7d85b617fb5dbafb2827c174f7d85" name="stroke" args="(window *, RGBA_t rgb)" definition="void BBP::std::R2D::stroke">			chan_t line = 0;



			window()

			{

				width = 0;
</function><function index="406" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ab3600d30e0b5f513d18db465c999179b" name="stroke" args="(window *, RGBA_t rgb, chan_t a)" definition="void BBP::std::R2D::stroke">				height = 0;



				xPos = 0;

				yPos = 0;

				zPos = 0;

			}
</function><function index="407" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a02dc9d6f0c3b105012cd73160bb7e50e" name="strokeWeight" args="(window *, word weight)" definition="void BBP::std::R2D::strokeWeight">

			extern int initializeGraphics(window *, int width, int height);

			extern void destructGraphics();

		}
</function><function index="408" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a86b47f725f748320350d45c25e232bad" name="noStroke" args="(window *)" definition="void BBP::std::R2D::noStroke">		};



		namespace Driver

		{
</function><function index="409" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a985d2f37aa59f400c93963bafdc25e54" name="fill" args="(window *, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::fill">		namespace R2D

		{

			RGBA_t convertUCHARtoINT(chan_t r, chan_t g, chan_t b, chan_t a);

			void convertINTtoUCHAR(chan_t *r, chan_t *g, chan_t *b, RGBA_t rgb);

			void convertINTtoUCHAR(chan_t *r, chan_t *g, chan_t *b, chan_t *a, RGBA_t rgba);



			void newWindow(window *, pos_t width, pos_t height, chan_t r, chan_t g, chan_t b);

			void newWindow(window *, chan_t r, chan_t g, chan_t b);
</function><function index="410" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ad64af62ecd5b637ffee0390f9ac1c09f" name="fill" args="(window *, chan_t r, chan_t g, chan_t b, chan_t a)" definition="void BBP::std::R2D::fill">

			void background(window *, chan_t r, chan_t g, chan_t b);

			void background(window *, chan_t r, chan_t g, chan_t b, chan_t a);

			void background(window *, RGBA_t rgb);

			void background(window *, RGBA_t rgb, chan_t a);



			void stroke(window *, chan_t r, chan_t g, chan_t b);

			void stroke(window *, chan_t r, chan_t g, chan_t b, chan_t a);

			void stroke(window *, RGBA_t rgb);
</function><function index="411" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a4b123bdf7236d4ede422aa3090daf914" name="fill" args="(window *, RGBA_t rgb)" definition="void BBP::std::R2D::fill">			void stroke(window *, RGBA_t rgb, chan_t a);

			void strokeWeight(window *, word weight);

			void noStroke(window *);



			void fill(window *, chan_t r, chan_t g, chan_t b);

			void fill(window *, chan_t r, chan_t g, chan_t b, chan_t a);
</function><function index="412" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a460ff575be19227dc1efe7a800ad5b16" name="fill" args="(window *, RGBA_t rgb, chan_t a)" definition="void BBP::std::R2D::fill">			void fill(window *, RGBA_t rgb);

			void fill(window *, RGBA_t rgb, chan_t a);

			void noFill(window *);



			void Line(window *, int x1, int y1, int x2, int y2);

			void Hrule(window *, pos_t x1, pos_t x2, pos_t y);

			void Vrule(window *, pos_t y1, pos_t y2, pos_t x);
</function><function index="413" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a637020510b9c2870fbe68e29a6d34a11" name="noFill" args="(window *)" definition="void BBP::std::R2D::noFill">			void Line(window *, int x1, int y1, int x2, int y2, chan_t r, chan_t g, chan_t b);

			void Hrule(window *, pos_t x1, pos_t x2, pos_t y, chan_t r, chan_t g, chan_t b);

			void Vrule(window *, pos_t y1, pos_t y2, pos_t x, chan_t r, chan_t g, chan_t b);


</function><function index="414" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a9c63903bb92e27bf2c719641dda3ee98" name="Line" args="(window *, int x1, int y1, int x2, int y2)" definition="void BBP::std::R2D::Line" /><function index="415" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1acc6674c3e336f1e429b0bc23f9955ca6" name="Hrule" args="(window *, pos_t x1, pos_t x2, pos_t y)" definition="void BBP::std::R2D::Hrule" /><function index="416" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a3f3e793215cc7ab1073d7169dd042c9c" name="Vrule" args="(window *, pos_t y1, pos_t y2, pos_t x)" definition="void BBP::std::R2D::Vrule" /><function index="417" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a7781a618863a538d28ba8b6a824d19c4" name="Hrule" args="(window *, pos_t x1, pos_t x2, pos_t y, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::Hrule" /><function index="418" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ab511446f8db444431dbd58e715cbb0f7" name="Vrule" args="(window *, pos_t y1, pos_t y2, pos_t x, chan_t r, chan_t g, chan_t b)" definition="void BBP::std::R2D::Vrule" /><function index="419" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ad125f29de7379a9edef7f618dbf91936" name="Hrule" args="(window *, pos_t x1, pos_t x2, pos_t y, RGBA_t rgb)" definition="void BBP::std::R2D::Hrule" /><function index="420" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a528fd9eab653541da2b1e7b39a4caa62" name="Vrule" args="(window *, pos_t y1, pos_t y2, pos_t x, RGBA_t rgb)" definition="void BBP::std::R2D::Vrule" /><function index="421" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a6d561f750415d55352addcd1286ee41f" name="Rect" args="(window *, pos_t x, pos_t y, pos_t w, pos_t h)" definition="void BBP::std::R2D::Rect" /><function index="422" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1acea93c05ea4bbf9b38158ac0682a74cd" name="Box" args="(window *, pos_t x, pos_t y, pos_t w, pos_t h)" definition="void BBP::std::R2D::Box" /><function index="423" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a59fe3c5f2e87d457a935f884456549cd" name="Frame" args="(window *, pos_t x, pos_t y, pos_t w, pos_t h)" definition="void BBP::std::R2D::Frame" /><function index="424" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ab48857f9d44795eef84f06c8b10626ed" name="RectPixelMask" args="(window *, pos_t x, pos_t y, mask_t mask)" definition="void BBP::std::R2D::RectPixelMask" /><function index="425" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ae1d88714e45ace0dcf915ffbad2e550e" name="RectPixelMask" args="(window *, pos_t x, pos_t y, word size, mask_t mask)" definition="void BBP::std::R2D::RectPixelMask" /><function index="426" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a04471602a24e37f097d5223afa97a068" name="RectPixelMaskAligned" args="(window *, pos_t x, pos_t y, word size, mask_t mask)" definition="void BBP::std::R2D::RectPixelMaskAligned" /><function index="427" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a8d82b791dfb06d26ff05ec27e451bc23" name="RectPixelMask" args="(window *, pos_t x, pos_t y, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::RectPixelMask" /><function index="428" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a1737251aa761a987132194242bfd19b7" name="RectPixelMask" args="(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::RectPixelMask" /><function index="429" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a7fa5f557411a59c6f600b3407f96868c" name="RectPixelMaskAligned" args="(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::RectPixelMaskAligned" /><function index="430" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aaa5e3978968fc3b485e6425d0a0f6f41" name="readPixel" args="(window *, pos_t x, pos_t y)" definition="RGBA_t BBP::std::R2D::readPixel" /><function index="431" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1acc11e125c7028e2c4834c7577a853818" name="setPixel" args="(window *, pos_t x, pos_t y)" definition="void BBP::std::R2D::setPixel" /><function index="432" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a1ff2b5345c0f2577b34cc21b096abb33" name="setPixel" args="(window *, pos_t x, pos_t y, word size)" definition="void BBP::std::R2D::setPixel" /><function index="433" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1af810971cb418624f05a53e32e7aeee00" name="setPixelAligned" args="(window *, pos_t x, pos_t y, word size)" definition="void BBP::std::R2D::setPixelAligned" /><function index="434" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a1a6b1725d55164c1157ff766baceaed9" name="PixelMask" args="(window *, pos_t x, pos_t y, mask_t mask)" definition="void BBP::std::R2D::PixelMask" /><function index="435" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ab41ab6dcb4a81af7d3bd78e26283160b" name="PixelMask" args="(window *, pos_t x, pos_t y, word size, mask_t mask)" definition="void BBP::std::R2D::PixelMask" /><function index="436" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a1104662a1c8fcf0a0bc9cc9973f6e189" name="PixelMaskAligned" args="(window *, pos_t x, pos_t y, word size, mask_t mask)" definition="void BBP::std::R2D::PixelMaskAligned" /><function index="437" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a7770f2686230f89508e5b3b542a87cbd" name="PixelMask" args="(window *, pos_t x, pos_t y, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::PixelMask" /><function index="438" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a7d648c5e94e07105fa045257e3440239" name="PixelMask" args="(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::PixelMask" /><function index="439" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ac218dc81a8b49971c849d52244d745e0" name="PixelMaskAligned" args="(window *, pos_t x, pos_t y, word size, mask_t *maskv, word maskc)" definition="void BBP::std::R2D::PixelMaskAligned" /><function index="440" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aa40574bb9ba2fcd8a63d1a0438d78aa3" name="PrintCharacterAt" args="(window *, pos_t x, pos_t y, ustring_element ch)" definition="void BBP::std::R2D::PrintCharacterAt" /><function index="441" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1a212aad050ebf4b7a7883add3b6aee666" name="PrintCharacterAt" args="(window *, pos_t x, pos_t y, ustring_element ch, word size)" definition="void BBP::std::R2D::PrintCharacterAt" /><function index="442" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ada5f0bdbe4d4bd6f1a3780235a34225a" name="print" args="(window *, ustring_element ch)" definition="void BBP::std::R2D::print" /><function index="443" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aefed8c396629f69d9389151834573442" name="print" args="(window *, conststring str)" definition="void BBP::std::R2D::print" /><function index="444" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1ad2871cbf4bfaae6435058137d35c8119" name="setCursorPos" args="(window *, pos_t x, pos_t y)" definition="void BBP::std::R2D::setCursorPos" /><function index="445" id="dc/da1/namespaceBBP_1_1std_1_1R2D_1aec7ebe885d0c8a1b5bf5b98b4d08a4ef" name="GetFontFromFile" args="(window *, std::PATH &amp;)" definition="void BBP::std::R2D::GetFontFromFile">



			void GetFontFromFile(window *, std::PATH &amp;);

		}



		namespace R3D

		{

			// TODO: Implement

		}

	}

}



#endif</function><function index="446" id="de/dfe/namespaceBBP_1_1userspace_1a9122f01317e629b0ae11a837667f1224" name="setRegister" args="(register_t &amp;reg, std::word w)" definition="void BBP::userspace::setRegister">namespace BBP

{



	namespace userspace

	{



		enum registerSize : std::byte

		{

			eightBit = 1,

			sixteenBit = 2,

			thirtyTwoBit = 4,

			addressSize = 8

		};



		struct Thread;

		struct register_t

		{

			// The size of this register

			registerSize size;

			

			// Data where this register lives

			userspace::Thread *owner;

			std::index_t index;		// In words

			std::offset_t offset;	// In bytes. Total 'index' in bytes is: index * 4 + offset



			register_t() = delete;

			register_t(register_t &amp;) = delete;

			register_t(register_t &amp;&amp;) = delete;



			register_t(Thread &amp;thread, std::index_t index_, std::offset_t offset_, registerSize size_);



		};



		void setRegister(register_t &amp;reg, std::word w);

		std::word readRegister(register_t &amp;reg);



	}



}



#endif</function><function index="447" id="de/dfe/namespaceBBP_1_1userspace_1a484d19b0d23141290394e25753c95bfb" name="readRegister" args="(register_t &amp;reg)" definition="BBP::std::word BBP::userspace::readRegister" /><function index="448" id="da/d4c/Actions_8cpp_1a7162ffd5779e9abcd443c8531128c4d2" name="PRAGMA" args="(include)" definition="PRAGMA">PRAGMA(include)

{

	// Move back one position

	context-&gt;atPosition--;



	// Move to the start of the next word, keeping in mind the newline.

	context-&gt;moveToStartOfNextWord(true);



	// Recalculate position

	context-&gt;calculateDebugPosition();



	// Since file names can appear between '&lt;&gt;' or '""' (but not both), create the following handle

	std::Lexer::lex_keywordhandle handles[] = { OPENANGLEBRACKET_HANDLE, CLOSEANGLEBRACKET_HANDLE, DOUBLEQUOTES_HANDLE, DOUBLEQUOTES_HANDLE };



	// Read delimiter information, and update debug information.

	std::errno_t error = processor.ExpectDelimiters(context, 4, handles, true, 1, 1, BACKSLASH_HANDLE, context-&gt;keywordStack.atElement + 2);

	context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index;



	// Switch based on error code

	switch (error)

	{

	case EFAULT: // Somehow a nullpointer got here. Abort immediately.

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "AMemory instability detected.";

	case EDOM: // Somehow, an odd number ended up as argc. Either programmer fault, or stack error. Abort immediately.

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "APossible stack smashing detected.";

	case EEOF: // Found End Of File before anything was found.

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "EExpected filename before end of file.";

	case ENOMSG:// Found End of Line before anything was found.

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "EExpected filename before end of line.";

	case ELINEEND: // End of Line found before second delimiter

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "EExpected closing delimiter before end of line.";

	case ENOANO: // Attempted to close delimiter before starting it.

		context-&gt;debugInformation.highlightmsg = "NHere";

		context-&gt;debugInformation.highlight = index;

		if (processor.handle == CLOSEANGLEBRACKET_HANDLE)

			return "eExpected '&lt;' before '&gt;'.";

		return "EExpected '\"' before filename.";

	case EILSEQ: // Mismatched delimiters

		context-&gt;debugInformation.highlightmsg = "NHere";

		context-&gt;debugInformation.highlight = index;

		if (processor.handle == CLOSEANGLEBRACKET_HANDLE)

			return "eExpected '&gt;' after '&lt;'.";

		return "EExpected '\"' after '\"'.";

	case EUNFOCS: // Somehow unfocused?

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "AEncountered bug 0x01.";

	case EOVERFLOW: // More than one delimiter, can only really happen with &lt;

		context-&gt;debugInformation.highlightmsg = "NHere";

		context-&gt;debugInformation.highlight = index;

		return "EUnexpected '&lt;' after '&lt;'.";

	}



	//context-&gt;resetInfo(context-&gt;debugInformation);

	context-&gt;debugInformation.highlight = processor.lastOpener;

	context-&gt;debugInformation.highlightLength = processor.firstCloser - processor.lastOpener;

	context-&gt;debugInformation.highlightmsg = "NHere";

	return processor.includeFile(context, index);

}
</function><function index="449" id="da/d4c/Actions_8cpp_1a23ac3ab4b2c451d966c59b2c319094c3" name="PRAGMA" args="(handler)" definition="PRAGMA">PRAGMA(handler)

{

	return nullptr;

}
</function><function index="450" id="da/d4c/Actions_8cpp_1af0f7eaf1d9c626fd2b7adcfb0653ec9a" name="PRAGMA" args="(define)" definition="PRAGMA">PRAGMA(define)

{

	// Hash next word.

	std::hash_t macroHash = 0;

	bool couldHash = context-&gt;moveToAndHashNextWord(macroHash, '\n');



	// Then move up one more.

	context-&gt;atPosition++;



	// If the word could not be hashed, return an error.

	if (!couldHash)

	{

		// Reset debug info

		context-&gt;resetInfo(context-&gt;debugInformation);



		// Set other pertinent info

		context-&gt;debugInformation.errName = "-Wempty-define";

		return "WEmpty #define directive ignored.";

	}



	// Otherwise print

	if (processor.beVerbose)

		std::printf("Defining 0x%08x\n", macroHash);



	// Look for empty definition in define pages.

	std::index_t reserved = 0;

	for (std::index_t idx = 0; idx &lt; 256; idx++)

	{

		// If we have not found a spot yet, look for an empty slot.

		if (defines[idx] == 0 &amp;&amp; reserved == 0)

			reserved = idx;



		// We can continue checking for duplicates

		if (defines[idx] == macroHash)

		{

			if (processor.beVerbose)

				std::printf("Found duplicate hash at index %u.\n", idx);



			// Reset debug info

			context-&gt;resetInfo(context-&gt;debugInformation);



			// Set other pertinent info

			context-&gt;debugInformation.errName = "-Wduplicate-define";

			context-&gt;debugInformation.highlight = index;

			context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index + 1;

			context-&gt;debugInformation.highlightmsg = "N#define found here";

			return "WDuplicate #define directive ignored.";

		}

	}



	// If we have not reserved anything yet, return error.

	if (reserved == 0)

	{

		// Reset debug info

		context-&gt;resetInfo(context-&gt;debugInformation);



		// Set other pertinent info

		return "E#define directive failed: page is full.";

	}



	// Just write the hash in, and maybe be verbose

	defines[reserved] = macroHash;



	if (processor.beVerbose)

		std::printf("Stored hash 0x%08x in %u.\n", macroHash, reserved);



	return nullptr;

}
</function><function index="451" id="da/d4c/Actions_8cpp_1a4e69a0634ac73ddfab6cf449027b22b6" name="PRAGMA" args="(undef)" definition="PRAGMA">PRAGMA(undef)

{

	// Hash next word.

	std::hash_t macroHash = 0;

	bool couldHash = context-&gt;moveToAndHashNextWord(macroHash, '\n');



	// If the word could not be hashed, return an error.

	if (!couldHash)

	{

		// Reset debug info

		context-&gt;resetInfo(context-&gt;debugInformation);



		// Set other pertinent info

		context-&gt;debugInformation.errName = "-Wempty-undefine";

		return "WEmpty #undefine directive ignored.";

	}



	// Otherwise print

	if (processor.beVerbose)

		std::printf("Undefining 0x%08x\n", macroHash);



	// Look for that definition on the page

	for (std::index_t idx = 0; idx &lt; 256; idx++)

	{

		// We don't care about anything that isn't our hash

		if (defines[idx] != macroHash)

			continue;



		// Entry found, now delete it and be verbose

		if (processor.beVerbose)

			std::printf("Removed hash 0x%08x from %u.\n", macroHash, idx);



		defines[idx] = 0;

		return nullptr;

	}



	// Macro does not exist

	context-&gt;resetInfo(context-&gt;debugInformation);

	context-&gt;debugInformation.errName = "-Wundef";

	context-&gt;debugInformation.highlight = index;

	context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index + 1;

	context-&gt;debugInformation.highlightmsg = "N#undef found here";

	return "W#undef directive failed: macro does not exist.";

}
</function><function index="452" id="da/d4c/Actions_8cpp_1a87429a8ffc0429461dbe86373ea3e993" name="PRAGMA" args="(ifndef)" definition="PRAGMA">PRAGMA(ifndef)

{

	// Hash next word.

	std::hash_t macroHash = 0;

	bool couldHash = context-&gt;moveToAndHashNextWord(macroHash, '\n');



	// Then move up one more.

	context-&gt;atPosition++;



	// If the word could not be hashed, return an error.

	if (!couldHash)

	{

		// Reset debug info

		context-&gt;resetInfo(context-&gt;debugInformation);



		// Set other pertinent info

		context-&gt;debugInformation.errName = "-Wempty-ifndef";

		return "WEmpty #ifndef directive ignored.";

	}







	// Look for that definition on the page

	for (std::index_t idx = 0; idx &lt; 256; idx++)

	{

		// We don't care about anything that isn't our hash

		if (defines[idx] != macroHash)

			continue;



		// Entry found, which means that ifndef turns off.

		context-&gt;commentDepth = 4;

		alreadyElsed &lt;&lt; false;

		shouldEmit &lt;&lt; false;

		if (processor.beVerbose)

			std::printf("Processing #ifndef, hash 0x%08x. Nesting at %u.\n#ifndef: \e[0;31mStop\e[0;37m.\n\n", macroHash, shouldEmit.atElement);

		return nullptr;

	}



	// Macro does not exist, so ifndef stays on, so do nothing

	alreadyElsed &lt;&lt; false;

	shouldEmit &lt;&lt; true;

	if (processor.beVerbose)

		std::printf("Processing #ifndef, hash 0x%08x. Nesting at %u.\n#ifndef: \e[0;32mGo\e[0;37m.\n\n", macroHash, shouldEmit.atElement);

	return nullptr;

}
</function><function index="453" id="da/d4c/Actions_8cpp_1a04c1d6c5cb0fa901e54addd4cbac5e6b" name="PRAGMA" args="(ifdef)" definition="PRAGMA">PRAGMA(ifdef)

{

	// Hash next word.

	std::hash_t macroHash = 0;

	bool couldHash = context-&gt;moveToAndHashNextWord(macroHash, '\n');



	// If the word could not be hashed, return an error.

	if (!couldHash)

	{

		// Reset debug info

		context-&gt;resetInfo(context-&gt;debugInformation);



		// Set other pertinent info

		context-&gt;debugInformation.errName = "-Wempty-ifdef";

		return "WEmpty #ifdef directive ignored.";

	}



	// Look for that definition on the page

	for (std::index_t idx = 0; idx &lt; 256; idx++)

	{

		// We don't care about anything that isn't our hash

		if (defines[idx] != macroHash)

			continue;



		// Entry found, which means that ifdef turns on.

		alreadyElsed &lt;&lt; true;

		shouldEmit &lt;&lt; false;

		return nullptr;

	}



	// Macro does not exist, so ifdef goes off.

	context-&gt;commentDepth = 4;

	alreadyElsed &lt;&lt; false;

	shouldEmit &lt;&lt; false;

	return nullptr;

}
</function><function index="454" id="da/d4c/Actions_8cpp_1abd3fa73e625bbb2496ab42983d6cdcd0" name="PRAGMA" args="(endif)" definition="PRAGMA">PRAGMA(endif)

{

	// If endif is found in isolation, emit warning

	if (shouldEmit.atElement == 0 || alreadyElsed.atElement == 0)

	{

		context-&gt;resetInfo(context-&gt;debugInformation);

		context-&gt;debugInformation.errName = "-Wstray-endif";

		context-&gt;debugInformation.highlight = index;

		context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index + 1;

		context-&gt;debugInformation.highlightmsg = "N#endif found here";

		return "WConsider removing stray #endif.";

	}



	{

		// A place where variables go to die.

		bool thebin;



		//Bye-Bye!

		shouldEmit &gt;&gt; thebin;

		alreadyElsed &gt;&gt; thebin;

	}



	// If there is nothing in the stack, just go back to normal.

	if (shouldEmit.atElement == 0 || alreadyElsed.atElement == 0)

	{

		context-&gt;commentDepth = 0;

		if (processor.beVerbose)

			std::printf("#endif resulted in comment depth %u (nesting at %u).\n", context-&gt;commentDepth, shouldEmit.atElement);

		return nullptr;

	}



	// Restore last settings.

	bool shouldContinue = shouldEmit[shouldEmit.atElement - 1];

	context-&gt;commentDepth = shouldContinue ? 0 : 4;



	if (processor.beVerbose)

	{

		std::printf("#endif resulted in comment depth %u (nesting at %u).\n#endif: Restored ", context-&gt;commentDepth, shouldEmit.atElement);

		if (shouldContinue)

			std::printf("\e[0;32mGo\e[0;37m.\n\n");

		else

			std::printf("\e[0;31mStop\e[0;37m.\n\n");

	}





	return nullptr;

}
</function><function index="455" id="da/d4c/Actions_8cpp_1ab6ca34aa05fe7d1e2cf27f16dd482e3f" name="PRAGMA" args="(else)" definition="PRAGMA">PRAGMA(else)

{

	// If else is found in isolation, emit warning

	if (shouldEmit.atElement == 0 || alreadyElsed.atElement == 0)

	{

		context-&gt;resetInfo(context-&gt;debugInformation);

		context-&gt;debugInformation.errName = "-Wstray-else";

		context-&gt;debugInformation.highlight = index;

		context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index + 1;

		context-&gt;debugInformation.highlightmsg = "N#else found here";

		return "WConsider removing stray #else.";

	}



	if (alreadyElsed[alreadyElsed.atElement - 1])

	{

		// If already elsed, emit error.

		context-&gt;debugInformation.highlight = index;

		context-&gt;debugInformation.highlightLength = context-&gt;atPosition - index + 1;

		context-&gt;debugInformation.highlightmsg = "NHere";

		return "eMultiple #else directives used, only one is allowed.";

	}



	// Now flip it

	alreadyElsed[alreadyElsed.atElement - 1] = true;

	shouldEmit[shouldEmit.atElement - 1] = !shouldEmit[shouldEmit.atElement - 1];

	context-&gt;commentDepth = shouldEmit[shouldEmit.atElement - 1] ? 0 : 4;



	return nullptr;

}
</function><function index="456" id="da/d4c/Actions_8cpp_1a34708458eef38ed83142395d472a5f33" name="PRAGMA" args="(atomic)" definition="PRAGMA">PRAGMA(atomic)

{

	return nullptr;

}
</function><function index="457" id="da/d4c/Actions_8cpp_1a24dd8cf346f3e5d6ef47ca0165687a75" name="PRAGMA" args="(handover)" definition="PRAGMA">PRAGMA(handover)

{

	return nullptr;

}
</function><function index="458" id="da/d4c/Actions_8cpp_1ac6a6d76be04571b63be6322b67cfff12" name="PRAGMA" args="(continue)" definition="PRAGMA">PRAGMA(continue)

{

	return nullptr;

}
</function><function index="459" id="da/d4c/Actions_8cpp_1a925a3bed31042f7172cb6022fc1a8c40" name="ACTION" args="(static)" definition="ACTION">ACTION(static)

{

	return processor.markStatic();

}
</function><function index="460" id="da/d4c/Actions_8cpp_1a88e73db2f76153e6ca72bc20b9e52196" name="ACTION" args="(const)" definition="ACTION">ACTION(const)

{

	return processor.markConst();

}
</function><function index="461" id="da/d4c/Actions_8cpp_1a5b3dadded2420ce488af26d3addd0055" name="ACTION" args="(virtual)" definition="ACTION">ACTION(virtual)

{

	return processor.markVirtual();

}
</function><function index="462" id="da/d4c/Actions_8cpp_1aaef82d23a0f91dbcbb302298c90f748f" name="ACTION" args="(extern)" definition="ACTION">ACTION(extern)

{

	return processor.markExtern();

}
</function><function index="463" id="da/d4c/Actions_8cpp_1ae60c55abbf6dca8b97d74a46ef2f6c6f" name="ACTION" args="(procedure)" definition="ACTION">ACTION(procedure)

{

	// Check appropriate flags

	if (processor.lineIsDefiningInstruction || processor.lineIsDefiningSymbolDefinition)

		return "E'procedure' is a reserved keyword."; // If any of these flags are true, return error.



	// Set appropriate flags

	processor.lineIsDefiningProcedure = true;



	// Set index to here

	processor.setProcedureAddress();



	return nullptr;

}
</function><function index="464" id="da/d4c/Actions_8cpp_1aaf5c64904ca4c69af226c399d7c129ea" name="ACTION" args="(end)" definition="ACTION">ACTION(end)

{

	// Check if inside a procedure

	if (processor.procedureHash == 0)

		return "EInvalid 'end'; Must be matched with 'procedure'.";



	// Save end

	processor.endedAt = processor.application-&gt;builder._text().stack.atElement;



	// Push function

	std::conststring error = processor.emitProcedure();



	// Now reset procedure flags

	processor.procedureName.static_data[0] = 0;

	processor.procedureHash = 0;

	processor.startedAt = 0;

	processor.endedAt = 0;

	processor.procedureArgumentCount = 0;

	processor.doneDeclaringProcedure = false;

	processor.externProcedure = false;



	// Check for any subscribers.

	if (processor.routineStarts.atElement)

	{

		// Reset them

		processor.routineStarts.atElement = 0;



		// Return error

		return "EUnterminated ':' tokens before end of procedure.";

	}



	// Then return error

	return error;

}
</function><function index="465" id="da/d4c/Actions_8cpp_1aeeb9a7b9f06f6478af9493ae728e6a2d" name="ACTION" args="(endroutine)" definition="ACTION">ACTION(endroutine)

{

	// If no subscribers, emit warning

	if (processor.routineStarts.atElement == 0)

	{

		context-&gt;resetInfo(context-&gt;debugInformation);

		context-&gt;debugInformation.errName = "-Wignored-double-at";

		return "WIgnored stray '@@' because no ':' tokens precedes it.";

	}



	// Get current index in .text

	std::index_t currentIndex = processor.application-&gt;builder.sections[processor.application-&gt;builder.text].stack.atElement;



	// Loop over subscribers

	for (std::index_t index = 0; index &lt; std::read(&amp;processor.routineSubscriberCount, processor.routineStarts.atElement); index++)

	{

		// Get target offset

		std::offset_t target = processor.subscribers[index];



		// Write into section

		processor.application-&gt;builder.sections[processor.application-&gt;builder.text].stack[target] = (currentIndex &gt;&gt; 24) &amp; 0xFF;

		processor.application-&gt;builder.sections[processor.application-&gt;builder.text].stack[target+1] = (currentIndex &gt;&gt; 16) &amp; 0xFF;

		processor.application-&gt;builder.sections[processor.application-&gt;builder.text].stack[target+2] = (currentIndex &gt;&gt; 8) &amp; 0xFF;

		processor.application-&gt;builder.sections[processor.application-&gt;builder.text].stack[target+3] = (currentIndex &gt;&gt; 0) &amp; 0xFF;



	}



	// Now reset

	std::index_t zero = 0;

	std::write(&amp;processor.routineSubscriberCount, zero, processor.routineStarts.atElement);

	processor.routineStarts--;



	return nullptr;

}
</function><function index="466" id="da/d4c/Actions_8cpp_1af64343f793bbcc079e2d0d6112fef21a" name="TOKEN" args="(newline)" definition="TOKEN">TOKEN(newline)

{



	// Check if procedure is being defined, and is also marked extern. Because if so, emit empty function

	if (processor.lineIsDefiningProcedure &amp;&amp; processor.externProcedure)

	{

		// Emit procedure

		std::conststring error = processor.emitProcedure();



		// Now reset procedure flags

		processor.procedureName.static_data[0] = 0;

		processor.procedureHash = 0;

		processor.startedAt = 0;

		processor.endedAt = 0;

		processor.procedureArgumentCount = 0;

		processor.doneDeclaringProcedure = false;

		processor.externProcedure = false;



		// Also reset symbol

		processor.resetSymbol();



		// Just for logging

		return error;

	}



	// Reset this flag

	processor.lineIsDefiningProcedure = false;



	// If inside a comment, exit out and continue as normals

	if (context-&gt;commentDepth == 1)

	{

		context-&gt;commentDepth = 0;

		return nullptr;

	}



	// If this line was for a symbol definition, reset it here.

	// Also, if symbol is marked extern and this point is reached, also run it. Because this is definately not a procedure then.

	if (processor.lineIsDefiningSymbolDefinition || (processor.symbol.subtype &amp; SYMBOL_TYPE::SYMTMOD_EXTERN))

	{

		// Also reset extern procedure flag

		processor.externProcedure = false;



		processor.lineIsDefiningSymbolDefinition = false;

		switch (processor.buildSymbol())

		{

		case 0:

			return nullptr;

		case ENOBUFS:

			return "EUnable to register quasi symbol: quasi symbol limit reached.";

		case EADDRINUSE:

			return "EIdentifier already used.";

		case EBADR:

			return "ECannot assign symbol to procedure marked extern.";

		case 2:

			return "NOverriding extern symbol.";

		default:

			return "ECould not export symbol.";

		}

	}



	// If this line was for a instruction definition, reset it here.

	if (processor.lineIsDefiningInstruction)

	{

		// Emit instruction

		processor.emitInstruction();



		// We want to clear remains

		processor.resetInstruction();

		

		// Stop defining instructions

		processor.lineIsDefiningInstruction = false;

		return nullptr;

	}



	return nullptr;

}
</function><function index="467" id="da/d4c/Actions_8cpp_1aba6fa060ec6d75159f2206c0a4696253" name="TOKEN" args="(semicolon)" definition="TOKEN">TOKEN(semicolon)

{

	// Set comment depth to 1

	context-&gt;commentDepth = 1;

	return nullptr;

}
</function><function index="468" id="da/d4c/Actions_8cpp_1a065ffad5e14333f8c422d64da0c31021" name="TOKEN" args="(openDelimiter)" definition="TOKEN">TOKEN(openDelimiter)

{



	// Not interested if this keyword is not '('.

	if (handle != OPENBRACKET_HANDLE)

		return nullptr;





	// Not doing anything with procedures, do this

	if (!processor.lineIsDefiningProcedure)

	{

		// Well, we might as well flag quasi symbol

		processor.lineIsDefiningSymbolDefinition = true;



		// Start of the name is here

		processor.symbol.start = context-&gt;atPosition;



		// When in isolation, this means symbol definition. Get a hash, and move on.

		std::hash_t hash = 0;

		bool couldHash = context-&gt;moveToAndHashThisWord(hash, ')');



		// End of the name is here

		processor.symbol.end = context-&gt;atPosition;



		// If the hasher could not hash, return error.

		if (!couldHash)

			return "EInvalid symbol identifier.";



		// If the hasher reads 0, it means empty object.

		if (hash == 0 || hash == 0x1194d79c) // Magic number UwU

			return "ESymbol identifier cannot be empty.";



		// Move up and recalculate position

		context-&gt;atPosition++;

		context-&gt;calculateDebugPosition();



		return processor.setHash(hash);

	}



	// This must be the procedure identifier if this is the first time this is found

	if (std::read(&amp;processor.procedureName, 0) == 0)

	{

		// Get procedure hash

		std::word start = context-&gt;atPosition;



		// Hash procedure identifier

		std::hash_t hash = 0;

		bool couldHash = context-&gt;moveToAndHashThisWord(hash, ')');



		// End of the name is here

		std::word end = context-&gt;atPosition;



		// If hashing failed, return error

		if (!couldHash)

			return "Einvalid procedure Identifier.";



		// Otherwise, if hash is empty, return error

		if (hash == 0 || hash == 0x1194d79c) // OMG, stop it with the magic numbers daddy ~~

			return "EProcedure identifier cannot be empty.";



		// Move up one and calculate position again

		context-&gt;atPosition++;

		context-&gt;calculateDebugPosition();



		// Set procedure names

		processor.setProcedureIdentifier(start, end, hash);



		// Return success

		return nullptr;

	}

	else if (!processor.doneDeclaringProcedure)

	{

		// This must be the second argument, I.E., the size.



		// Then read the character, and do something based on it.

		std::string_element c = std::read(&amp;context-&gt;data, context-&gt;atPosition);



		// Check if within '0' and '8' (48 and 56)

		if (c &gt;= '0' &amp;&amp; c &lt;= '8')

			processor.setProcedureArgCount(c - '0');

		else if (c == ')')

			return "EExpected a numerical constant between '0' and '8' (inclusive) between '()'.";

		else

			return "EInvalid procedure argument count.";



		// Now check for ')' immediately after

		context-&gt;atPosition++;

		context-&gt;calculateDebugPosition();



		// Then read the character, and do something based on it.

		c = std::read(&amp;context-&gt;data, context-&gt;atPosition);



		if (c == ')')

			return nullptr;

		return "EExpected ')' immediately after numerical constant.";

	}

	else

	{

		return "EUnexpected argument supplied during procedure declaration.";

	}





	return nullptr;

}
</function><function index="469" id="da/d4c/Actions_8cpp_1acdbb080bb9cf178f71dbbc53cd474edc" name="TOKEN" args="(closeDelimiter)" definition="TOKEN">TOKEN(closeDelimiter)

{

	return nullptr;

}
</function><function index="470" id="da/d4c/Actions_8cpp_1a615cb918a3ba51089bb7b47cd8f44e83" name="TOKEN" args="(comma)" definition="TOKEN">TOKEN(comma)

{

	return nullptr;

}
</function><function index="471" id="da/d4c/Actions_8cpp_1a6382a2f66227b6f590cdecf55ffc0143" name="TOKEN" args="(caret)" definition="TOKEN">TOKEN(caret)

{

	// Check if any routines are available

	if (processor.routineStarts.atElement == 0)

	{

		// Reset info and throw error

		context-&gt;resetInfo(context-&gt;debugInformation);

		return "ECannot find address of routine since '^' is not within routine.";

	}



	// Set argument

	processor.numericalArgument({ processor.routineStarts[processor.routineStarts.atElement - 1] }, false);



	// If instruction is part of a jmp, jmpr, or jmpc set, flag suffix absolute.

	if (processor.instruction.header.opcode == userspace::JMP || processor.instruction.header.opcode == userspace::JMPZ || processor.instruction.header.opcode == userspace::JMPC)

		processor.instruction.header.suffix |= userspace::absoluteJmp;

	return nullptr;

}
</function><function index="472" id="da/d4c/Actions_8cpp_1aeca42bdac78d4cbf8465c3fc481f6546" name="TOKEN" args="(doubleQuote)" definition="TOKEN">TOKEN(doubleQuote)

{

	



	// If inside a string, exit out of the string

	if (context-&gt;literalDepth)

	{

		// Exit the string

		context-&gt;literalDepth = 0;



		// Check if symbol is extern

		if (processor.symbol.subtype &amp; SYMBOL_TYPE::SYMTMOD_EXTERN)

			return "ECannot add data to extern symbol";



		// If also defining symbol, add numericals.

		if (processor.lineIsDefiningSymbolDefinition)

		{

			for (std::index_t i = stringStart; i &lt; context-&gt;atPosition - 1; i++)

				processor.addNumerical(std::Lexer::numerical_t{ (std::word)context-&gt;data.data[i] }, false);

		}



		return nullptr;

	}



	context-&gt;literalDepth = context-&gt;keywordStack[handle].considerLiteralDepth;

	stringStart = context-&gt;atPosition;

	return nullptr;

}
</function><function index="473" id="da/d4c/Actions_8cpp_1a285fb58ee6964ad44f2388cab0b47890" name="TOKEN" args="(singleQuote)" definition="TOKEN">TOKEN(singleQuote)

{

	return nullptr;

}
</function><function index="474" id="da/d4c/Actions_8cpp_1a5d32958887f12c11c1f3318106610e07" name="TOKEN" args="(colon)" definition="TOKEN">TOKEN(colon)

{

	// If not defining a instruction, return error

	if (!processor.lineIsDefiningInstruction)

		return "E':' Can only be used when constructing an instruction.";



	// Get offset

	std::offset_t subscriber = processor.calculateAbsoluteArgumentOffset();



	// Check if instruction is routine. If so, Add routine start. Also flag absolute (Since this measures distance in bytes, not instructions)

	if (processor.instruction.header.opcode == userspace::CTRL &amp;&amp; processor.instruction.header.suffix == userspace::routine)

	{

		// Add routine start

		processor.routineStarts &lt;&lt; subscriber;



		// Flag absolute

		processor.instruction.header.suffix |= userspace::absolute;

	}



	// Check if allowed to add subscribers

	if (processor.subscribers.atElement &gt;= processor.subscribers.max_elements)

		return "EReached the limit of consecutive ':' tokens allowed.";



	// Add subscriber to subscribers stack

	processor.subscribers &lt;&lt; subscriber;



	// Increase subscriber count

	std::read(&amp;processor.routineSubscriberCount, processor.routineStarts.atElement)++;



	// Set argument

	processor.numericalArgument({'EMMA'}, false);

	return nullptr;

}
</function><function index="475" id="da/d4c/Actions_8cpp_1ab22a758e703abfd59c39b0b28452be89" name="TOKEN" args="(backslash)" definition="TOKEN">TOKEN(backslash)

{

	return nullptr;

}
</function><function index="476" id="da/d4c/Actions_8cpp_1adb74b6da125938fb92556958e9fac413" name="TOKEN" args="(size)" definition="TOKEN">TOKEN(size)

{

	switch (handle)

	{

	case DN_HANDLE:

		return processor.setSize(4);

	case DB_HANDLE:

		return processor.setSize(8);

	case DH_HANDLE:

		return processor.setSize(16);

	case DI_HANDLE:

		return processor.setSize(20);

	case DA_HANDLE:

		return processor.setSize(24);

	case DW_HANDLE:

		return processor.setSize(32);

	}



	// Will select default

	return processor.setSize(1);

}
</function><function index="477" id="da/d4c/Actions_8cpp_1a375dcb21abe49b7c11b6b2a75777003d" name="INSTRUCTION" args="(nil)" definition="INSTRUCTION">INSTRUCTION(nil)

{

	processor.setInstruction(userspace::NIL, 0, 0, 0);



	return nullptr;

}
</function><function index="478" id="da/d4c/Actions_8cpp_1a0f71738cc0185ebbeb6cbc3655ebeb25" name="INSTRUCTION" args="(stack)" definition="INSTRUCTION">INSTRUCTION(stack)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case PUSH_HANDLE:

		suffix = userspace::push;

		break;

	case POP_HANDLE:

		suffix = userspace::pop;

		break;

	case POPA_HANDLE:

		suffix = userspace::pop | userspace::argument;

		break;

	}



	processor.setInstruction(userspace::STACK, suffix, 0, 1);

	if (handle == PUSH_HANDLE)

		processor.expectAny(0);

	else

		processor.expectAddress(0);



	return nullptr;

}
</function><function index="479" id="da/d4c/Actions_8cpp_1aa320f5ec6b2b09a5cfaf64388369b6f9" name="INSTRUCTION" args="(ctrl)" definition="INSTRUCTION">INSTRUCTION(ctrl)

{

	std::byte suffix = 0;

	std::byte argCount = 0;



	switch (handle)

	{

	case RET_HANDLE:

		suffix = userspace::ret;

		argCount = 1;

		processor.surpressArgCountWarning(0);

		processor.setInstruction(userspace::CTRL, suffix, 0, argCount);

		break;



	case CALL_HANDLE:

		suffix = userspace::call;

		argCount = 8;

		processor.surpressArgCountWarning();

		processor.surpress[0] = false;

		processor.setInstruction(userspace::CTRL, suffix, 0, argCount);

		processor.expectAddress(0);

		for (std::byte n = 1; n &lt; 8; n++)

			processor.expectAny(n);

		break;



	case CALLP_HANDLE:

		suffix = userspace::callp;

		argCount = 8;

		processor.surpressArgCountWarning();

		processor.surpress[0] = false;

		processor.setInstruction(userspace::CTRL, suffix, 0, argCount);

		processor.expectAddress(0);

		for (std::byte n = 1; n &lt; 8; n++)

			processor.expectAny(n);

		break;



	case SYSCALL_HANDLE:

		suffix = userspace::syscall;

		argCount = 8;

		processor.surpressArgCountWarning();

		processor.surpress[0] = false;

		processor.setInstruction(userspace::CTRL, suffix, 0, argCount);

		processor.expectLiteral(0);

		for (std::byte n = 1; n &lt; 8; n++)

			processor.expectAny(n);

		break;



	case ROUTINE_HANDLE:

		suffix = userspace::routine;

		argCount = 1;

		processor.setInstruction(userspace::CTRL, suffix, 0, argCount);

		processor.expectLiteral(0);

		break;

	}



	return nullptr;

}
</function><function index="480" id="da/d4c/Actions_8cpp_1a84d68b38a050649c2bc727eac5109aec" name="INSTRUCTION" args="(mem)" definition="INSTRUCTION">INSTRUCTION(mem)

{

	

	std::byte firsttype = 0;

	std::byte secondtype = 0;



	// Decode first type

	switch (handle)

	{

	case MOVB_HANDLE:

	case MOVBH_HANDLE:

	case MOVBW_HANDLE:

	case MOVBA_HANDLE:

		firsttype = userspace::fbyte;

		break;



	case MOVH_HANDLE:

	case MOVHB_HANDLE:

	case MOVHW_HANDLE:

	case MOVHA_HANDLE:

		firsttype = userspace::fhalfword;

		break;



	case MOVW_HANDLE:

	case MOVWB_HANDLE:

	case MOVWH_HANDLE:

	case MOVWA_HANDLE:

		firsttype = userspace::fword;

		break;



	case MOVA_HANDLE:

	case MOVAB_HANDLE:

	case MOVAH_HANDLE:

	case MOVAW_HANDLE:

		firsttype = userspace::faddress;

		break;



	}



	// Decode second type

	switch (handle)

	{

	case MOVB_HANDLE:

	case MOVHB_HANDLE:

	case MOVWB_HANDLE:

	case MOVAB_HANDLE:

		secondtype = userspace::sbyte;

		break;



	case MOVH_HANDLE:

	case MOVBH_HANDLE:

	case MOVWH_HANDLE:

	case MOVAH_HANDLE:

		secondtype = userspace::shalfword;

		break;



	case MOVW_HANDLE:

	case MOVBW_HANDLE:

	case MOVHW_HANDLE:

	case MOVAW_HANDLE:

		secondtype = userspace::sword;

		break;



	case MOVA_HANDLE:

	case MOVBA_HANDLE:

	case MOVHA_HANDLE:

	case MOVWA_HANDLE:

		secondtype = userspace::saddress;

		break;

	}



	processor.setInstruction(userspace::MEM, firsttype | secondtype, 0, 2);

	processor.expectAddress(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="481" id="da/d4c/Actions_8cpp_1ac59ec51d7179b3c74568cd2e8582f1c9" name="INSTRUCTION" args="(inc)" definition="INSTRUCTION">INSTRUCTION(inc)

{

	std::byte suffix = 0;

	

	switch (handle)

	{

	case INC_HANDLE:

		suffix = 0;

		break;

	case INCF_HANDLE:

		suffix = userspace::ffloat;

		break;

	}



	processor.setInstruction(userspace::INC, suffix, 0, 1);

	processor.expectAddress(0);



	return nullptr;

}
</function><function index="482" id="da/d4c/Actions_8cpp_1af1459e201908f5446ae916d9b5f13068" name="INSTRUCTION" args="(dec)" definition="INSTRUCTION">INSTRUCTION(dec)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case DEC_HANDLE:

		suffix = 0;

		break;

	case DECF_HANDLE:

		suffix = userspace::ffloat;

		break;

	}



	processor.setInstruction(userspace::DEC, suffix, 0, 1);

	processor.expectAddress(0);



	return nullptr;

}
</function><function index="483" id="da/d4c/Actions_8cpp_1a2bd5670158e6a73e51130e204a3f5914" name="INSTRUCTION" args="(neg)" definition="INSTRUCTION">INSTRUCTION(neg)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case NEG_HANDLE:

		suffix = 0;

		break;

	case NEGF_HANDLE:

		suffix = userspace::ffloat;

		break;

	}



	processor.setInstruction(userspace::NEG, suffix, 0, 1);

	processor.expectAddress(0);



	return nullptr;

}
</function><function index="484" id="da/d4c/Actions_8cpp_1a8856568a3c5bc4cc6f6d206d142e9dbb" name="INSTRUCTION" args="(add)" definition="INSTRUCTION">INSTRUCTION(add)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case ADD_HANDLE:

		suffix = 0;

		break;

	case ADDF_HANDLE:

		suffix = userspace::ffloat;

		break;

	case ADDIF_HANDLE:

		suffix = userspace::sfloat;

		break;

	case ADDFF_HANDLE:

		suffix = userspace::ffloat | userspace::sfloat;

		break;

	}



	// If the handle is ADD, expect any amount of args

	if (handle == ADD_HANDLE)

	{

		processor.setInstruction(userspace::ADD, suffix, 0, 8);

		processor.surpressArgCountWarning();

		processor.expectAny(0);

		processor.expectAny(1);

		processor.expectAny(2);

		processor.expectAny(3);

		processor.expectAny(4);

		processor.expectAny(5);

		processor.expectAny(6);

		processor.expectAny(7);



		return nullptr;

	}



	processor.setInstruction(userspace::ADD, suffix, 0, 2);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="485" id="da/d4c/Actions_8cpp_1a969120d5704190cfafb4a5764131c69f" name="INSTRUCTION" args="(sub)" definition="INSTRUCTION">INSTRUCTION(sub)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case SUB_HANDLE:

		suffix = 0;

		break;

	case SUBF_HANDLE:

		suffix = userspace::ffloat;

		break;

	case SUBIF_HANDLE:

		suffix = userspace::sfloat;

		break;

	case SUBFF_HANDLE:

		suffix = userspace::ffloat | userspace::sfloat;

		break;

	}



	// If the handle is SUB, expect any amount of args

	if (handle == SUB_HANDLE)

	{

		processor.setInstruction(userspace::SUB, suffix, 0, 8);

		processor.surpressArgCountWarning();

		processor.expectAny(0);

		processor.expectAny(1);

		processor.expectAny(2);

		processor.expectAny(3);

		processor.expectAny(4);

		processor.expectAny(5);

		processor.expectAny(6);

		processor.expectAny(7);



		return nullptr;

	}



	processor.setInstruction(userspace::SUB, suffix, 0, 2);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="486" id="da/d4c/Actions_8cpp_1a653a469ebb901711dce40d92fa087be6" name="INSTRUCTION" args="(mul)" definition="INSTRUCTION">INSTRUCTION(mul)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case MUL_HANDLE:

		suffix = 0;

		break;

	case MULF_HANDLE:

		suffix = userspace::ffloat;

		break;

	case MULIF_HANDLE:

		suffix = userspace::sfloat;

		break;

	case MULFF_HANDLE:

		suffix = userspace::ffloat | userspace::sfloat;

		break;

	}



	// If the handle is MUL, expect any amount of args

	if (handle == MUL_HANDLE)

	{

		processor.setInstruction(userspace::MUL, suffix, 0, 8);

		processor.surpressArgCountWarning();

		processor.expectAny(0);

		processor.expectAny(1);

		processor.expectAny(2);

		processor.expectAny(3);

		processor.expectAny(4);

		processor.expectAny(5);

		processor.expectAny(6);

		processor.expectAny(7);



		return nullptr;

	}



	processor.setInstruction(userspace::MUL, suffix, 0, 2);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="487" id="da/d4c/Actions_8cpp_1a47e2eabe3be023783e564cdff08c6844" name="INSTRUCTION" args="(div)" definition="INSTRUCTION">INSTRUCTION(div)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case DIV_HANDLE:

		suffix = 0;

		break;

	case DIVF_HANDLE:

		suffix = userspace::ffloat;

		break;

	case DIVIF_HANDLE:

		suffix = userspace::sfloat;

		break;

	case DIVFF_HANDLE:

		suffix = userspace::ffloat | userspace::sfloat;

		break;

	}



	// Divide always expects 2 arguments

	processor.setInstruction(userspace::DIV, suffix, 0, 2);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="488" id="da/d4c/Actions_8cpp_1a72318351a97adffee73947ceea1142c7" name="INSTRUCTION" args="(mod)" definition="INSTRUCTION">INSTRUCTION(mod)

{

	std::byte suffix = 0;



	switch (handle)

	{

	case ADD_HANDLE:

		suffix = 0;

		break;

	case ADDF_HANDLE:

		suffix = userspace::ffloat;

		break;

	case ADDIF_HANDLE:

		suffix = userspace::sfloat;

		break;

	case ADDFF_HANDLE:

		suffix = userspace::ffloat | userspace::sfloat;

		break;

	}

	

	// Mod always expects 2 arguments

	processor.setInstruction(userspace::MOD, suffix, 0, 2);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="489" id="da/d4c/Actions_8cpp_1ad915c5630b7b068afe6e2234681b75ef" name="INSTRUCTION" args="(lbs)" definition="INSTRUCTION">INSTRUCTION(lbs)

{

	// Set based on handle

	processor.setInstruction(userspace::LBS, handle == LBS_HANDLE ? 0 : userspace::inplace, 0, 2);



	if (handle == LBS_HANDLE)

		processor.expectAny(0);

	else

		processor.expectAddress(0);



	processor.expectAny(1);

	return nullptr;

}
</function><function index="490" id="da/d4c/Actions_8cpp_1aa581dfd59b27632df0ac996fad8b6dd6" name="INSTRUCTION" args="(rbs)" definition="INSTRUCTION">INSTRUCTION(rbs)

{

	// Set based on handle

	processor.setInstruction(userspace::LBS, handle == RBS_HANDLE ? 0 : userspace::inplace, 0, 2);



	if (handle == RBS_HANDLE)

		processor.expectAny(0);

	else

		processor.expectAddress(0);



	processor.expectAny(1);

	return nullptr;

}
</function><function index="491" id="da/d4c/Actions_8cpp_1a5b19db83f93b309db4cf78e42b448def" name="INSTRUCTION" args="(or)" definition="INSTRUCTION">INSTRUCTION(or )

{



	std::byte suffix = 0;



	switch (handle)

	{

	case OR_HANDLE:

		suffix = 0;

		break;

	case ORIP_HANDLE:

		suffix = userspace::inplace;

		break;

	case ORB_HANDLE: // I AM ORB!!!!!!!!!!!!!!!!!!!!!!!!! FUCK YOU MOTHERFUCKERSSSSSSSSSSSSSSSSS

		suffix = userspace::bitwise;

		break;

	case ORBIP_HANDLE:

		suffix = userspace::bitwise | userspace::inplace;

		break;

	}



	// Set instruction

	processor.setInstruction(userspace::OR, suffix, 0, 2);



	// If in place, expect writeable value

	if (suffix | userspace::inplace)

		processor.expectAddress(0);

	else

		processor.expectAny(0);



	// Expect anything on second arg

	processor.expectAny(1);



	return nullptr;

}
</function><function index="492" id="da/d4c/Actions_8cpp_1aefddd1a42f6ea10fb8dd4eb8956b120d" name="INSTRUCTION" args="(xor)" definition="INSTRUCTION">INSTRUCTION(xor)

{



	std::byte suffix = 0;



	switch (handle)

	{

	case XOR_HANDLE:

		suffix = 0;

		break;

	case XORIP_HANDLE:

		suffix = userspace::inplace;

		break;

	case XORB_HANDLE: // I AM ORB!!!!!!!!!!!!!!!!!!!!!!!!! FUCK YOU MOTHERFUCKERSSSSSSSSSSSSSSSSS

		suffix = userspace::bitwise;

		break;

	case XORBIP_HANDLE:

		suffix = userspace::bitwise | userspace::inplace;

		break;

	}



	// Set instruction

	processor.setInstruction(userspace::XOR, suffix, 0, 2);



	// If in place, expect writeable value

	if (suffix | userspace::inplace)

		processor.expectAddress(0);

	else

		processor.expectAny(0);



	// Expect anything on second arg

	processor.expectAny(1);



	return nullptr;

}
</function><function index="493" id="da/d4c/Actions_8cpp_1a2dc38117871501e5ba301f1c09ede7e9" name="INSTRUCTION" args="(and)" definition="INSTRUCTION">INSTRUCTION(and)

{



	std::byte suffix = 0;



	switch (handle)

	{

	case AND_HANDLE:

		suffix = 0;

		break;

	case ANDIP_HANDLE:

		suffix = userspace::inplace;

		break;

	case ANDB_HANDLE: // I AM ORB!!!!!!!!!!!!!!!!!!!!!!!!! FUCK YOU MOTHERFUCKERSSSSSSSSSSSSSSSSS

		suffix = userspace::bitwise;

		break;

	case ANDBIP_HANDLE:

		suffix = userspace::bitwise | userspace::inplace;

		break;

	}



	// Set instruction

	processor.setInstruction(userspace::AND, suffix, 0, 2);



	// If in place, expect writeable value

	if (suffix | userspace::inplace)

		processor.expectAddress(0);

	else

		processor.expectAny(0);



	// Expect anything on second arg

	processor.expectAny(1);



	return nullptr;

}
</function><function index="494" id="da/d4c/Actions_8cpp_1a92997f3a9290065f5c59178e7ad19641" name="INSTRUCTION" args="(not)" definition="INSTRUCTION">INSTRUCTION(not)

{



	std::byte suffix = 0;



	switch (handle)

	{

	case NOT_HANDLE:

		suffix = 0;

		break;

	case NOTIP_HANDLE:

		suffix = userspace::inplace;

		break;

	case NOTB_HANDLE: // I AM ORB!!!!!!!!!!!!!!!!!!!!!!!!! FUCK YOU MOTHERFUCKERSSSSSSSSSSSSSSSSS

		suffix = userspace::bitwise;

		break;

	case NOTBIP_HANDLE:

		suffix = userspace::bitwise | userspace::inplace;

		break;

	}



	// Set instruction

	processor.setInstruction(userspace::NOT, suffix, 0, 2);



	// If in place, expect writeable value

	if (suffix | userspace::inplace)

		processor.expectAddress(0);

	else

		processor.expectAny(0);



	// Expect anything on second arg

	processor.expectAny(1);



	return nullptr;

}
</function><function index="495" id="da/d4c/Actions_8cpp_1aaabc79b151071155044b3e37f3266046" name="INSTRUCTION" args="(flag)" definition="INSTRUCTION">INSTRUCTION(flag)

{

	// If simple flag handle, then just do this

	if (handle == FLAG_HANDLE)

	{

		processor.setInstruction(userspace::FLAG, 1, 0, 1);

		processor.expectLiteral(0);



		return nullptr;

	}



	// Otherwise, this is compare flag.

	processor.setInstruction(userspace::FLAG, 0, 0, 2);

	processor.surpressArgCountWarning(1);

	processor.expectAny(0);

	processor.expectAny(1);



	return nullptr;

}
</function><function index="496" id="da/d4c/Actions_8cpp_1a64a65a1aa0cbf4e9cf17a1d3ec593132" name="INSTRUCTION" args="(jmp)" definition="INSTRUCTION">INSTRUCTION(jmp)

{

	if (handle == JMP_HANDLE)

	{

		processor.setInstruction(userspace::JMP, 0, 0, 1);

		processor.expectAddress(0);

		

		return nullptr;

	}



	processor.setInstruction(userspace::JMP, userspace::jmproutine, 0, 0);

	return nullptr;

}
</function><function index="497" id="da/d4c/Actions_8cpp_1aecd113037a91c0e531c42b0d21ab5648" name="INSTRUCTION" args="(jmpc)" definition="INSTRUCTION">INSTRUCTION(jmpc)

{



	std::byte suffix = 0;



	switch (handle)

	{

	case JLTNR_HANDLE:

		suffix = userspace::negated;

	case JLTR_HANDLE:

		suffix |= userspace::lessthan | userspace::jmproutine;

		processor.setInstruction(userspace::JMPC, suffix, 0, 0);

		return nullptr;



	case JLTN_HANDLE:

		suffix = userspace::negated;

	case JLT_HANDLE:

		suffix |= userspace::lessthan;

		processor.setInstruction(userspace::JMPC, suffix, 0, 1);

		processor.expectAddress(0);

		return nullptr;





	case JGTNR_HANDLE:

		suffix = userspace::negated;

	case JGTR_HANDLE:

		suffix |= userspace::greaterthan | userspace::jmproutine;

		processor.setInstruction(userspace::JMPC, suffix, 0, 0);

		return nullptr;



	case JGTN_HANDLE:

		suffix = userspace::negated;

	case JGT_HANDLE:

		suffix |= userspace::greaterthan;

		processor.setInstruction(userspace::JMPC, suffix, 0, 1);

		processor.expectAddress(0);

		return nullptr;

	}



	return nullptr;

}
</function><function index="498" id="da/d4c/Actions_8cpp_1ab88534ac2db5ea3b011cbc3e424ab5b8" name="INSTRUCTION" args="(jmpz)" definition="INSTRUCTION">INSTRUCTION(jmpz)

{



	std::byte suffix = 0;



	switch (handle)

	{

	case JLZNR_HANDLE:

		suffix = userspace::negated;

	case JLZR_HANDLE:

		suffix |= userspace::jmproutine | userspace::lessthan;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 0);

		return nullptr;



	case JLZN_HANDLE:

		suffix = userspace::negated;

	case JLZ_HANDLE:

		suffix |= userspace::lessthan;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 1);

		processor.expectAddress(0);

		return nullptr;









	case JEZNR_HANDLE:

		suffix = userspace::negated;

	case JEZR_HANDLE:

		suffix |= userspace::jmproutine | userspace::equalto;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 0);

		return nullptr;



	case JEZN_HANDLE:

		suffix = userspace::negated;

	case JEZ_HANDLE:

		suffix |= userspace::equalto;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 1);

		processor.expectAddress(0);

		return nullptr;









	case JGZNR_HANDLE:

		suffix = userspace::negated;

	case JGZR_HANDLE:

		suffix |= userspace::jmproutine | userspace::greaterthan;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 0);

		return nullptr;



	case JGZN_HANDLE:

		suffix = userspace::negated;

	case JGZ_HANDLE:

		suffix |= userspace::greaterthan;

		processor.setInstruction(userspace::JMPZ, suffix, 0, 1);

		processor.expectAddress(0);

		return nullptr;

	}





	return nullptr;

}
</function><function index="499" id="da/d4c/Actions_8cpp_1a4ff303c2c584cd3ad275e04862bdcd10" name="INSTRUCTION" args="(page)" definition="INSTRUCTION">INSTRUCTION(page)

{

   switch(handle)

   {

   case PAGE_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::assign | userspace::read | userspace::write, 0, 1);

	   processor.expectLiteral(0);

	   return nullptr;



   case PAGEAW_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::assign | userspace::write, 0, 1);

	   processor.expectLiteral(0);

	   return nullptr;

   case PAGEAR_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::assign | userspace::read, 0, 1);

	   processor.expectLiteral(0);

	   return nullptr;



   case PAGEW_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::write, 0, 2);

	   processor.expectLiteral(0);

	   processor.expectAny(1);

	   return nullptr;

   case PAGER_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::read, 0, 2);

	   processor.expectLiteral(0);

	   processor.expectAny(1);

	   return nullptr;



   case PALLOC_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::assign | userspace::memoryOp | userspace::sizeOp, 0, 1);

	   processor.expectLiteral(0);

	   return nullptr;

   case PFREE_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::memoryOp | userspace::sizeOp, 0, 0);

	   return nullptr;



   case PAGES_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::sizeOp | userspace::read, 0, 2);

	   processor.expectAddress(0);

	   processor.expectLiteral(1);

	   return nullptr;

   case PAGEBC_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::sizeOp | userspace::read | userspace::bytes, 0, 2);

	   processor.expectAddress(0);

	   processor.expectLiteral(1);

	   return nullptr;



   case PASSIGN_HANDLE:

	   processor.setInstruction(userspace::PAGE, userspace::assign | userspace::read | userspace::write | userspace::memoryOp, 0, 1);

	   processor.expectAddress(0);

	   return nullptr;

   }



   return "APage instruction not recognized. Please ensure you are using the right version of ELSA.";

}
</function><function index="500" id="da/d4c/Actions_8cpp_1a9673973d262bfbf4d2df0c51afe16d33" name="INSTRUCTION" args="(signal)" definition="INSTRUCTION">INSTRUCTION(signal)

{

	processor.setInstruction(userspace::SIGNAL, handle == SIGNALF_HANDLE ? 1 : 0, 0, handle == SIGNALF_HANDLE ? 2 : 1);

	if (handle == SIGNALF_HANDLE)

	{

		processor.expectLiteral(0);

		processor.expectLiteral(1);

	}

	else

	{

		processor.expectLiteral(0);

	}



	return nullptr;

}
</function><function index="501" id="da/d4c/Actions_8cpp_1a20035995df7a64af88e122d8a291f900" name="INSTRUCTION" args="(halt)" definition="INSTRUCTION">INSTRUCTION(halt)

{

	switch (handle)

	{

	case HLT_HANDLE:

		processor.setInstruction(userspace::HALT, 0, 0, 0);

		return nullptr;

	case HCF_HANDLE:

		processor.setInstruction(userspace::HALT, 1, 0, 0);

		processor.esaParser.debugInformation.errName = "-Wuse-of-hcf";

		return "WHCF instruction emitted.";

	case HBU_HANDLE:

		processor.setInstruction(userspace::HALT, 2, 0, 0);

		processor.esaParser.debugInformation.errName = "-Wuse-of-hbu";

		return "WHBU instruction emitted.";

		return nullptr;

	}

	return "AUnrecognized halt instruction. Please make sure you are using the right version of ELSA.";

}
</function><function index="502" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1a30c9bdfc3c40be8b6fd32ff1fe987970" name="readByte" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)" definition="BBP::std::byte readByte">BBP::std::byte readByte(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)

{

	return elf-&gt;file.data[offset];

}
</function><function index="503" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1a789c9ae67fcdb3a6f5454f8d99ca6b0b" name="writeByte" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::byte byte, BBP::std::offset_t offset)" definition="void writeByte">void writeByte(BBP::std::ELF::ELFBuilder *elf, BBP::std::byte byte, BBP::std::offset_t offset)

{

	elf-&gt;file.data[offset] = byte;

}
</function><function index="504" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1a62c709dfb84d60f5f9043c4f1a417079" name="readHalfWord" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)" definition="BBP::std::halfword readHalfWord">BBP::std::halfword readHalfWord(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)

{

	BBP::std::byte a = elf-&gt;file.data[offset];

	BBP::std::byte b = elf-&gt;file.data[offset + 1];



	if (!elf-&gt;Endian)

		return a | (b &lt;&lt; 8);

	return b | (a &lt;&lt; 8);

}
</function><function index="505" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1acbe729fa579c7b45c89ccca710affab7" name="writeHalfWord" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::halfword halfword, BBP::std::offset_t offset)" definition="void writeHalfWord">void writeHalfWord(BBP::std::ELF::ELFBuilder *elf, BBP::std::halfword halfword, BBP::std::offset_t offset)

{

	BBP::std::byte a = (halfword &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (halfword &gt;&gt; 8) &amp; 0xFF;



	if (!elf-&gt;Endian)

	{

		elf-&gt;file.data[offset] = a;

		elf-&gt;file.data[offset + 1] = b;

	}

	else

	{

		elf-&gt;file.data[offset] = b;

		elf-&gt;file.data[offset + 1] = a;

	}

}
</function><function index="506" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1aa966c175861f53f0da77aef07282ab12" name="readWord" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)" definition="BBP::std::word readWord">BBP::std::word readWord(BBP::std::ELF::ELFBuilder *elf, BBP::std::offset_t offset)

{

	BBP::std::byte a = elf-&gt;file.data[offset];

	BBP::std::byte b = elf-&gt;file.data[offset + 1];

	BBP::std::byte c = elf-&gt;file.data[offset + 2];

	BBP::std::byte d = elf-&gt;file.data[offset + 3];



	if (!elf-&gt;Endian)

		return a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24);

	return d | (c &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24);

}
</function><function index="507" id="dc/dc2/ELFHeaderGettersSetters_8cpp_1a662f29a4070b37792137073a799f1775" name="writeWord" args="(BBP::std::ELF::ELFBuilder *elf, BBP::std::word word, BBP::std::offset_t offset)" definition="void writeWord">void writeWord(BBP::std::ELF::ELFBuilder *elf, BBP::std::word word, BBP::std::offset_t offset)

{

	BBP::std::byte a = (word &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (word &gt;&gt; 8) &amp; 0xFF;

	BBP::std::byte c = (word &gt;&gt; 16) &amp; 0xFF;

	BBP::std::byte d = (word &gt;&gt; 24) &amp; 0xFF;



	if (!elf-&gt;Endian)

	{

		elf-&gt;file.data[offset] = a;

		elf-&gt;file.data[offset + 1] = b;

		elf-&gt;file.data[offset + 2] = c;

		elf-&gt;file.data[offset + 3] = d;

	}

	else

	{

		elf-&gt;file.data[offset] = d;

		elf-&gt;file.data[offset + 1] = c;

		elf-&gt;file.data[offset + 2] = b;

		elf-&gt;file.data[offset + 3] = a;

	}

}
</function><function index="508" id="d6/d69/Processor_8cpp_1a33cca20345e8bc757735747d9f131f9d" name="_unkown" args="(BBP::std::index_t from, BBP::std::index_t to)" definition="BBP::std::conststring _unkown">BBP::std::conststring _unkown(BBP::std::index_t from, BBP::std::index_t to)

{

	// If not defining an instruction, do this

	if (!BBP::esa::processor.lineIsDefiningInstruction)

		return BBP::esa::processor.unkown(from, to);

	return BBP::esa::processor.resolve(from, to);

}
</function><function index="509" id="d6/d69/Processor_8cpp_1a7a945d503d23337289abfc748242d6eb" name="_numerical" args="(BBP::std::Lexer::numerical_t numerical, bool isFloat)" definition="BBP::std::conststring _numerical">BBP::std::conststring _numerical(BBP::std::Lexer::numerical_t numerical, bool isFloat)

{

	if (!BBP::esa::processor.lineIsDefiningInstruction)

		return BBP::esa::processor.numerical(numerical, isFloat);

	return BBP::esa::processor.numericalArgument(numerical, isFloat);

}
</function><function index="510" id="dc/d51/SectionBuilderGettersSetters_8cpp_1aecd1a7f983edbf869d01a4be7b55e5e0" name="readWord" args="(BBP::std::ELF::SectionBuilder *sec, BBP::std::offset_t offset)" definition="BBP::std::word readWord">BBP::std::word readWord(BBP::std::ELF::SectionBuilder *sec, BBP::std::offset_t offset)

{

	BBP::std::byte a = sec-&gt;header.data[offset];

	BBP::std::byte b = sec-&gt;header.data[offset + 1];

	BBP::std::byte c = sec-&gt;header.data[offset + 2];

	BBP::std::byte d = sec-&gt;header.data[offset + 3];



	if (!sec-&gt;elf-&gt;Endian)

		return a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24);

	return d | (c &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24);

}
</function><function index="511" id="dc/d51/SectionBuilderGettersSetters_8cpp_1a2f1117d73b25ec87d35be21d06469a7b" name="writeWord" args="(BBP::std::ELF::SectionBuilder *sec, BBP::std::word word, BBP::std::offset_t offset)" definition="void writeWord">void writeWord(BBP::std::ELF::SectionBuilder *sec, BBP::std::word word, BBP::std::offset_t offset)

{

	BBP::std::byte a = (word &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (word &gt;&gt; 8) &amp; 0xFF;

	BBP::std::byte c = (word &gt;&gt; 16) &amp; 0xFF;

	BBP::std::byte d = (word &gt;&gt; 24) &amp; 0xFF;



	if (!sec-&gt;elf-&gt;Endian)

	{

		sec-&gt;header.data[offset] = a;

		sec-&gt;header.data[offset + 1] = b;

		sec-&gt;header.data[offset + 2] = c;

		sec-&gt;header.data[offset + 3] = d;

	}

	else

	{

		sec-&gt;header.data[offset] = d;

		sec-&gt;header.data[offset + 1] = c;

		sec-&gt;header.data[offset + 2] = b;

		sec-&gt;header.data[offset + 3] = a;

	}

}
</function><function index="512" id="db/db5/SegmentBuilderGettersSetters_8cpp_1af2f866c74e2272870ac09970cedd5738" name="readWord" args="(BBP::std::ELF::SegmentBuilder *seg, BBP::std::offset_t offset)" definition="BBP::std::word readWord">BBP::std::word readWord(BBP::std::ELF::SegmentBuilder *seg, BBP::std::offset_t offset)

{

	BBP::std::byte a = seg-&gt;header.data[offset];

	BBP::std::byte b = seg-&gt;header.data[offset + 1];

	BBP::std::byte c = seg-&gt;header.data[offset + 2];

	BBP::std::byte d = seg-&gt;header.data[offset + 3];



	if (!seg-&gt;elf-&gt;Endian)

		return a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24);

	return d | (c &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24);

}
</function><function index="513" id="db/db5/SegmentBuilderGettersSetters_8cpp_1ae36c2d7af1b802ba05bcdf08bd49857f" name="writeWord" args="(BBP::std::ELF::SegmentBuilder *seg, BBP::std::word word, BBP::std::offset_t offset)" definition="void writeWord">void writeWord(BBP::std::ELF::SegmentBuilder *seg, BBP::std::word word, BBP::std::offset_t offset)

{

	BBP::std::byte a = (word &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (word &gt;&gt; 8) &amp; 0xFF;

	BBP::std::byte c = (word &gt;&gt; 16) &amp; 0xFF;

	BBP::std::byte d = (word &gt;&gt; 24) &amp; 0xFF;



	if (!seg-&gt;elf-&gt;Endian)

	{

		seg-&gt;header.data[offset] = a;

		seg-&gt;header.data[offset + 1] = b;

		seg-&gt;header.data[offset + 2] = c;

		seg-&gt;header.data[offset + 3] = d;

	}

	else

	{

		seg-&gt;header.data[offset] = d;

		seg-&gt;header.data[offset + 1] = c;

		seg-&gt;header.data[offset + 2] = b;

		seg-&gt;header.data[offset + 3] = a;

	}

}
</function><function index="514" id="de/d23/StressRelief_8h_1a6b9697e03dc6310858d59b849bc0a8f1" name="FUCKYOU" args="()" definition="static void FUCKYOU">static inline void FUCKYOU()

{}
</function><function index="515" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1a88fc5f40f0438315cd35c05457257f48" name="readByte" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)" definition="BBP::std::byte readByte">BBP::std::byte readByte(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)

{

	return sym-&gt;header.data[offset];

}
</function><function index="516" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1a7a86e7eba1fa67f43c1f0548643aef02" name="writeByte" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::byte byte, BBP::std::offset_t offset)" definition="void writeByte">void writeByte(BBP::std::ELF::SymbolBuilder *sym, BBP::std::byte byte, BBP::std::offset_t offset)

{

	sym-&gt;header.data[offset] = byte;

}
</function><function index="517" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1aeff9acbd4dfabd2257b143a12085cf4a" name="readHalfWord" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)" definition="BBP::std::halfword readHalfWord">BBP::std::halfword readHalfWord(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)

{

	BBP::std::byte a = sym-&gt;header.data[offset];

	BBP::std::byte b = sym-&gt;header.data[offset + 1];



	if (!sym-&gt;elf-&gt;Endian)

		return a | (b &lt;&lt; 8);

	return b | (a &lt;&lt; 8);

}
</function><function index="518" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1a5e338db258aeae29c957af90daf80cb1" name="writeHalfWord" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::halfword halfword, BBP::std::offset_t offset)" definition="void writeHalfWord">void writeHalfWord(BBP::std::ELF::SymbolBuilder *sym, BBP::std::halfword halfword, BBP::std::offset_t offset)

{

	BBP::std::byte a = (halfword &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (halfword &gt;&gt; 8) &amp; 0xFF;



	if (!sym-&gt;elf-&gt;Endian)

	{

		sym-&gt;header.data[offset] = a;

		sym-&gt;header.data[offset + 1] = b;

	}

	else

	{

		sym-&gt;header.data[offset] = b;

		sym-&gt;header.data[offset + 1] = a;

	}

}
</function><function index="519" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1a752ea5aa70053cfcd35b88aea393438f" name="readWord" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)" definition="BBP::std::word readWord">BBP::std::word readWord(BBP::std::ELF::SymbolBuilder *sym, BBP::std::offset_t offset)

{

	BBP::std::byte a = sym-&gt;header.data[offset];

	BBP::std::byte b = sym-&gt;header.data[offset + 1];

	BBP::std::byte c = sym-&gt;header.data[offset + 2];

	BBP::std::byte d = sym-&gt;header.data[offset + 3];



	if (!sym-&gt;elf-&gt;Endian)

		return a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24);

	return d | (c &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24);

}
</function><function index="520" id="d1/d6c/SymbolBuilderGettersSetters_8cpp_1a336d2a369954870f6c7e1457fdb3f75b" name="writeWord" args="(BBP::std::ELF::SymbolBuilder *sym, BBP::std::word word, BBP::std::offset_t offset)" definition="void writeWord">void writeWord(BBP::std::ELF::SymbolBuilder *sym, BBP::std::word word, BBP::std::offset_t offset)

{

	BBP::std::byte a = (word &gt;&gt; 0) &amp; 0xFF;

	BBP::std::byte b = (word &gt;&gt; 8) &amp; 0xFF;

	BBP::std::byte c = (word &gt;&gt; 16) &amp; 0xFF;

	BBP::std::byte d = (word &gt;&gt; 24) &amp; 0xFF;



	if (!sym-&gt;elf-&gt;Endian)

	{

		sym-&gt;header.data[offset] = a;

		sym-&gt;header.data[offset + 1] = b;

		sym-&gt;header.data[offset + 2] = c;

		sym-&gt;header.data[offset + 3] = d;

	}

	else

	{

		sym-&gt;header.data[offset] = d;

		sym-&gt;header.data[offset + 1] = c;

		sym-&gt;header.data[offset + 2] = b;

		sym-&gt;header.data[offset + 3] = a;

	}

}
</function></xml>
