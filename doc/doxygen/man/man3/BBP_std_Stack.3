.TH "BBP::std::Stack< K >" 3 "Fri Jan 26 2024" "Version 0.2.0" "BBP Embedded kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BBP::std::Stack< K >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Stack\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBIterator\fP = void(*)(K &)"
.br
.ti -1c
.RI "using \fBPredicate\fP = bool(*)(K &)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBStack\fP (\fBPAGE\fP< K > *_page)"
.br
.ti -1c
.RI "\fBStack\fP (\fBPAGE\fP< K > *_page, \fBsize_t\fP max)"
.br
.ti -1c
.RI "template<int N> \fBStack\fP (\fBSTATIC_PAGE\fP< K, N > *_page)"
.br
.ti -1c
.RI "template<int N> \fBStack\fP (\fBSTATIC_PAGE\fP< K, N > *_page, \fBsize_t\fP max)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator<<\fP (K value)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator>>\fP (K &value)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator<=\fP (K value)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator>=\fP (K &value)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator>>\fP (\fBStack\fP< K > &)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator<<\fP (\fBStack\fP< K > &)"
.br
.ti -1c
.RI "K & \fBoperator+=\fP (\fBstd::s_offset_t\fP offset)"
.br
.ti -1c
.RI "K & \fBoperator%=\fP (\fBstd::s_offset_t\fP offset)"
.br
.ti -1c
.RI "K & \fBoperator[]\fP (\fBstd::index_t\fP)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator\-\-\fP ()"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator++\fP (int a)"
.br
.ti -1c
.RI "\fBStack\fP< K > & \fBoperator\-\-\fP (int a)"
.br
.ti -1c
.RI "void \fBExtend\fP (\fBstd::ResourceManager\fP *, \fBsize_t\fP)"
.br
.ti -1c
.RI "void \fBforeach\fP (\fBIterator\fP)"
.br
.ti -1c
.RI "bool \fBall\fP (\fBPredicate\fP)"
.br
.ti -1c
.RI "bool \fBany\fP (\fBPredicate\fP)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBPAGE\fP< K > * \fBpage\fP"
.br
.ti -1c
.RI "\fBsize_t\fP \fBmax_elements\fP"
.br
.ti -1c
.RI "\fBindex_t\fP \fBatElement\fP"
.br
.ti -1c
.RI "void(* \fBreadFrom\fP )(\fBStack\fP< K > *)"
.br
.ti -1c
.RI "void(* \fBwriteTo\fP )(\fBStack\fP< K > *)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename K>
.br
class BBP::std::Stack< K >"

.PP
Definition at line 14 of file Stack\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename K > using \fBBBP::std::Stack\fP< K >::\fBIterator\fP =  void (*)(K &)"

.PP
Definition at line 74 of file Stack\&.h\&.
.SS "template<typename K > using \fBBBP::std::Stack\fP< K >::\fBPredicate\fP =  bool (*)(K &)"

.PP
Definition at line 75 of file Stack\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename K > \fBBBP::std::Stack\fP< K >::\fBStack\fP (\fBPAGE\fP< K > * _page)\fC [inline]\fP"

.PP
Definition at line 19 of file Stack\&.h\&.
.PP
.nf
19 : page(_page), max_elements(std::seqlen(*_page)), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
.fi
.SS "template<typename K > \fBBBP::std::Stack\fP< K >::\fBStack\fP (\fBPAGE\fP< K > * _page, \fBsize_t\fP max)\fC [inline]\fP"

.PP
Definition at line 20 of file Stack\&.h\&.
.PP
.nf
20 : page(_page), max_elements(max), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
.fi
.SS "template<typename K > template<int N> \fBBBP::std::Stack\fP< K >::\fBStack\fP (\fBSTATIC_PAGE\fP< K, N > * _page)\fC [inline]\fP"

.PP
Definition at line 24 of file Stack\&.h\&.
.PP
.nf
24 : page(_page), max_elements(std::seqlen(*_page)), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
.fi
.SS "template<typename K > template<int N> \fBBBP::std::Stack\fP< K >::\fBStack\fP (\fBSTATIC_PAGE\fP< K, N > * _page, \fBsize_t\fP max)\fC [inline]\fP"

.PP
Definition at line 26 of file Stack\&.h\&.
.PP
.nf
26 : page(_page), max_elements(max), atElement(0), readFrom(nullptr), writeTo(nullptr) {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename K > bool \fBBBP::std::Stack\fP< K >::all (\fBPredicate\fP lambda)\fC [inline]\fP"

.PP
Definition at line 158 of file Stack\&.hxx\&.
.PP
.nf
159         {
160             bool result = true;
161             for (std::index_t index = 0; index < atElement; index++)
162                 result &= lambda(read(page, index));
163             return result;
164         }
.fi
.SS "template<typename K > bool \fBBBP::std::Stack\fP< K >::any (\fBPredicate\fP lambda)\fC [inline]\fP"

.PP
Definition at line 167 of file Stack\&.hxx\&.
.PP
.nf
168         {
169             bool result = true;
170             for (std::index_t index = 0; index < atElement; index++)
171                 result |= lambda(read(page, index));
172             return result;
173         }
.fi
.SS "template<typename K > void \fBBBP::std::Stack\fP< K >::Extend (\fBstd::ResourceManager\fP * allocator, \fBsize_t\fP by)\fC [inline]\fP"

.PP
Definition at line 125 of file Stack\&.hxx\&.
.PP
.nf
126         {
127             // Create temporary string
128             std::PAGE<K> temp(*page);
129 
130             // Save size
131             size_t oldSize = max_elements;
132 
133             // Now create a new page
134             *page = std::PAGE<K>(page->dataSize + by, (K *)allocator->calloc(page->dataSize + by, sizeof(K)));
135 
136             // Copy old data into data
137             memcpy(temp, *page, oldSize);
138 
139             // Then free old string
140             allocator->free(temp\&.data);
141 
142             // Then save the prev and next pages
143             page->prevPage = temp\&.prevPage;
144             page->nextPage = temp\&.nextPage;
145 
146             // Update stack length
147             max_elements = page->dataSize;
148         }
.fi
.SS "template<typename K > void \fBBBP::std::Stack\fP< K >::foreach (\fBIterator\fP lambda)\fC [inline]\fP"

.PP
Definition at line 151 of file Stack\&.hxx\&.
.PP
.nf
152         {
153             for (std::index_t index = 0; index < atElement; index++)
154                 lambda(read(page,index));
155         }
.fi
.SS "template<typename K > K & \fBBBP::std::Stack\fP< K >::operator%= (\fBstd::s_offset_t\fP offset)\fC [inline]\fP"

.PP
Definition at line 118 of file Stack\&.hxx\&.
.PP
.nf
119         {
120             // Just read unsafely and return directly\&.
121             return __UNSAFE__(std::read)(page, atElement + offset);
122         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator++\fC [inline]\fP"

.PP
Definition at line 13 of file Stack\&.hxx\&.
.PP
.nf
14         {
15             this->atElement++;
16             return *this;
17         }
.fi
.PP
Referenced by BBP::std::Stack< BBP::std::DIRECTORY >::operator++()\&.
.SS "template<typename K > \fBStack\fP<K>& \fBBBP::std::Stack\fP< K >::operator++ (int a)\fC [inline]\fP"

.PP
Definition at line 51 of file Stack\&.h\&.
.PP
.nf
52             {
53                 a = a;
54                 this->operator++();
55                 return *this;
56             }
.fi
.SS "template<typename K > K & \fBBBP::std::Stack\fP< K >::operator+= (\fBstd::s_offset_t\fP offset)\fC [inline]\fP"

.PP
Definition at line 108 of file Stack\&.hxx\&.
.PP
.nf
109         {
110             // Check bounds of offset
111             if ((atElement < offset && offset < 0) || atElement + offset >= max_elements)
112                 throw std::exception("Cannot peek element from stack: offset index exceeds stack page bounds\&.", EPERM);
113 
114             return std::read(page, atElement + offset);
115         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator\-\-\fC [inline]\fP"

.PP
Definition at line 20 of file Stack\&.hxx\&.
.PP
.nf
21         {
22             this->atElement--;
23             return *this;
24         }
.fi
.PP
Referenced by BBP::std::Stack< BBP::std::DIRECTORY >::operator\-\-()\&.
.SS "template<typename K > \fBStack\fP<K>& \fBBBP::std::Stack\fP< K >::operator\-\- (int a)\fC [inline]\fP"

.PP
Definition at line 57 of file Stack\&.h\&.
.PP
.nf
58             {
59                 a = a;
60                 this->operator\-\-();
61                 return *this;
62             }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator<< (K value)\fC [inline]\fP"

.PP
Definition at line 27 of file Stack\&.hxx\&.
.PP
.nf
28         {
29             // Check if stack has space
30             if (atElement >= max_elements)
31                 throw std::exception("Cannot add value to stack: maximum elements reached\&.", EPERM);
32 
33             // Write to page
34             std::write(page, value, atElement);
35 
36             // Advance one position
37             this->operator++();
38 
39             return *this;
40         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator<< (\fBStack\fP< K > & value)\fC [inline]\fP"

.PP
Definition at line 59 of file Stack\&.hxx\&.
.PP
.nf
60         {
61             char c = 0;
62             value >> c;
63             *this << c;
64             return *this;
65         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator<= (K value)\fC [inline]\fP"

.PP
Definition at line 77 of file Stack\&.hxx\&.
.PP
.nf
78         {
79             // Write to page without safety
80             __UNSAFE__(std::write)(page, value, atElement);
81 
82             // Advance one position
83             this->operator++();
84 
85             return *this;
86         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator>= (K & value)\fC [inline]\fP"

.PP
Definition at line 89 of file Stack\&.hxx\&.
.PP
.nf
90         {
91             // Decrement by one position
92             this->operator\-\-();
93 
94             // Read value without safety
95             value = __UNSAFE__(std::read)(page, atElement);
96 
97             return *this;
98         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator>> (K & value)\fC [inline]\fP"

.PP
Definition at line 43 of file Stack\&.hxx\&.
.PP
.nf
44         {
45             // Check if stack has anything
46             if (atElement == 0)
47                 throw std::exception("Cannot read from stack: stack is empty\&.", EPERM);
48 
49             // Decrement by one position
50             this->operator\-\-();
51 
52             // Read value
53             value = std::read(page, atElement);
54 
55             return *this;
56         }
.fi
.SS "template<typename K > \fBStack\fP< K > & \fBBBP::std::Stack\fP< K >::operator>> (\fBStack\fP< K > & value)\fC [inline]\fP"

.PP
Definition at line 68 of file Stack\&.hxx\&.
.PP
.nf
69         {
70             char c = 0;
71             *this >> c;
72             value << c;
73             return *this;
74         }
.fi
.SS "template<typename K > K & \fBBBP::std::Stack\fP< K >::operator[] (\fBstd::index_t\fP access)\fC [inline]\fP"

.PP
Definition at line 101 of file Stack\&.hxx\&.
.PP
.nf
102         {
103             return read(this->page, access);
104         }
.fi
.SH "Field Documentation"
.PP 
.SS "template<typename K > \fBindex_t\fP \fBBBP::std::Stack\fP< K >::atElement"

.PP
Definition at line 67 of file Stack\&.h\&.
.PP
Referenced by BBP::esa::ACTION(), BBP::esa::esaProcessor::ExpectDelimiters(), BBP::esa::esaProcessor::includeFromPath(), BBP::esa::BinaryApplication::mangle(), BBP::std::operator<<(), BBP::std::operator>(), BBP::std::operator>>=(), BBP::esa::esaProcessor::setProcedureAddress(), BBP::esa::TOKEN(), and BBP::std::Lexer::lex_context::translateUnit()\&.
.SS "template<typename K > \fBsize_t\fP \fBBBP::std::Stack\fP< K >::max_elements"

.PP
Definition at line 66 of file Stack\&.h\&.
.PP
Referenced by BBP::std::operator<<(), BBP::std::operator>>=(), and BBP::esa::TOKEN()\&.
.SS "template<typename K > \fBPAGE\fP<K>* \fBBBP::std::Stack\fP< K >::page"

.PP
Definition at line 64 of file Stack\&.h\&.
.PP
Referenced by BBP::badapple_main(), BBP::std::R2D::GetFontFromFile(), BBP::esa::BinaryApplication::mangle(), BBP::std::operator>(), BBP::std::operator>>=(), BBP::std::Lexer::lex_context::parseFile(), BBP::shell(), and BBP::smile_main()\&.
.SS "template<typename K > void(* \fBBBP::std::Stack\fP< K >::readFrom) (\fBStack\fP< K > *)"

.PP
Definition at line 71 of file Stack\&.h\&.
.PP
Referenced by BBP::std::operator>(), and BBP::std::operator>>=()\&.
.SS "template<typename K > void(* \fBBBP::std::Stack\fP< K >::writeTo) (\fBStack\fP< K > *)"

.PP
Definition at line 72 of file Stack\&.h\&.
.PP
Referenced by BBP::std::operator<<=()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for BBP Embedded kernel from the source code\&.
