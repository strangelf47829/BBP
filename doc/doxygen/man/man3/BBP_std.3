.TH "BBP::std" 3 "Fri Jan 26 2024" "Version 0.2.0" "BBP Embedded kernel" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BBP::std
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBDriver\fP"
.br
.ti -1c
.RI " \fBELF\fP"
.br
.ti -1c
.RI " \fBLexer\fP"
.br
.ti -1c
.RI " \fBR2D\fP"
.br
.ti -1c
.RI " \fBR3D\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBAbstractGCEntry\fP"
.br
.ti -1c
.RI "struct \fBcolour\fP"
.br
.ti -1c
.RI "class \fBDIRECTORY\fP"
.br
.ti -1c
.RI "struct \fBDirectoryNode\fP"
.br
.ti -1c
.RI "struct \fBExecutable\fP"
.br
.ti -1c
.RI "struct \fBexecutableFrame\fP"
.br
.ti -1c
.RI "class \fBFILE\fP"
.br
.ti -1c
.RI "struct \fBFileNode\fP"
.br
.ti -1c
.RI "class \fBGCEntry\fP"
.br
.ti -1c
.RI "struct \fBPAGE\fP"
.br
.ti -1c
.RI "class \fBPATH\fP"
.br
.ti -1c
.RI "class \fBResourceManager\fP"
.br
.ti -1c
.RI "struct \fBSIGNAL\fP"
.br
.ti -1c
.RI "class \fBStack\fP"
.br
.ti -1c
.RI "struct \fBSTATIC_PAGE\fP"
.br
.ti -1c
.RI "class \fBTerminal\fP"
.br
.ti -1c
.RI "class \fBVOLUME\fP"
.br
.ti -1c
.RI "struct \fBwindow\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBerrno_t\fP"
.br
.ti -1c
.RI "typedef int(* \fBexecutable_main\fP) (int argc, char **argv)"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBPID_t\fP"
.br
.ti -1c
.RI "typedef \fBstd::index_t\fP \fBnoderef_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBRGBA_t\fP"
.br
.ti -1c
.RI "typedef \fBbyte\fP \fBchan_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBpos_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBmask_t\fP"
.br
.ti -1c
.RI "typedef int \fBsignal_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBword\fP"
.br
.ti -1c
.RI "typedef \fBint32_t\fP \fBsword\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP \fBdword\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBhalfword\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBbyte\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBnibble\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBcrumb\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBoffset_t\fP"
.br
.ti -1c
.RI "typedef \fBsword\fP \fBs_offset_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBaddress_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBindex_t\fP"
.br
.ti -1c
.RI "typedef \fBword\fP \fBsize_t\fP"
.br
.ti -1c
.RI "typedef \fBbyte\fP \fBmem_t\fP"
.br
.ti -1c
.RI "typedef char \fBstring_element\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBustring_element\fP"
.br
.ti -1c
.RI "typedef \fBPAGE\fP< \fBstring_element\fP > \fBstring\fP"
.br
.ti -1c
.RI "template<int N> using \fBstatic_string\fP = \fBSTATIC_PAGE\fP< \fBstring_element\fP, N >"
.br
.ti -1c
.RI "typedef \fBstring_element\fP * \fBc_string\fP"
.br
.ti -1c
.RI "typedef \fBustring_element\fP * \fBuc_string\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBhash_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBtime_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBswap\fP (int *a, int *b)"
.br
.ti -1c
.RI "float \fBabsolute\fP (float x)"
.br
.ti -1c
.RI "int \fBiPartOfNumber\fP (float x)"
.br
.ti -1c
.RI "int \fBroundNumber\fP (float x)"
.br
.ti -1c
.RI "float \fBfPartOfNumber\fP (float x)"
.br
.ti -1c
.RI "float \fBrfPartOfNumber\fP (float x)"
.br
.ti -1c
.RI "except \fBexception\fP (const char *msg, \fBerrno_t\fP _errno)"
.br
.ti -1c
.RI "\fBPID_t\fP \fBgetNextAvailablePID\fP ()"
.br
.ti -1c
.RI "\fBPID_t\fP \fBspawnExecutable\fP (\fBexecutable_main\fP, \fBstd::string\fP &)"
.br
.ti -1c
.RI "void \fBexecute\fP (\fBexecutable_main\fP, int argc, char **argv)"
.br
.ti -1c
.RI "void \fBexit\fP ()"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBfprintf\fP (\fBBBP::std::FILE\fP &file, \fBstd::conststring\fP format, Args\&.\&.\&. args)"
.br
.ti -1c
.RI "template<typename T > void \fBwrite\fP (\fBPAGE\fP< T > *page, T &data, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > void \fBwrite_r\fP (\fBPAGE\fP< T > *page, \fBmem_t\fP &data, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > void \fBwrite_a\fP (\fBPAGE\fP< T > *page, T *data, \fBindex_t\fP index, \fBsize_t\fP amount)"
.br
.ti -1c
.RI "template<typename T > void \fBwrite_ar\fP (\fBPAGE\fP< T > *page, \fBmem_t\fP *data, \fBindex_t\fP index, \fBsize_t\fP amount)"
.br
.ti -1c
.RI "template<typename T > void \fB__UNSAFE__\fP() \fBwrite\fP (\fBPAGE\fP< T > *page, T &data, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > void \fB__UNSAFE__\fP() \fBwrite_a\fP (\fBPAGE\fP< T > *page, T *data, \fBindex_t\fP index, \fBsize_t\fP amount)"
.br
.ti -1c
.RI "template<typename T > void \fB__UNSAFE__\fP() \fBwrite_r\fP (\fBPAGE\fP< T > *page, \fBmem_t\fP &data, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > T & \fBread\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > \fBmem_t\fP & \fBread_r\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > T * \fBread_a\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > \fBmem_t\fP * \fBread_ar\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > T &\fB__UNSAFE__\fP() \fBread\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > \fBmem_t\fP &\fB__UNSAFE__\fP() \fBread_r\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > T *\fB__UNSAFE__\fP() \fBread_a\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > \fBmem_t\fP *\fB__UNSAFE__\fP() \fBread_ar\fP (\fBPAGE\fP< T > *page, \fBindex_t\fP index)"
.br
.ti -1c
.RI "template<typename T > \fBstd::PAGE\fP< T > & \fBlast\fP (\fBstd::PAGE\fP< T > &)"
.br
.ti -1c
.RI "template<typename T > \fBstd::PAGE\fP< T > & \fBfirst\fP (\fBstd::PAGE\fP< T > &)"
.br
.ti -1c
.RI "template<typename T > \fBsize_t\fP \fBseqlen\fP (\fBPAGE\fP< T > &page)"
.br
.ti -1c
.RI "template<typename T > \fBsize_t\fP \fBseqlen_r\fP (\fBPAGE\fP< T > &page)"
.br
.ti -1c
.RI "template<typename T > \fBsize_t\fP \fB__UNSAFE__\fP() \fBseqlen\fP (\fBPAGE\fP< T > &page)"
.br
.ti -1c
.RI "template<typename T > \fBsize_t\fP \fB__UNSAFE__\fP() \fBseqlen_r\fP (\fBPAGE\fP< T > &page)"
.br
.ti -1c
.RI "template<typename T > void \fBmemcpy\fP (\fBPAGE\fP< T > &src, \fBPAGE\fP< T > &dst, \fBsize_t\fP amount)"
.br
.ti -1c
.RI "template<typename T > void \fBmemcpy\fP (\fBPAGE\fP< T > &src, \fBPAGE\fP< T > &dst)"
.br
.ti -1c
.RI "template<typename T > bool \fBmemcmp\fP (\fBPAGE\fP< T > &src, \fBPAGE\fP< T > &dst)"
.br
.ti -1c
.RI "void \fBext_free\fP (void *)"
.br
.ti -1c
.RI "void * \fBext_malloc\fP (\fBstd::size_t\fP)"
.br
.ti -1c
.RI "void * \fBext_calloc\fP (\fBstd::size_t\fP, \fBstd::size_t\fP)"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBdecimals\fP (\fBuint32_t\fP value)"
.br
.ti -1c
.RI "\fBuint8_t\fP \fBgetDecimal\fP (\fBuint32_t\fP value, \fBuint32_t\fP position)"
.br
.ti -1c
.RI "void \fBprint_to_terminal\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > *stack)"
.br
.ti -1c
.RI "int \fBsprintf\fP (\fBstd::c_string\fP buffer, \fBstd::conststring\fP format,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBprintf\fP (\fBstd::conststring\fP format,\&.\&.\&.)"
.br
.ti -1c
.RI "int \fBputf\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stream, \fBstd::conststring\fP format,\&.\&.\&.)"
.br
.ti -1c
.RI "void \fBcaptureInput\fP ()"
.br
.ti -1c
.RI "void \fBstopCapturingInput\fP ()"
.br
.ti -1c
.RI "char \fBgetC\fP ()"
.br
.ti -1c
.RI "void \fBgetLine\fP ()"
.br
.ti -1c
.RI "void \fBstrcpy\fP (\fBstring\fP *dst, \fBconststring\fP src)"
.br
.ti -1c
.RI "void \fBoperator<=\fP (\fBstring\fP &dst, \fBconststring\fP src)"
.br
.ti -1c
.RI "void \fBstrcpy\fP (\fBstring\fP *dst, \fBc_string\fP src)"
.br
.ti -1c
.RI "void \fBoperator<=\fP (\fBstring\fP &dst, \fBc_string\fP src)"
.br
.ti -1c
.RI "void \fBstrcpy\fP (\fBc_string\fP dst, \fBconststring\fP src)"
.br
.ti -1c
.RI "bool \fBstrcmp\fP (\fBstring\fP *sta, \fBconststring\fP stb)"
.br
.ti -1c
.RI "bool \fBstrcmp\fP (\fBstring\fP *sta, \fBc_string\fP stb)"
.br
.ti -1c
.RI "\fBsize_t\fP \fBstrlen\fP (\fBconststring\fP str)"
.br
.ti -1c
.RI "\fBsize_t\fP \fBstrlen\fP (\fBc_string\fP str)"
.br
.ti -1c
.RI "\fBsize_t\fP \fBstrlen\fP (\fBstring\fP &str)"
.br
.ti -1c
.RI "\fBsize_t\fP \fBstrlen\fP (\fBstring\fP str, \fBoffset_t\fP offset)"
.br
.ti -1c
.RI "\fBhash_t\fP \fBstrhsh\fP (\fBstring\fP &str)"
.br
.ti -1c
.RI "\fBhash_t\fP \fBstrhsh\fP (\fBc_string\fP str)"
.br
.ti -1c
.RI "\fBhash_t\fP \fBstrhsh\fP (\fBconststring\fP str)"
.br
.ti -1c
.RI "constexpr \fBstd::hash_t\fP \fBoperator''_hash\fP (const char *str, long unsigned int hehe)"
.br
.ti -1c
.RI "void \fBstrhsh\fP (\fBhash_t\fP &, \fBword\fP &, \fBstring_element\fP &)"
.br
.ti -1c
.RI "\fBsize_t\fP \fB__UNSAFE__\fP() \fBstrlen\fP (\fBstring\fP str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::conststring\fP str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::c_string\fP str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::string\fP &str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, char c)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, int value)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::conststring\fP str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::c_string\fP str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::string\fP &str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, int value)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>>=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::c_string\fP *str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>>=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::string\fP *str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>>\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &lh, \fBstd::Stack\fP< \fBstd::string_element\fP > &rh)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &lh, \fBstd::Stack\fP< \fBstd::string_element\fP > &rh)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>>=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &lh, \fBstd::Stack\fP< \fBstd::string_element\fP > &rh)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator<<=\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &lh, \fBstd::Stack\fP< \fBstd::string_element\fP > &rh)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::c_string\fP *str)"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > & \fBoperator>\fP (\fBstd::Stack\fP< \fBstd::string_element\fP > &stack, \fBstd::string\fP *str)"
.br
.ti -1c
.RI "\fBtime_t\fP \fBmillis\fP ()"
.br
.ti -1c
.RI "void \fBdelay\fP (\fBtime_t\fP)"
.br
.ti -1c
.RI "\fBtime_t\fP \fBnow\fP ()"
.br
.ti -1c
.RI "void \fBinitClock\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const typedef \fBstring_element\fP * \fBconststring\fP"
.br
.ti -1c
.RI "const typedef \fBustring_element\fP * \fBuconststring\fP"
.br
.ti -1c
.RI "\fBResourceManager\fP \fBvmem\fP"
.br
.ti -1c
.RI "\fBSTATIC_PAGE\fP< \fBexecutableFrame\fP, 12 > \fBprocFrames\fP"
.br
.ti -1c
.RI "\fBStack\fP< \fBexecutableFrame\fP > \fBProcesses\fP"
.br
.ti -1c
.RI "\fBPID_t\fP \fBactiveExecutable\fP = 0"
.br
.ti -1c
.RI "const \fBExecutable\fP \fBexecutables\fP [] = {{\fBshell_main\fP, '/proc/\fBshell\fP'}}"
.br
.ti -1c
.RI "static constexpr \fBstd::size_t\fP \fBmax_open_files\fP = 32"
.br
.ti -1c
.RI "static constexpr \fBstd::size_t\fP \fBmax_path_length\fP = 128"
.br
.ti -1c
.RI "\fBstd::STATIC_PAGE\fP< \fBFileNode\fP, \fBmax_open_files\fP > \fBfileTable\fP"
.br
.ti -1c
.RI "\fBPATH\fP * \fBworkingDirectory\fP"
.br
.ti -1c
.RI "\fBVOLUME\fP * \fBprimaryVolume\fP"
.br
.ti -1c
.RI "bool \fBgINIT\fP"
.br
.ti -1c
.RI "constexpr \fBword\fP \fBmax_page_elements\fP = 20000"
.br
.ti -1c
.RI "constexpr \fBword\fP \fBmax_page_static_size\fP = 20000"
.br
.ti -1c
.RI "constexpr \fBword\fP \fBmax_page_pointer_size\fP = \fBmax_page_elements\fP"
.br
.ti -1c
.RI "constexpr \fBword\fP \fBmax_page_sequence_length\fP = 64"
.br
.ti -1c
.RI "constexpr \fBword\fP \fBmax_lpage_static_size\fP = 0x2000"
.br
.ti -1c
.RI "\fBstd::window\fP \fBkernelDisplay\fP"
.br
.ti -1c
.RI "static constexpr \fBsize_t\fP \fBmax_objects\fP = 1000"
.br
.ti -1c
.RI "static constexpr \fBsize_t\fP \fBmax_allocations\fP = 1000"
.br
.ti -1c
.RI "\fBResourceManager\fP \fBprogmem\fP"
.br
.ti -1c
.RI "\fBResourceManager\fP * \fBactivemem\fP"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGINV\fP = 1"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGTERM\fP = 2"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGSEGV\fP = 3"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGINT\fP = 4"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGILL\fP = 5"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGABRT\fP = 6"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGFPE\fP = 7"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGSHTDN\fP = 8"
.br
.ti -1c
.RI "constexpr \fBsignal_t\fP \fBSIGADJ\fP = 150"
.br
.ti -1c
.RI "\fBstatic_string\fP< 509 > \fBstr_STDOUT\fP"
.br
.ti -1c
.RI "\fBstatic_string\fP< 509 > \fBstr_STDIN\fP"
.br
.ti -1c
.RI "\fBstatic_string\fP< 509 > \fBstr_STDERR\fP"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > \fBSTDOUT\fP"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > \fBSTDIN\fP"
.br
.ti -1c
.RI "\fBstd::Stack\fP< \fBstd::string_element\fP > \fBSTDERR\fP"
.br
.ti -1c
.RI "volatile bool \fB_waitforline\fP"
.br
.ti -1c
.RI "volatile bool \fB_echoStuffToTerminal\fP"
.br
.ti -1c
.RI "const \fBsize_t\fP \fBmax_string_length\fP = 0xFFFF"
.br
.ti -1c
.RI "const \fBstd::conststring\fP \fBspace\fP = ' '"
.br
.ti -1c
.RI "const \fBstd::conststring\fP \fBendl\fP = '\\n'"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBword\fP \fBBBP::std::address_t\fP"

.PP
Definition at line 45 of file stddef\&.h\&.
.SS "typedef \fBuint8_t\fP \fBBBP::std::byte\fP"

.PP
Definition at line 30 of file stddef\&.h\&.
.SS "typedef \fBstring_element\fP* \fBBBP::std::c_string\fP"

.PP
Definition at line 25 of file Strings\&.h\&.
.SS "typedef \fBbyte\fP \fBBBP::std::chan_t\fP"

.PP
Definition at line 19 of file Graphics\&.h\&.
.SS "typedef \fBuint8_t\fP \fBBBP::std::crumb\fP"

.PP
Definition at line 36 of file stddef\&.h\&.
.SS "typedef \fBuint64_t\fP \fBBBP::std::dword\fP"

.PP
Definition at line 23 of file stddef\&.h\&.
.SS "typedef int \fBBBP::std::errno_t\fP"

.PP
Definition at line 10 of file errno\&.h\&.
.SS "typedef int(* BBP::std::executable_main) (int argc, char **argv)"

.PP
Definition at line 22 of file Executable\&.h\&.
.SS "typedef \fBuint16_t\fP \fBBBP::std::halfword\fP"

.PP
Definition at line 27 of file stddef\&.h\&.
.SS "typedef \fBuint32_t\fP \fBBBP::std::hash_t\fP"

.PP
Definition at line 36 of file Strings\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::index_t\fP"

.PP
Definition at line 48 of file stddef\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::mask_t\fP"

.PP
Definition at line 25 of file Graphics\&.h\&.
.SS "typedef \fBbyte\fP \fBBBP::std::mem_t\fP"

.PP
Definition at line 54 of file stddef\&.h\&.
.SS "typedef \fBuint8_t\fP \fBBBP::std::nibble\fP"

.PP
Definition at line 33 of file stddef\&.h\&.
.SS "typedef \fBstd::index_t\fP \fBBBP::std::noderef_t\fP"

.PP
Definition at line 32 of file FileSys\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::offset_t\fP"

.PP
Definition at line 39 of file stddef\&.h\&.
.SS "typedef \fBuint8_t\fP \fBBBP::std::PID_t\fP"

.PP
Definition at line 25 of file Executable\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::pos_t\fP"

.PP
Definition at line 22 of file Graphics\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::RGBA_t\fP"

.PP
Definition at line 16 of file Graphics\&.h\&.
.SS "typedef \fBsword\fP \fBBBP::std::s_offset_t\fP"

.PP
Definition at line 42 of file stddef\&.h\&.
.SS "typedef int \fBBBP::std::signal_t\fP"

.PP
Definition at line 15 of file Signal\&.h\&.
.SS "typedef \fBword\fP \fBBBP::std::size_t\fP"

.PP
Definition at line 51 of file stddef\&.h\&.
.SS "template<int N> using \fBBBP::std::static_string\fP = typedef \fBSTATIC_PAGE\fP<\fBstring_element\fP, N>"

.PP
Definition at line 22 of file Strings\&.h\&.
.SS "typedef \fBPAGE\fP<\fBstring_element\fP> \fBBBP::std::string\fP"

.PP
Definition at line 18 of file Strings\&.h\&.
.SS "typedef char \fBBBP::std::string_element\fP"

.PP
Definition at line 14 of file Strings\&.h\&.
.SS "typedef \fBint32_t\fP \fBBBP::std::sword\fP"

.PP
Definition at line 18 of file stddef\&.h\&.
.SS "typedef \fBuint32_t\fP \fBBBP::std::time_t\fP"

.PP
Definition at line 12 of file Time\&.h\&.
.SS "typedef \fBustring_element\fP* \fBBBP::std::uc_string\fP"

.PP
Definition at line 26 of file Strings\&.h\&.
.SS "typedef unsigned char \fBBBP::std::ustring_element\fP"

.PP
Definition at line 15 of file Strings\&.h\&.
.SS "typedef \fBuint32_t\fP \fBBBP::std::word\fP"

.PP
Definition at line 15 of file stddef\&.h\&.
.SH "Function Documentation"
.PP 
.SS "float BBP::std::absolute (float x)"

.PP
Definition at line 294 of file R2D\&.cpp\&.
.PP
.nf
295         {
296             if (x < 0) return -x;
297             else return x;
298         }
.fi
.PP
Referenced by BBP::std::R2D::Line()\&.
.SS "void BBP::std::captureInput ()"

.SS "\fBBBP::uint32_t\fP BBP::std::decimals (\fBuint32_t\fP value)"

.PP
Definition at line 3 of file stdint\&.cpp\&.
.PP
.nf
4 {
5     uint32_t decim = 1;
6     for (uint32_t val = value; val >= 10; val /= 10)
7         decim++;
8     return decim;
9 }
.fi
.PP
Referenced by operator<()\&.
.SS "void BBP::std::delay (\fBtime_t\fP)"

.PP
Referenced by BBP::badapple_main()\&.
.SS "BBP::std::except BBP::std::exception (const char * msg, \fBerrno_t\fP _errno)"

.PP
Definition at line 7 of file Except\&.cpp\&.
.PP
.nf
8 {
9     // set error number
10     BBP::std::__errno = _errno;
11 
12     // Stream msg into STDERR
13     BBP::std::STDERR << "\e[0;31mError: " << msg << "\e[0;37m" <<= std::endl;
14 
15     except exc = {_errno};
16 
17     return exc;
18 }
.fi
.PP
References endl, and STDERR\&.
.PP
Referenced by BBP::std::ResourceManager::add_alloc(), BBP::std::ResourceManager::add_object(), BBP::esa::esaProcessor::addReservedIdentifier(), BBP::std::ELF::SectionBuilder::Append(), BBP::std::ResourceManager::calloc(), BBP::std::ELF::ELFBuilder::ELFBuilder(), BBP::esa::esaProcessor::emitProcedure(), BBP::esa::BinaryApplication::emitSymbol(), execute(), BBP::std::ELF::SectionBuilder::Extend(), BBP::std::FILE::FILE(), fprintf(), BBP::std::FILE::getINodeIndex(), BBP::std::PATH::makeAbsolutePath(), BBP::std::ResourceManager::malloc(), BBP::std::Stack< BBP::std::DIRECTORY >::operator+=(), BBP::std::Stack< BBP::std::DIRECTORY >::operator<<(), operator<<(), BBP::std::Stack< BBP::std::DIRECTORY >::operator>>(), operator>>=(), BBP::std::ELF::ELFBuilder::renameSymbol(), and strlen()\&.
.SS "void BBP::std::execute (\fBstd::executable_main\fP mainFunc, int argc, char ** argv)"

.PP
Definition at line 14 of file Executable\&.cpp\&.
.PP
.nf
15 {
16     // Find a new PID
17     PID_t procPID = getNextAvailablePID();
18 
19     // Create new process stack
20     executableFrame procFrame = std::read(&procFrames, procPID);
21 
22     // Set pid
23     procFrame\&.PID = procPID;
24 
25     // Create process memory
26     procFrame\&.pmem = BBP::std::progmem\&.add_object(new std::ResourceManager());
27 
28     // Swap that in for the old activemem
29     BBP::std::ResourceManager *oldActiveMem = BBP::std::activemem;
30     BBP::std::activemem = procFrame\&.pmem;
31 
32     // Store old active executable
33     PID_t oldActiveExecutable = std::activeExecutable;
34 
35     // Set active executable to this one
36     std::activeExecutable = procPID;
37 
38     // Run main function in try block
39     try 
40     {
41         // Set 'Is executing' flag to true
42         procFrame\&.isExecuting = true;
43 
44         // Acually execute the program
45         BBP::std::__errno = mainFunc(argc, argv);
46 
47         // Reset the 'is executing' flag
48         procFrame\&.isExecuting = false;
49 
50         // Reset terminal
51         BBP::std::kernelDisplay\&.fontSize = 1;
52         BBP::std::kernelDisplay\&.fontSpacing = 6;
53         BBP::std::R2D::fill(&BBP::std::kernelDisplay, 0xFFFFFFFF);
54     }
55     catch (const std::SIGNAL &signal)
56     {
57         switch (signal\&._sig)
58         {
59         case BBP::std::SIGSHTDN:
60             // System shutdown, rethrow signal, but before doing that, reset the state of this program
61             
62             // Garbage collection
63             procFrame\&.pmem->deleteAll();
64             procFrame\&.pmem->freeAll();
65 
66             // Delete garbage collector
67             BBP::std::progmem\&._delete(procFrame\&.pmem);
68 
69             // Restore active mem and active proc
70             BBP::std::activemem = oldActiveMem;
71             BBP::std::activeExecutable = oldActiveExecutable;
72             throw;
73 
74         default:
75             BBP::std::printf("[bbp] Program terminated after receiving signal %u", signal\&._sig);
76 
77             if (signal\&._sig == std::SIGILL)
78                 BBP::std::printf(" (SIGILL)\&.");
79 
80             BBP::std::printf("\r\n");
81             break;
82         }
83     }
84     catch (std::except exception)
85     {
86         BBP::std::printf("[bbp] Uncaught exception: halting program\&.\r\n");
87         std::STDOUT <<= std::STDERR;
88     }
89     catch (\&.\&.\&.)
90     {
91         BBP::std::printf("[bbp] Program terminated after uncaught object\&.\r\n");
92     }
93 
94     if (std::__errno && std::STDERR[0])
95         BBP::std::printf("Program terminated with code %d: %s\n\r", std::__errno, &std::STDERR[0]);
96 
97     // Print stuff
98     //std::printf("(%p) Allocated a total of %u bytes during runtime\&.\n", procFrame\&.pmem, procFrame\&.pmem->totalAllocations);
99 
100     // Garbage collection
101     BBP::std::size_t deletedCount = procFrame\&.pmem->deleteAll();
102     BBP::std::size_t freedCount = procFrame\&.pmem->freeAll();
103 
104     if (deletedCount || freedCount)
105     {
106         printf("\nNot all memory on the heap was released\&.\n");
107 
108         printf("\tAmount of blocks free'd: %u\n", freedCount);
109         printf("\tAmount of objects delete'd: %u\n", deletedCount);
110     }
111 
112     // Delete garbage collector
113     BBP::std::progmem\&._delete(procFrame\&.pmem);
114 
115     // Restore active mem and active proc
116     BBP::std::activemem = oldActiveMem;
117     BBP::std::activeExecutable = oldActiveExecutable;
118 }
.fi
.PP
References BBP::std::ResourceManager::_delete(), BBP::std::SIGNAL::_sig, activeExecutable, activemem, BBP::std::ResourceManager::add_object(), BBP::std::ResourceManager::deleteAll(), exception(), BBP::std::R2D::fill(), BBP::std::window::fontSize, BBP::std::window::fontSpacing, BBP::std::ResourceManager::freeAll(), getNextAvailablePID(), BBP::std::executableFrame::isExecuting, kernelDisplay, BBP::std::executableFrame::PID, BBP::std::executableFrame::pmem, printf(), procFrames, progmem, BBP::userspace::read, SIGILL, SIGSHTDN, STDERR, and STDOUT\&.
.PP
Referenced by BBP::shell()\&.
.SS "void BBP::std::exit ()"

.PP
Definition at line 126 of file Executable\&.cpp\&.
.PP
.nf
127 {
128     printf("\n\r");
129     __SIGNAL__(SIGABRT);
130 }
.fi
.PP
References __SIGNAL__, printf(), and SIGABRT\&.
.SS "void* BBP::std::ext_calloc (\fBstd::size_t\fP, \fBstd::size_t\fP)"

.PP
Referenced by BBP::std::ResourceManager::calloc()\&.
.SS "void BBP::std::ext_free (void *)"

.PP
Referenced by BBP::std::ResourceManager::free()\&.
.SS "void* BBP::std::ext_malloc (\fBstd::size_t\fP)"

.PP
Referenced by BBP::std::ResourceManager::malloc()\&.
.SS "template<typename T > \fBstd::PAGE\fP<T>& BBP::std::first (\fBstd::PAGE\fP< T > &)"

.PP
Referenced by BBP::std::PATH::isRelativeToRoot()\&.
.SS "float BBP::std::fPartOfNumber (float x)"

.PP
Definition at line 313 of file R2D\&.cpp\&.
.PP
.nf
314         {
315             if (x > 0) return x - iPartOfNumber(x);
316             else return x - (iPartOfNumber(x) + 1);
317 
318         }
.fi
.PP
References iPartOfNumber()\&.
.PP
Referenced by rfPartOfNumber()\&.
.SS "template<typename\&.\&.\&. Args> void BBP::std::fprintf (\fBBBP::std::FILE\fP & file, \fBstd::conststring\fP format, Args\&.\&.\&. args)\fC [inline]\fP"

.PP
Definition at line 262 of file FileSys\&.h\&.
.PP
.nf
263         {
264             // Check if can write to file
265             if (!file\&.is_open())
266                 throw std::exception("ERR_FILE_NOT_OPEN", EBADF);
267 
268             // Allocate a buffer
269             std::string buffer(BBP::std::max_page_elements, (BBP::std::string_element *)BBP::std::activemem->calloc(BBP::std::max_page_elements, sizeof(BBP::std::string_element)));
270 
271             // Format the string
272             std::sprintf(buffer\&.data, format, args\&.\&.\&.);
273 
274             // Then print
275             file\&.data()->fileData <<= buffer;
276 
277             // Then free the buffer
278             BBP::std::activemem->free(buffer\&.data);
279 
280         }
.fi
.PP
References activemem, BBP::std::PAGE< T >::data, BBP::std::FILE::data(), EBADF, exception(), BBP::std::FileNode::fileData, BBP::std::ResourceManager::free(), BBP::std::FILE::is_open(), max_page_elements, and sprintf()\&.
.SS "char BBP::std::getC ()"

.PP
Referenced by BBP::shell_main()\&.
.SS "\fBBBP::uint8_t\fP BBP::std::getDecimal (\fBuint32_t\fP value, \fBuint32_t\fP position)"

.PP
Definition at line 11 of file stdint\&.cpp\&.
.PP
.nf
12 {
13     uint32_t divisor = 1;
14 
15     for (uint32_t p = 0; p < position; p++)
16         divisor *= 10;
17 
18     return (value / divisor) % 10;
19 }
.fi
.PP
Referenced by operator<()\&.
.SS "void BBP::std::getLine ()"

.SS "\fBBBP::std::PID_t\fP BBP::std::getNextAvailablePID ()"

.PP
Definition at line 121 of file Executable\&.cpp\&.
.PP
.nf
122 {
123     return pidCounter++;
124 }
.fi
.PP
References pidCounter\&.
.PP
Referenced by execute()\&.
.SS "void BBP::std::initClock ()"

.SS "int BBP::std::iPartOfNumber (float x)"

.PP
Definition at line 301 of file R2D\&.cpp\&.
.PP
.nf
302         {
303             return (int)x;
304         }
.fi
.PP
Referenced by fPartOfNumber(), BBP::std::R2D::Line(), and roundNumber()\&.
.SS "template<typename T > \fBstd::PAGE\fP<T>& BBP::std::last (\fBstd::PAGE\fP< T > &)"

.PP
Referenced by BBP::std::ELF::SectionBuilder::Append(), and BBP::std::ELF::SegmentBuilder::Append()\&.
.SS "template<typename T > bool BBP::std::memcmp (\fBPAGE\fP< T > & src, \fBPAGE\fP< T > & dst)"

.SS "template<typename T > void BBP::std::memcpy (\fBPAGE\fP< T > & src, \fBPAGE\fP< T > & dst)\fC [inline]\fP"

.PP
Definition at line 160 of file Memory\&.h\&.
.PP
.nf
161         {
162             // Get sequence length of src
163             std::size_t srcLen = std::seqlen(src);
164             std::size_t dstLen = std::seqlen(dst);
165 
166             memcpy(src, dst, (srcLen < dstLen) ? srcLen : dstLen);
167         }
.fi
.PP
References memcpy(), and seqlen()\&.
.SS "template<typename T > void BBP::std::memcpy (\fBPAGE\fP< T > & src, \fBPAGE\fP< T > & dst, \fBsize_t\fP amount)"

.PP
Referenced by BBP::std::Stack< BBP::std::DIRECTORY >::Extend(), BBP::esa::esaProcessor::includeFile(), and memcpy()\&.
.SS "\fBtime_t\fP BBP::std::millis ()"

.SS "\fBtime_t\fP BBP::std::now ()"

.SS "constexpr \fBstd::hash_t\fP BBP::std::operator''_hash (const char * str, long unsigned int hehe)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 72 of file Strings\&.h\&.
.PP
.nf
73         {
74             // Hashing constants
75             const int p = 31;
76             const int m = 1e9 + 9;
77 
78             // Working variables
79             std::hash_t hash = 0;
80             uint32_t Power = 1;
81 
82             // Get the size of the string
83             std::size_t length = hehe;
84 
85             // Actual hashing algorithm\&. Taken from: 
86             for (std::index_t index = 0; index < length; index++)
87             {
88                 char c = str[index];
89                 hash = (hash + (c - 'a' + 1) * Power) % m;
90                 Power = (p * Power) % m;
91             }
92 
93             return hash;
94         }
.fi
.PP
References BBP::Locale::Japanese::hash\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator< (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, int value)"

.PP
Definition at line 269 of file Strings\&.cpp\&.
.PP
.nf
270 {
271     // Print sign
272     if (value < 0)
273     {
274         stack << '-';
275         value *= -1;
276     }
277 
278     // Get the amount of decimals
279     uint32_t decimals = std::decimals(value);
280 
281     for (uint32_t decimal = 0; decimal < decimals; decimal++)
282     {
283         std::word dec = std::getDecimal(value, decimals - decimal - 1);
284         stack << (char)(dec + 48);
285     }
286 
287     return stack;
288 }
.fi
.PP
References decimals(), and getDecimal()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<< (\fBstd::Stack\fP< \fBstd::string_element\fP > & lh, \fBstd::Stack\fP< \fBstd::string_element\fP > & rh)"

.PP
Definition at line 443 of file Strings\&.cpp\&.
.PP
.nf
444 {
445     char c = 0;
446     rh >> c;
447     lh << c;
448     return lh;
449 }
.fi
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<< (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::c_string\fP str)"

.PP
Definition at line 238 of file Strings\&.cpp\&.
.PP
.nf
239 {
240     // Check string exists
241     if (str == nullptr)
242         throw std::exception("Failed to stream string into buffer: string is null\&.", EINVAL);
243 
244     // Calculate string size
245     size_t strLen = std::strlen(str);
246 
247     // Check if stack has enough space
248     if (stack\&.atElement + strLen >= stack\&.max_elements)
249         throw std::exception("Failed to stream string into buffer: operation would cause buffer overflow\&.", EPERM);
250 
251     // Write unsafely (since we already checked everything)
252     for (index_t idx = 0; idx < strLen; idx++)
253         stack <= str[idx];
254 
255     return stack;
256 }
.fi
.PP
References BBP::std::Stack< K >::atElement, EINVAL, EPERM, exception(), BBP::std::Stack< K >::max_elements, and strlen()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<< (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::conststring\fP str)"

.PP
Definition at line 218 of file Strings\&.cpp\&.
.PP
.nf
219 {
220     // Check string exists
221     if (str == nullptr)
222         throw std::exception("Failed to stream string into buffer: string is null\&.", EINVAL);
223 
224     // Calculate string size
225     size_t strLen = std::strlen(str);
226 
227     // Check if stack has enough space
228     if (stack\&.atElement + strLen >= stack\&.max_elements)
229         throw std::exception("Failed to stream string into buffer: operation would cause buffer overflow\&.", EPERM);
230 
231     // Write unsafely (since we already checked everything)
232     for (index_t idx = 0; idx < strLen; idx++)
233         stack <= str[idx];
234 
235     return stack;
236 }
.fi
.PP
References BBP::std::Stack< K >::atElement, EINVAL, EPERM, exception(), BBP::std::Stack< K >::max_elements, and strlen()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<< (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::string\fP & str)"

.PP
Definition at line 258 of file Strings\&.cpp\&.
.PP
.nf
259 {
260     // Fetch the underlying c string
261     std::c_string cstr = std::read_a(&str, 0);
262 
263     // Write that cstring
264     stack <<= cstr;
265 
266     return stack;
267 }
.fi
.PP
References read_a()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & lh, \fBstd::Stack\fP< \fBstd::string_element\fP > & rh)"

.PP
Definition at line 459 of file Strings\&.cpp\&.
.PP
.nf
460 {
461     char c = 0;
462     rh >> c;
463     lh <<= c;
464     return lh;
465 }
.fi
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, char c)"

.PP
Definition at line 195 of file Strings\&.cpp\&.
.PP
.nf
196 {
197     stack << c;
198     stack << (char)0;
199 
200     // If writeTo is defined: execute
201     if (stack\&.writeTo)
202         stack\&.writeTo(&stack);
203 
204     return stack;
205 }
.fi
.PP
References BBP::std::Stack< K >::writeTo\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::c_string\fP str)"

.PP
Definition at line 172 of file Strings\&.cpp\&.
.PP
.nf
173 {
174     stack << str;
175     stack << '\0';
176 
177     // If writeTo is defined: execute
178     if (stack\&.writeTo)
179         stack\&.writeTo(&stack);
180 
181     return stack;
182 }
.fi
.PP
References BBP::std::Stack< K >::writeTo\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::conststring\fP str)"

.PP
Definition at line 160 of file Strings\&.cpp\&.
.PP
.nf
161 {
162     stack << str;
163     stack << '\0';
164 
165     // If writeTo is defined: execute
166     if (stack\&.writeTo)
167         stack\&.writeTo(&stack);
168 
169     return stack;
170 }
.fi
.PP
References BBP::std::Stack< K >::writeTo\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::string\fP & str)"

.PP
Definition at line 184 of file Strings\&.cpp\&.
.PP
.nf
185 {
186     // Fetch the underlying c string
187     std::c_string cstr = std::read_a(&str, 0);
188 
189     // Write that cstring
190     stack <<= cstr;
191 
192     return stack;
193 }
.fi
.PP
References read_a()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator<= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, int value)"

.PP
Definition at line 207 of file Strings\&.cpp\&.
.PP
.nf
208 {
209     // Just write 'value' with the << operator
210     stack << value;
211 
212     // Write '0'
213     stack <<= "";
214 
215     return stack;
216 }
.fi
.SS "void BBP::std::operator<= (\fBstring\fP & dst, \fBc_string\fP src)"

.PP
Definition at line 155 of file Strings\&.cpp\&.
.PP
.nf
156 {
157     BBP::std::strcpy(&dst, src);
158 }
.fi
.PP
References strcpy()\&.
.SS "void BBP::std::operator<= (\fBstring\fP & dst, \fBconststring\fP src)"

.PP
Definition at line 150 of file Strings\&.cpp\&.
.PP
.nf
151 {
152     BBP::std::strcpy(&dst, src);
153 }
.fi
.PP
References strcpy()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator> (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::c_string\fP * str)"

.PP
Definition at line 370 of file Strings\&.cpp\&.
.PP
.nf
371 {
372     // Move pointer back by one\&.
373     stack--;
374 
375     // Check if the current element is not a null character
376     if (stack %= 0)
377         stack--; // If this is the case, move the pointer back one\&.
378 
379     char c = 0; // Allocate char already
380     do
381     {
382         // Peek once character (unsafe since we know where we are)
383         c = stack %= 0;
384 
385         // Check if character is null
386         if (c == 0)
387         {
388             // If null, return here
389             *str = __UNSAFE__(std::read_a)(stack\&.page, stack\&.atElement + 1);
390 
391             // If readFrom is defined: execute
392             if (stack\&.readFrom)
393                 stack\&.readFrom(&stack);
394 
395             return stack;
396         }
397 
398         if (stack\&.atElement == 0)
399             break; // Must be done, logic allows it and WILL cause errors if not handled, even for unsafe functions\&.
400 
401         // Character not null, go back
402         stack--;
403 
404     } while (stack\&.atElement);
405 
406     // Reached element 0, so return element 0\&.
407     *str = __UNSAFE__(std::read_a)(stack\&.page, stack\&.atElement);
408 
409     // If readFrom is defined: execute
410     if (stack\&.readFrom)
411         stack\&.readFrom(&stack);
412 
413     return stack;
414 }
.fi
.PP
References __UNSAFE__, BBP::std::Stack< K >::atElement, BBP::std::Stack< K >::page, read_a(), and BBP::std::Stack< K >::readFrom\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator> (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::string\fP * str)"

.PP
Definition at line 416 of file Strings\&.cpp\&.
.PP
.nf
417 {
418     // Fetch the underlying c string
419     std::c_string cstr;
420     stack > &cstr;
421 
422     // Get the size of the string
423     size_t length = __UNSAFE__(std::strlen)(cstr);
424 
425     // Write that cstring into string
426     __UNSAFE__(std::write_a)(str, cstr, 0, length);
427 
428     // If readFrom is defined: execute
429     if (stack\&.readFrom)
430         stack\&.readFrom(&stack);
431 
432     return stack;
433 }
.fi
.PP
References __UNSAFE__, BBP::std::Stack< K >::readFrom, strlen(), and write_a()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator>> (\fBstd::Stack\fP< \fBstd::string_element\fP > & lh, \fBstd::Stack\fP< \fBstd::string_element\fP > & rh)"

.PP
Definition at line 435 of file Strings\&.cpp\&.
.PP
.nf
436 {
437     char c = 0;
438     lh >> c;
439     rh << c;
440     return lh;
441 }
.fi
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator>>= (\fBstd::Stack\fP< \fBstd::string_element\fP > & lh, \fBstd::Stack\fP< \fBstd::string_element\fP > & rh)"

.PP
Definition at line 451 of file Strings\&.cpp\&.
.PP
.nf
452 {
453     char c = 0;
454     lh >> c;
455     rh <<= c;
456     return lh;
457 }
.fi
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator>>= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::c_string\fP * str)"

.PP
Definition at line 290 of file Strings\&.cpp\&.
.PP
.nf
291 {
292     // Check target exists
293     if (str == nullptr)
294         throw std::exception("Failed to stream string from buffer: string is null\&.", EINVAL);
295 
296     // If stack is already at 0, throw error (since this only occurs if there is 'nothing' in the buffer)
297     if (stack\&.atElement == 0)
298         throw std::exception("Could not stream string from buffer: buffer is empty\&.", EPERM);
299 
300     // Move the pointer back by one
301     stack--;
302 
303     // Check if the current element is not a null character
304     if ((stack %= 0) == 0)
305         stack--; // If this is the case, move the pointer back one\&.
306 
307     // If this caused buffer overflow: return error\&.
308     if (stack\&.atElement > stack\&.max_elements)
309     {
310         stack++; // Rectify the overflow
311         throw std::exception("Failed to stream string from buffer: Caused overflow\&. (rectified)\&.", EPERM);
312     }
313 
314     char c = 0; // Allocate char already
315     do
316     {
317         // Peek once character (unsafe since we know where we are)
318         c = stack %= 0;
319 
320         // Check if character is null
321         if (c == 0)
322         {
323             // If null, return here
324             *str = std::read_a(stack\&.page, stack\&.atElement + 1);
325 
326             // If readFrom is defined: execute
327             if (stack\&.readFrom)
328                 stack\&.readFrom(&stack);
329 
330             return stack;
331         }
332 
333         if (stack\&.atElement == 0)
334             break; // Must be done, logic allows it and WILL cause errors if not handled, even for unsafe functions\&.
335 
336         // Character not null, go back
337         stack--;
338 
339     } while (stack\&.atElement);
340 
341     // Reached element 0, so return element 0\&.
342     *str = __UNSAFE__(std::read_a)(stack\&.page, stack\&.atElement);
343 
344     // If readFrom is defined: execute
345     if (stack\&.readFrom)
346         stack\&.readFrom(&stack);
347 
348     return stack;
349 }
.fi
.PP
References __UNSAFE__, BBP::std::Stack< K >::atElement, EINVAL, EPERM, exception(), BBP::std::Stack< K >::max_elements, BBP::std::Stack< K >::page, read_a(), and BBP::std::Stack< K >::readFrom\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > & BBP::std::operator>>= (\fBstd::Stack\fP< \fBstd::string_element\fP > & stack, \fBstd::string\fP * str)"

.PP
Definition at line 351 of file Strings\&.cpp\&.
.PP
.nf
352 {
353     // Fetch the underlying c string
354     std::c_string cstr;
355     stack >>= &cstr;
356 
357     // Get the size of the string
358     size_t length = std::strlen(cstr);
359 
360     // Write that cstring into string
361     std::write_a(str, cstr, 0, length);
362 
363     // If readFrom is defined: execute
364     if (stack\&.readFrom)
365         stack\&.readFrom(&stack);
366 
367     return stack;
368 }
.fi
.PP
References BBP::std::Stack< K >::readFrom, strlen(), and write_a()\&.
.SS "void BBP::std::print_to_terminal (\fBstd::Stack\fP< \fBstd::string_element\fP > * stack)"

.SS "int BBP::std::printf (\fBstd::conststring\fP format,  \&.\&.\&.)"

.PP
Referenced by BBP::badapple_main(), BBP::esa::esaProcessor::emitProcedure(), BBP::esa::BinaryApplication::emitSymbol(), execute(), exit(), BBP::esa::esaProcessor::includeFile(), BBP::esa::esaProcessor::includeFromPath(), BBP::std::Lexer::lex_context::Log(), BBP::esa::esaProcessor::logInstruction(), BBP::neofetch_main(), BBP::esa::PRAGMA(), BBP::shell(), BBP::shell_main(), and BBP::smile_main()\&.
.SS "int BBP::std::putf (\fBstd::Stack\fP< \fBstd::string_element\fP > & stream, \fBstd::conststring\fP format,  \&.\&.\&.)"

.PP
Referenced by BBP::std::Lexer::lex_context::Highlight(), and BBP::std::Lexer::lex_context::Log()\&.
.SS "template<typename T > T& BBP::std::read (\fBPAGE\fP< T > * page, \fBindex_t\fP index)"

.PP
Referenced by BBP::esa::esaProcessor::addReservedIdentifier(), BBP::std::Stack< BBP::std::DIRECTORY >::all(), BBP::std::Stack< BBP::std::DIRECTORY >::any(), BBP::esa::esaProcessor::buildSymbol(), BBP::std::Lexer::lex_context::calculateDebugPosition(), BBP::std::FILE::checkIfIsOpen(), BBP::std::FILE::data(), BBP::std::ResourceManager::deleteAll(), BBP::esa::BinaryApplication::emitSymbolHash(), BBP::std::ResourceManager::find_Alloc_pointer(), BBP::std::ResourceManager::find_next_empty_alloc(), BBP::std::ResourceManager::find_next_empty_object(), BBP::std::ResourceManager::find_Object_pointer(), BBP::std::FILE::findClosedFile(), BBP::std::Stack< BBP::std::DIRECTORY >::foreach(), BBP::std::ResourceManager::freeAll(), BBP::std::PATH::getFileAndPaths(), BBP::std::Lexer::lex_context::Highlight(), BBP::esa::esaProcessor::includeFile(), BBP::std::PATH::isDefinedFromRoot(), BBP::std::PATH::isRelativeToRoot(), BBP::esa::esaProcessor::lookupSymbol(), BBP::std::Lexer::lex_context::moveToAndHashThisWord(), BBP::std::Lexer::lex_context::moveToEndOfLastWord(), BBP::std::Lexer::lex_context::moveToEndOfThisWord(), BBP::std::Lexer::lex_context::moveToNextKeyword(), BBP::std::Lexer::lex_context::moveToStartOfNextWord(), BBP::std::Lexer::lex_context::moveToStartOfThisWord(), BBP::std::Stack< BBP::std::DIRECTORY >::operator%=(), BBP::std::Stack< BBP::std::DIRECTORY >::operator+=(), BBP::std::Stack< BBP::std::DIRECTORY >::operator>=(), BBP::std::Stack< BBP::std::DIRECTORY >::operator>>(), BBP::std::Stack< BBP::std::DIRECTORY >::operator[](), BBP::std::Lexer::lex_context::parseFile(), BBP::esa::esaProcessor::resolve(), BBP::std::PATH::resolveAbsolutes(), BBP::esa::esaProcessor::setProcedureIdentifier(), BBP::shell(), strlen(), and BBP::std::Lexer::lex_context::tryParseNumerical()\&.
.SS "template<typename T > T& \fB__UNSAFE__\fP() BBP::std::read (\fBPAGE\fP< T > * page, \fBindex_t\fP index)\fC [inline]\fP"

.SS "template<typename T > T* BBP::std::read_a (\fBPAGE\fP< T > * page, \fBindex_t\fP index)"

.PP
Referenced by BBP::std::PATH::fileName(), BBP::std::R2D::GetFontFromFile(), operator<<(), operator<<=(), operator>(), operator>>=(), BBP::std::PATH::pathName(), BBP::shell(), and strhsh()\&.
.SS "template<typename T > T* \fB__UNSAFE__\fP() BBP::std::read_a (\fBPAGE\fP< T > * page, \fBindex_t\fP index)\fC [inline]\fP"

.SS "template<typename T > \fBmem_t\fP* BBP::std::read_ar (\fBPAGE\fP< T > * page, \fBindex_t\fP index)"

.PP
Referenced by BBP::std::R2D::GetFontFromFile()\&.
.SS "template<typename T > \fBmem_t\fP* \fB__UNSAFE__\fP() BBP::std::read_ar (\fBPAGE\fP< T > * page, \fBindex_t\fP index)\fC [inline]\fP"

.SS "template<typename T > \fBmem_t\fP& BBP::std::read_r (\fBPAGE\fP< T > * page, \fBindex_t\fP index)"

.PP
Referenced by BBP::shell()\&.
.SS "template<typename T > \fBmem_t\fP& \fB__UNSAFE__\fP() BBP::std::read_r (\fBPAGE\fP< T > * page, \fBindex_t\fP index)\fC [inline]\fP"

.SS "float BBP::std::rfPartOfNumber (float x)"

.PP
Definition at line 321 of file R2D\&.cpp\&.
.PP
.nf
322         {
323             return 1 - fPartOfNumber(x);
324         }
.fi
.PP
References fPartOfNumber()\&.
.SS "int BBP::std::roundNumber (float x)"

.PP
Definition at line 307 of file R2D\&.cpp\&.
.PP
.nf
308         {
309             return iPartOfNumber(x + 0\&.5);
310         }
.fi
.PP
References iPartOfNumber()\&.
.SS "template<typename T > \fBsize_t\fP BBP::std::seqlen (\fBPAGE\fP< T > & page)"

.PP
Referenced by BBP::std::ELF::SectionBuilder::Append(), BBP::std::ELF::SegmentBuilder::Append(), BBP::std::ELF::ELFBuilder::ELFBuilder(), memcpy(), and BBP::std::Lexer::lex_context::parseFile()\&.
.SS "template<typename T > \fBsize_t\fP \fB__UNSAFE__\fP() BBP::std::seqlen (\fBPAGE\fP< T > & page)"

.SS "template<typename T > \fBsize_t\fP BBP::std::seqlen_r (\fBPAGE\fP< T > & page)"

.SS "template<typename T > \fBsize_t\fP \fB__UNSAFE__\fP() BBP::std::seqlen_r (\fBPAGE\fP< T > & page)"

.SS "\fBPID_t\fP BBP::std::spawnExecutable (\fBexecutable_main\fP, \fBstd::string\fP &)"

.SS "int BBP::std::sprintf (\fBstd::c_string\fP buffer, \fBstd::conststring\fP format,  \&.\&.\&.)"

.PP
Referenced by BBP::badapple_main(), fprintf(), and BBP::std::PATH::makeAbsolutePath()\&.
.SS "void BBP::std::stopCapturingInput ()"

.SS "bool BBP::std::strcmp (\fBstring\fP * sta, \fBc_string\fP stb)"

.SS "bool BBP::std::strcmp (\fBstring\fP * sta, \fBconststring\fP stb)"

.PP
Definition at line 125 of file Strings\&.cpp\&.
.PP
.nf
126 {
127     // If lenghts are unequal, just return false
128     size_t len1 = BBP::std::strlen(str1->data);
129     size_t len2 = BBP::std::strlen(str2);
130 
131     // If lengths are unequal, just return
132     if (len1 != len2)
133         return false;
134 
135     // Loop over each character
136     for (size_t index = 0; index < len1; index++)
137     {
138         // Fetch each character
139         char c1 = std::read(str1, index);
140         char c2 = str2[index];
141 
142         // If characters are unequal, return false
143         if (c1 != c2)
144             return false;
145     }
146     return true;
147 }
.fi
.PP
References BBP::std::PAGE< T >::data, BBP::userspace::read, and strlen()\&.
.SS "void BBP::std::strcpy (\fBc_string\fP dst, \fBconststring\fP src)"

.PP
Definition at line 118 of file Strings\&.cpp\&.
.PP
.nf
119 {
120     size_t len = BBP::std::strlen(src) + 1;
121     for (std::index_t idx = 0; idx < len; idx++)
122         dst[idx] = src[idx];
123 }
.fi
.PP
References strlen()\&.
.SS "void BBP::std::strcpy (\fBstring\fP * dst, \fBc_string\fP src)"

.PP
Definition at line 111 of file Strings\&.cpp\&.
.PP
.nf
112 {
113     size_t len = BBP::std::strlen(src);
114     BBP::std::write_a(dst, src, 0, len + 1);
115 }
.fi
.PP
References strlen(), and write_a()\&.
.SS "void BBP::std::strcpy (\fBstring\fP * dst, \fBconststring\fP src)"

.PP
Definition at line 104 of file Strings\&.cpp\&.
.PP
.nf
105 {
106     BBP::std::c_string cstring = (BBP::std::c_string)src;
107     BBP::std::strcpy(dst, cstring);
108 }
.fi
.PP
Referenced by BBP::std::PATH::makeAbsolutePath(), operator<=(), BBP::std::Lexer::lex_context::parseFile(), BBP::std::PATH::PATH(), and BBP::shell()\&.
.SS "\fBBBP::std::hash_t\fP BBP::std::strhsh (\fBstd::c_string\fP str)"

.PP
Definition at line 477 of file Strings\&.cpp\&.
.PP
.nf
478 {
479     // Hashing constants
480     const int p = 31;
481     const int m = 1e9 + 9;
482 
483     // Working variables
484     std::hash_t hash = 0;
485     uint32_t Power = 1;
486 
487     // Get the size of the string
488     std::size_t length = std::strlen(str);
489 
490     // Actual hashing algorithm\&. Taken from: 
491     for (std::index_t index = 0; index < length; index++)
492     {
493         char c = str[index];
494         hash = (hash + (c - 'a' + 1) * Power) % m;
495         Power = (p * Power) % m;
496     }
497     
498     return hash;
499 }
.fi
.PP
References BBP::Locale::Japanese::hash, and strlen()\&.
.SS "\fBhash_t\fP BBP::std::strhsh (\fBconststring\fP str)"

.SS "void BBP::std::strhsh (\fBstd::hash_t\fP & hash, \fBstd::word\fP & Power, \fBstd::string_element\fP & c)"

.PP
Definition at line 501 of file Strings\&.cpp\&.
.PP
.nf
502 {
503     // Hashing constants
504     const int p = 31;
505     const int m = 1e9 + 9;
506     
507     // Run the hashing equation once
508     hash = (hash + (c - 'a' + 1) * Power) % m;
509     Power = (p * Power) % m;
510 }
.fi
.PP
References BBP::Locale::Japanese::hash\&.
.SS "\fBBBP::std::hash_t\fP BBP::std::strhsh (\fBstd::string\fP & str)"

.PP
Definition at line 467 of file Strings\&.cpp\&.
.PP
.nf
468 {
469     return std::strhsh(std::read_a(&str, 0));
470 }
.fi
.PP
References read_a()\&.
.PP
Referenced by BBP::std::FILE::checkIfIsOpen(), BBP::std::ELF::ELFBuilder::ELFBuilder(), BBP::std::FileNode::FileNode(), and BBP::std::Lexer::lex_context::moveToAndHashThisWord()\&.
.SS "\fBBBP::std::size_t\fP BBP::std::strlen (\fBc_string\fP str)"

.PP
Definition at line 21 of file Strings\&.cpp\&.
.PP
.nf
22 {
23     // Check if string is valid
24     if (str == nullptr)
25         throw BBP::std::exception("Could not calculate string length: string is null\&.", EINVAL);
26 
27     // Create length variable
28     size_t length = 0;
29 
30     for (; str[length]; length++)
31         if (length >= BBP::std::max_string_length)
32             throw BBP::std::exception("Failed to calculate string length: string is calculated to be bigger than maximum permissible size\&.", ENOBUFS);
33 
34     return length;
35 }
.fi
.PP
References EINVAL, ENOBUFS, exception(), and max_string_length\&.
.SS "\fBsize_t\fP BBP::std::strlen (\fBconststring\fP str)"

.PP
Referenced by BBP::esa::esaProcessor::addReservedIdentifier(), BBP::esa::esaProcessor::esaProcessor(), BBP::std::PATH::getFileAndPaths(), BBP::esa::esaProcessor::includeFile(), BBP::std::PATH::isDefinedFromRoot(), BBP::std::PATH::makeAbsolutePath(), BBP::esa::BinaryApplication::mangle(), operator<<(), operator>(), operator>>=(), BBP::std::PATH::PATH(), BBP::std::PATH::resolveAbsolutes(), BBP::shell(), strcmp(), strcpy(), and strhsh()\&.
.SS "\fBBBP::std::size_t\fP BBP::std::strlen (\fBstring\fP & str)"

.PP
Definition at line 37 of file Strings\&.cpp\&.
.PP
.nf
38 {
39     // Create length variable
40     size_t length = 0;
41 
42     for (; BBP::std::read(&str, length); length++)
43         if (length >= BBP::std::max_string_length)
44             throw BBP::std::exception("Failed to calculate string length: string is calculated to be bigger than maximum permissible size\&.", ENOBUFS);
45 
46     return length;
47 }
.fi
.PP
References ENOBUFS, exception(), max_string_length, and read()\&.
.SS "\fBsize_t\fP \fB__UNSAFE__\fP() BBP::std::strlen (\fBstring\fP str)"

.SS "\fBBBP::std::size_t\fP BBP::std::strlen (\fBstring\fP str, \fBoffset_t\fP offset)"

.PP
Definition at line 49 of file Strings\&.cpp\&.
.PP
.nf
50 {
51     // Create length variable
52     size_t length = 0;
53 
54     for (; BBP::std::read(&str, length + offset); length++)
55         if (length >= BBP::std::max_string_length)
56             throw BBP::std::exception("Failed to calculate string length: string is calculated to be bigger than maximum permissible size\&.", ENOBUFS);
57 
58     return length;
59 }
.fi
.PP
References ENOBUFS, exception(), max_string_length, and read()\&.
.SS "void BBP::std::swap (int * a, int * b)"

.PP
Definition at line 286 of file R2D\&.cpp\&.
.PP
.nf
287         {
288             int temp = *a;
289             *a = *b;
290             *b = temp;
291         }
.fi
.PP
References BBP::Locale::Japanese::a\&.
.PP
Referenced by BBP::std::R2D::Line()\&.
.SS "template<typename T > void BBP::std::write (\fBPAGE\fP< T > * page, T & data, \fBindex_t\fP index)"

.PP
Referenced by BBP::std::ResourceManager::add_alloc(), BBP::esa::esaProcessor::addReservedIdentifier(), BBP::std::R2D::background(), BBP::esa::esaProcessor::buildSymbol(), BBP::esa::BinaryApplication::emitSymbolHash(), BBP::std::PATH::getFileAndPaths(), BBP::esa::esaProcessor::includeFile(), BBP::std::Stack< BBP::std::DIRECTORY >::operator<<(), BBP::std::Stack< BBP::std::DIRECTORY >::operator<=(), BBP::std::PATH::resolveAbsolutes(), BBP::std::ResourceManager::ResourceManager(), and BBP::esa::esaProcessor::setProcedureIdentifier()\&.
.SS "template<typename T > void \fB__UNSAFE__\fP() BBP::std::write (\fBPAGE\fP< T > * page, T & data, \fBindex_t\fP index)\fC [inline]\fP"

.SS "template<typename T > void BBP::std::write_a (\fBPAGE\fP< T > * page, T * data, \fBindex_t\fP index, \fBsize_t\fP amount)"

.PP
Referenced by operator>(), operator>>=(), and strcpy()\&.
.SS "template<typename T > void \fB__UNSAFE__\fP() BBP::std::write_a (\fBPAGE\fP< T > * page, T * data, \fBindex_t\fP index, \fBsize_t\fP amount)\fC [inline]\fP"

.SS "template<typename T > void BBP::std::write_ar (\fBPAGE\fP< T > * page, \fBmem_t\fP * data, \fBindex_t\fP index, \fBsize_t\fP amount)"

.SS "template<typename T > void BBP::std::write_r (\fBPAGE\fP< T > * page, \fBmem_t\fP & data, \fBindex_t\fP index)"

.SS "template<typename T > void \fB__UNSAFE__\fP() BBP::std::write_r (\fBPAGE\fP< T > * page, \fBmem_t\fP & data, \fBindex_t\fP index)\fC [inline]\fP"

.SH "Variable Documentation"
.PP 
.SS "volatile bool BBP::std::_echoStuffToTerminal"

.SS "volatile bool BBP::std::_waitforline"

.SS "\fBBBP::std::PID_t\fP BBP::std::activeExecutable = 0"

.PP
Definition at line 12 of file Executable\&.cpp\&.
.PP
Referenced by execute()\&.
.SS "\fBResourceManager\fP* BBP::std::activemem"

.PP
Referenced by BBP::badapple_main(), BBP::std::FILE::close(), BBP::esa::esaProcessor::discardAndClose(), execute(), BBP::std::FILE::FILE(), fprintf(), BBP::esa::esaProcessor::saveAndClose(), BBP::esa::esaProcessor::setupBackend(), BBP::shell(), and BBP::smile_main()\&.
.SS "const typedef \fBstring_element\fP* BBP::std::conststring"

.PP
Definition at line 29 of file Strings\&.h\&.
.PP
Referenced by BBP::esa::ACTION(), BBP::esa::esaProcessor::buildSymbol(), BBP::esa::esaProcessor::resolve(), and BBP::esa::TOKEN()\&.
.SS "const \fBstd::conststring\fP BBP::std::endl = '\\n'"

.PP
Definition at line 139 of file Strings\&.h\&.
.PP
Referenced by BBP::std::ResourceManager::_delete(), exception(), BBP::std::FILE::finish(), BBP::std::ResourceManager::free(), BBP::std::Lexer::lex_context::Highlight(), BBP::std::Lexer::lex_context::LogAbort(), BBP::std::Lexer::lex_context::LogError(), BBP::std::Lexer::lex_context::LogNote(), BBP::std::Lexer::lex_context::LogWarning(), and BBP::std::ResourceManager::mark_deleted()\&.
.SS "const \fBBBP::std::Executable\fP BBP::std::executables = {{\fBshell_main\fP, '/proc/\fBshell\fP'}}"

.PP
Definition at line 7 of file Executable\&.cpp\&.
.SS "\fBstd::STATIC_PAGE\fP<\fBFileNode\fP, \fBmax_open_files\fP> BBP::std::fileTable"

.PP
Referenced by BBP::std::FILE::checkIfIsOpen(), BBP::std::FILE::close(), BBP::std::FILE::data(), BBP::std::FILE::FILE(), BBP::std::FILE::findClosedFile(), BBP::std::FILE::getINodeIndex(), and BBP::std::FILE::is_open()\&.
.SS "bool BBP::std::gINIT"

.SS "\fBstd::window\fP BBP::std::kernelDisplay"

.PP
Referenced by execute()\&.
.SS "constexpr \fBsize_t\fP BBP::std::max_allocations = 1000\fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 17 of file Resources\&.h\&.
.SS "constexpr \fBword\fP BBP::std::max_lpage_static_size = 0x2000\fC [constexpr]\fP"

.PP
Definition at line 30 of file Memory\&.h\&.
.SS "constexpr \fBsize_t\fP BBP::std::max_objects = 1000\fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 16 of file Resources\&.h\&.
.SS "constexpr \fBstd::size_t\fP BBP::std::max_open_files = 32\fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 28 of file FileSys\&.h\&.
.SS "constexpr \fBword\fP BBP::std::max_page_elements = 20000\fC [constexpr]\fP"

.PP
Definition at line 18 of file Memory\&.h\&.
.PP
Referenced by fprintf(), and BBP::std::PATH::makeAbsolutePath()\&.
.SS "constexpr \fBword\fP BBP::std::max_page_pointer_size = \fBmax_page_elements\fP\fC [constexpr]\fP"

.PP
Definition at line 24 of file Memory\&.h\&.
.SS "constexpr \fBword\fP BBP::std::max_page_sequence_length = 64\fC [constexpr]\fP"

.PP
Definition at line 27 of file Memory\&.h\&.
.SS "constexpr \fBword\fP BBP::std::max_page_static_size = 20000\fC [constexpr]\fP"

.PP
Definition at line 21 of file Memory\&.h\&.
.PP
Referenced by BBP::std::STATIC_PAGE< std::index_t, 32 >::STATIC_PAGE()\&.
.SS "constexpr \fBstd::size_t\fP BBP::std::max_path_length = 128\fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 29 of file FileSys\&.h\&.
.SS "const \fBsize_t\fP BBP::std::max_string_length = 0xFFFF"

.PP
Definition at line 33 of file Strings\&.h\&.
.PP
Referenced by strlen()\&.
.SS "\fBVOLUME\fP* BBP::std::primaryVolume"

.PP
Referenced by BBP::std::FILE::FILE(), and BBP::esa::esaProcessor::includeFromPath()\&.
.SS "\fBStack\fP<\fBexecutableFrame\fP> BBP::std::Processes"

.SS "\fBBBP::std::STATIC_PAGE\fP< \fBBBP::std::executableFrame\fP, 12 > BBP::std::procFrames"

.PP
Definition at line 9 of file Executable\&.cpp\&.
.PP
Referenced by execute()\&.
.SS "\fBResourceManager\fP BBP::std::progmem"

.PP
Referenced by execute()\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGABRT = 6\fC [constexpr]\fP"

.PP
Definition at line 32 of file Signal\&.h\&.
.PP
Referenced by exit()\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGADJ = 150\fC [constexpr]\fP"

.PP
Definition at line 35 of file Signal\&.h\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGFPE = 7\fC [constexpr]\fP"

.PP
Definition at line 33 of file Signal\&.h\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGILL = 5\fC [constexpr]\fP"

.PP
Definition at line 31 of file Signal\&.h\&.
.PP
Referenced by execute(), and BBP::smile_main()\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGINT = 4\fC [constexpr]\fP"

.PP
Definition at line 30 of file Signal\&.h\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGINV = 1\fC [constexpr]\fP"

.PP
Definition at line 27 of file Signal\&.h\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGSEGV = 3\fC [constexpr]\fP"

.PP
Definition at line 29 of file Signal\&.h\&.
.PP
Referenced by BBP::std::ResourceManager::_delete(), BBP::std::ELF::SectionBuilder::Append(), BBP::std::ELF::SegmentBuilder::Append(), BBP::std::ELF::SectionBuilder::close(), BBP::std::ELF::SegmentBuilder::close(), BBP::std::ELF::SectionBuilder::Extend(), and BBP::std::ResourceManager::free()\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGSHTDN = 8\fC [constexpr]\fP"

.PP
Definition at line 34 of file Signal\&.h\&.
.PP
Referenced by execute(), and BBP::logout_main()\&.
.SS "constexpr \fBsignal_t\fP BBP::std::SIGTERM = 2\fC [constexpr]\fP"

.PP
Definition at line 28 of file Signal\&.h\&.
.SS "const \fBstd::conststring\fP BBP::std::space = ' '"

.PP
Definition at line 138 of file Strings\&.h\&.
.SS "\fBstd::Stack\fP<\fBstd::string_element\fP> BBP::std::STDERR"

.PP
Referenced by BBP::std::ResourceManager::_delete(), exception(), execute(), BBP::std::ResourceManager::free(), and BBP::std::ResourceManager::mark_deleted()\&.
.SS "\fBstd::Stack\fP<\fBstd::string_element\fP> BBP::std::STDIN"

.PP
Referenced by BBP::shell_main()\&.
.SS "\fBstd::Stack\fP<\fBstd::string_element\fP> BBP::std::STDOUT"

.PP
Referenced by execute(), BBP::std::Lexer::lex_context::Highlight(), BBP::std::Lexer::lex_context::Log(), BBP::std::Lexer::lex_context::LogAbort(), BBP::std::Lexer::lex_context::LogError(), BBP::std::Lexer::lex_context::LogNote(), BBP::std::Lexer::lex_context::LogWarning(), and BBP::shell_main()\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > \fBBBP::std::STDERR\fP & BBP::std::str_STDERR"

.PP
Definition at line 5 of file stdio\&.cpp\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > \fBBBP::std::STDIN\fP & BBP::std::str_STDIN"

.PP
Definition at line 4 of file stdio\&.cpp\&.
.SS "\fBBBP::std::Stack\fP< \fBBBP::std::string_element\fP > \fBBBP::std::STDOUT\fP & BBP::std::str_STDOUT"

.PP
Definition at line 3 of file stdio\&.cpp\&.
.SS "const typedef \fBustring_element\fP* BBP::std::uconststring"

.PP
Definition at line 30 of file Strings\&.h\&.
.SS "\fBResourceManager\fP BBP::std::vmem"

.PP
Definition at line 33 of file R2D\&.cpp\&.
.PP
Referenced by BBP::std::R2D::GetFontFromFile(), and BBP::std::R2D::newWindow()\&.
.SS "\fBPATH\fP* BBP::std::workingDirectory"

.PP
Referenced by BBP::std::FileNode::FileNode(), BBP::std::FILE::getINodeIndex(), BBP::shell(), BBP::shell_main(), and BBP::std::Lexer::lex_context::translateUnit()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for BBP Embedded kernel from the source code\&.
